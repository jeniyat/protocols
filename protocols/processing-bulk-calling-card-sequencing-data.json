{"id":20139,"title":"Processing Bulk Calling Card Sequencing Data","title_html":"Processing Bulk Calling Card Sequencing Data","image":{"source":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/bs6q4s6w.png","placeholder":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/bs6q4s6w.png"},"doi":"dx.doi.org\/10.17504\/protocols.io.xwjfpcn","doi_status":2,"uri":"processing-bulk-calling-card-sequencing-data-xwjfpcn","type_id":1,"published_on":1572021017,"parent_protocols":[],"parent_collections":[],"version_id":0,"created_on":1549581596,"categories":null,"creator":{"name":"Arnav Moudgil","affiliation":"Washington University, Saint Louis","affiliations":[{"affiliation":"Washington University, Saint Louis","url":"http:\/\/genetics.wustl.edu\/rmlab\/","is_default":1}],"username":"arnav-moudgil","link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bcqga.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/bcqga.jpg"},"badges":[{"id":3,"image":{"source":"\/img\/badges\/silver.svg","placeholder":"\/img\/badges\/silver.svg"},"name":"Power author!"}],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"journal":null,"journal_name":null,"journal_link":null,"article_citation":null,"public":1,"has_versions":0,"link":null,"total_collections":0,"number_of_steps":17,"authors":[{"name":"Arnav Moudgil","affiliation":"Washington University, Saint Louis","affiliations":[],"username":"arnav-moudgil","link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bcqga.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/bcqga.jpg"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},{"name":"Rob Mitra","affiliation":"Washington University, Saint Louis","affiliations":[],"username":"rob-mitra","link":null,"image":{"source":"\/img\/avatars\/013.png","placeholder":"\/img\/avatars\/013.png"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false}],"versions":[],"groups":[{"id":1136,"uri":"calling-cards","title":"Transposon Calling Cards","image":{"source":"https:\/\/www.protocols.io\/img\/group_placeholder.png","placeholder":"https:\/\/www.protocols.io\/img\/group_placeholder.png"},"tech_support":{"email":null,"phone":null,"hide_contact":0,"use_email":0},"is_member":1,"request":{"id":1136,"uri":"calling-cards","title":"Transposon Calling Cards","image":{"source":"https:\/\/www.protocols.io\/img\/group_placeholder.png","placeholder":"https:\/\/www.protocols.io\/img\/group_placeholder.png"},"tech_support":{"email":null,"phone":null,"hide_contact":0,"use_email":0},"is_member":1,"description":null,"research_interests":null,"website":null,"location":null,"affiliation":null,"status":{"is_visible":true,"access_level":0},"stats":{"files":[],"total_members":0,"total_followers":0,"total_child_groups":0,"total_parent_groups":0,"has_collaborations":0},"user_status":{"is_member":true,"is_confirmed":true,"is_invited":false,"is_owner":true,"is_admin":false,"is_following":false},"join_link":null,"token":null,"owner":{"name":" ","affiliation":null,"affiliations":[],"username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"is_protocol_requested":0,"is_group_requested":0,"is_my":false,"is_request":false,"is_confirmed":1,"is_declined":0,"requester":{"name":" ","affiliation":null,"affiliation_url":null,"username":null,"link":null},"protocol":{"id":0,"title":"Processing Bulk Calling Card Sequencing Data","title_html":"Processing Bulk Calling Card Sequencing Data","image":{"source":null,"placeholder":null},"doi":null,"doi_status":0,"uri":"processing-bulk-calling-card-sequencing-data-xwjfpcn","type_id":1,"published_on":null,"stats":{"number_of_views":0,"number_of_steps":0,"number_of_bookmarks":0,"number_of_comments":0,"number_of_exports":0,"number_of_runs":0,"number_of_votes":0,"is_voted":0},"parent_protocols":[],"parent_collections":[]},"created_on":1572021016,"resolve_on":0,"resolved_user":{"name":" ","affiliation":null,"affiliations":[],"username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"shared":false}}],"has_subprotocols":0,"is_subprotocol":0,"is_bookmarked":0,"can_be_copied":1,"can_remove_fork":1,"forks_count":{"private":0,"public":0},"access":{"can_view":1,"can_remove":0,"can_add":0,"can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":1,"can_move":1,"can_move_outside":1,"can_transfer":1,"can_download":1,"is_locked":0},"guid":"885F7C85B9DA11E99CA40242AC110005","steps":[{"id":774600,"guid":"659AC5709D0511E98172456EA9B23331","previous_id":778017,"previous_guid":"FABD28B0A26811E9A533C994DAFFA939","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"4F6D5D6E9A0A4B56AFD00E2F5EE062FA","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preamble"}},{"id":1054724,"guid":"5325E245BC8B4E91B61AEB06A6FCD146","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>To illustrate the workflow, let's say that we have performed bulk RNA calling cards on our favorite transcription factor (YFTF) in a human cell line. We have prepared libraries from 10 biological replicates of cells transfected with wild-type <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> transposase, and 10 replicates of cells with YFTF-<\/span><span style = \"font-style:italic;\">piggyBac<\/span><span>. We have sequenced these libraries and now need to map these insertions across the genome.<\/span><\/div><div class = \"text-block\">We will consider a single replicate; the workflow can then be repeated for all remaining replicates. At the end we can combine the data from the 10 piggyBac replicates, and the 10 YFTF-piggyBac replicates, respectively, into a single CCF file each.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","critical":null,"critical_id":null,"duration":0},{"id":774608,"guid":"832913B09D0711E98172456EA9B23331","previous_id":774600,"previous_guid":"659AC5709D0511E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"2E19120E61DC47339039B4FC8634132C","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preamble"}},{"id":1054724,"guid":"AB79090DD519425B926D2A5F613707DF","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>In this example, we will be analyzing a single replicate from the wild-type <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> libraries: PBase_rep1. The read 1 sequencing file is PBase_rep1_L001_R1_001.fastq.gz<\/span><\/div><div class = \"text-block\">This biological replicate had GAT as its primer barcode and CTCACGGTGA as its index sequence. It was prepared by PCR ligation with the following primers:<\/div><div class = \"text-block\">>OM-PB-GAT (barcode in bolded)<\/div><div class = \"text-block\"><span>AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT<\/span><span style = \"font-weight:bold;\">GAT<\/span><span>TTTACGCAGACTATCTTTCTAG<\/span><\/div><div class = \"text-block\">>Nextera_N7_CTCACGGTGA (index in bold; note the reverse complement orientation)<\/div><div class = \"text-block\"><span>CAAGCAGAAGACGGCATACGAGAT<\/span><span style = \"font-weight:bold;\">TCACCGTGAG<\/span><span>GTCTCGTGGGCTCGG<\/span><\/div><div class = \"text-block\"><span>Thus, each read 1 <\/span><span style = \"font-style:italic;\">should<\/span><span> begin with GATTTTACGCAGACTATCTTTCTAG.<\/span><\/div><\/div>"}},{"id":1054725,"guid":"62D5A2327B454912AEBCC5FCDC508157","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\">For bulk RNA calling card libraries, only read 1 is analyzed, as it contains the junction between the transposon and genome.<\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","critical":null,"critical_id":null,"duration":0},{"id":774621,"guid":"4DDCC0109D0911E98172456EA9B23331","previous_id":774608,"previous_guid":"832913B09D0711E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"28BE7F46DE714605B01D2DD409407057","order_id":1,"type_id":6,"title":"Section","source":{"title":"Adapter Trimming"}},{"id":1054724,"guid":"0F9F963B74034C1E967FC8DC29A448B5","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>The purpose of this step is to check that reads have (1) the appropriate primer barcode sequence and (2) the transposon sequence is correct and ends in TTAA, <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span>'s insertion motif. If these conditions are true, those bases are trimmed (hard clipped), to facilitate genomic alignment. Only reads with perfect matches to the barcode and transposon sequence are carried forward.<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">cutadapt \\<\/div><div class = \"text-block\">    -g ^GATTTTACGCAGACTATCTTTCTAGGGTTAA \\<\/div><div class = \"text-block\">    --minimum-length 1 \\<\/div><div class = \"text-block\">    --discard-untrimmed \\<\/div><div class = \"text-block\">    -e 0 \\<\/div><div class = \"text-block\">    --no-indels \\<\/div><div class = \"text-block\">    -o PBase_rep1_trimBC.fastq.gz \\<\/div><div class = \"text-block\">    PBase_rep1_L001_R1_001.fastq.gz<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Typically 70-90% of reads will pass this filter, although there may be sample-dependent variation.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","critical":null,"critical_id":null,"duration":0},{"id":774677,"guid":"E5F4CBD09D0A11E98172456EA9B23331","previous_id":774621,"previous_guid":"4DDCC0109D0911E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"5284011A05F5444E98492A9B430C604D","order_id":1,"type_id":6,"title":"Section","source":{"title":"Adapter Trimming"}},{"id":1054724,"guid":"B60606EAAF6F47F8981FC910556FC3B7","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Next, we re-examine the passing reads and trim any reads that end in the Nextera adapter that was added during tagmentation. This step reduces the amount of non-genomic bases, which should accelerate alignment. Only a small fraction (5-10%) typically have any adapter sequence at all, so virtually every read will pass this filter.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">cutadapt \\<\/div><div class = \"text-block\"><span>    -a CTGTCTCTTATACACATCTCCGAGCCCACGAGACT<\/span><span style = \"font-weight:bold;\">CTCACGGTGA<\/span><span>TCTCGTATGCCGTCTTCTGCTTG \\<\/span><\/div><div class = \"text-block\">    --minimum-length 1 \\<\/div><div class = \"text-block\">    -o PBase_rep1_trimmed.fastq.gz \\<\/div><div class = \"text-block\">    Base_rep1_trimBC.fastq.gz<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">The index sequence has been emphasized in bold, but if you are processing libraries with many index different indexes, you can replace the bolded sequence with N's (keeping the length same). cutadapt can handle degenerate bases in adapters.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","critical":null,"critical_id":null,"duration":0},{"id":774679,"guid":"20B67E709D0C11E98172456EA9B23331","previous_id":774677,"previous_guid":"E5F4CBD09D0A11E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"59D50EB719B54CB29D3726C0C75D82D8","order_id":1,"type_id":6,"title":"Section","source":{"title":"Alignment"}},{"id":1054724,"guid":"582180A9EE054AE1B4C5E5ED500D40F0","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Now that our reads are trimmed, we are ready to align them to the genome. This step can be done with any aligner; we typically use novoalign, so that is what we will demonstrate here.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">novoalign \\<\/div><div class = \"text-block\">    -d hg38.nvx \\<\/div><div class = \"text-block\">    -f PBase_rep1_trimmed.fastq.gz \\<\/div><div class = \"text-block\">    -n 40 \\<\/div><div class = \"text-block\">    -o SAM \\<\/div><div class = \"text-block\">    -o SoftClip > PBase_rep1_trimmed.sam<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">The \"-n 40\" flag tells novoalign to align only the first 40 bases of the read. We have found that this reduction can increase the speed of alignment with minimal impact on total number of insertions recovered. Faster aligners (e.g. bowtie2, GATK, STAR) may not need this setting.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","critical":null,"critical_id":null,"duration":0},{"id":774682,"guid":"25F5A7B09D0E11E98172456EA9B23331","previous_id":774688,"previous_guid":"9B1474309D0F11E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"01ADE4FB249E49129D182F3142AF5C44","order_id":1,"type_id":6,"title":"Section","source":{"title":"Annotation"}},{"id":1054724,"guid":"A1536215FF6E490AAD8A1D74B0FA0857","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">The BAM format provides a flexible way to annotate reads through the use of short tags. These tags remain with the reads in the BAM file, which makes for a simple and portable archive of a calling card experiment. We use the following custom tags:<\/div><div class = \"text-block\"><ul style = \"list-style-type:disc;\"><li style = \"counter-reset:ol0;list-style-type:disc;\">XP: primer barcode<\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">XJ: index 1 sequence<\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">XK: index 2 sequence (optional; reserved for future use)<\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">XI: insertion site annotation<\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">XZ: adjacent sequence (to verify transposase motif)<\/li><\/ul><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","critical":null,"critical_id":null,"duration":0},{"id":774683,"guid":"E66CE5309D0E11E98172456EA9B23331","previous_id":774682,"previous_guid":"25F5A7B09D0E11E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"815D79C4AA964CD99E058C3B9BF63221","order_id":1,"type_id":6,"title":"Section","source":{"title":"Annotation"}},{"id":1054724,"guid":"21655FAD93D844DF9729F441A9675CC1","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">First, we will annotate reads with the XP tag for the primer barcode GAT.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python TagBam.py \\<\/div><div class = \"text-block\">    --tag XP:Z:GAT \\<\/div><div class = \"text-block\">    PBase_rep1_mapped.bam \\<\/div><div class = \"text-block\">    PBase_rep1_tagged.bam<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","critical":null,"critical_id":null,"duration":0},{"id":774684,"guid":"127490109D0F11E98172456EA9B23331","previous_id":774683,"previous_guid":"E66CE5309D0E11E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"592D90835FB54549A3DDDF57C03CD1D6","order_id":1,"type_id":6,"title":"Section","source":{"title":"Annotation"}},{"id":1054724,"guid":"4676E89F3F5C4F3690794DE38A31DD01","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Next, we will annotate reads with the XJ tag for the index sequence CTCACGGTGA.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python TagBam.py \\<\/div><div class = \"text-block\">    --tag XJ:Z:CTCACGGTGA \\<\/div><div class = \"text-block\">    PBase_rep1_tagged.bam \\<\/div><div class = \"text-block\">    PBase_rep1_tagged2.bam<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","critical":null,"critical_id":null,"duration":0},{"id":774685,"guid":"36CDFB909D0F11E98172456EA9B23331","previous_id":774684,"previous_guid":"127490109D0F11E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"35DB6B002F0D4E618A16EDC2272A707F","order_id":1,"type_id":6,"title":"Section","source":{"title":"Annotation"}},{"id":1054724,"guid":"CF1B29B3BFAC46478EB5F560D4463E6B","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Lastly, we will annotate reads with respect to the insertion site. This script checks each read to make sure that it maps next to the <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> insertion site motif TTAA. Remember, this part of read 1 was trimmed in step 4. By double checking that the read maps next to a genomic TTAA, we add an extra layer of specificity to the alignment. The sequence of the adjacent bases will also be annotated with the XZ tag. Reads that pass will be annotated with the insertion site coordinates in the XI tag and written to the output file.<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python AnnotateInsertionSites.py \\<\/div><div class = \"text-block\">    --transposase PB \\<\/div><div class = \"text-block\">    -f \\<\/div><div class = \"text-block\">    PBase_rep1_tagged2.bam \\<\/div><div class = \"text-block\">    hg38.2bit \\<\/div><div class = \"text-block\">    PBase_rep1_final.bam<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">You can provide a path to the .2bit file if your genome references are in another directory.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","critical":null,"critical_id":null,"duration":0},{"id":774688,"guid":"9B1474309D0F11E98172456EA9B23331","previous_id":774679,"previous_guid":"20B67E709D0C11E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"3E8801762A034595864F3648BF32B8DD","order_id":1,"type_id":6,"title":"Section","source":{"title":"Alignment"}},{"id":1054724,"guid":"19AD0D823EBC42F8946540CAF48EE616","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">After alignment, we filter out reads that mapped to multiple locations in the genome (e.g. in a repetitive element) and convert to the more space-efficient BAM format.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">samtools view \\<\/div><div class = \"text-block\">    -bS -h -F 260 \\<\/div><div class = \"text-block\">    PBase_rep1_trimmed.sam | \\<\/div><div class = \"text-block\">    samtools sort - -o PBase_rep1_mapped.bam<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","critical":null,"critical_id":null,"duration":0},{"id":774690,"guid":"E89EA7609D1011E98172456EA9B23331","previous_id":774685,"previous_guid":"36CDFB909D0F11E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"63D101FA40A54C3998E2898DCB310E2E","order_id":1,"type_id":6,"title":"Section","source":{"title":"Finishing Up"}},{"id":1054724,"guid":"349F0DF70C144921B1981B74AB5362A3","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">To finish, we first index the BAM file.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"><a href=\"#\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">samtools index <\/span><\/a><span>PBase_rep1_final.bam<\/span><\/div><div class = \"text-block\"><pre><code>samtools index\u00a0$out_map_sort_prefix\"_final.bam\"<\/code><\/pre><\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#EA9F6C","critical":null,"critical_id":null,"duration":0},{"id":774691,"guid":"1FD099009D1111E98172456EA9B23331","previous_id":774690,"previous_guid":"E89EA7609D1011E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"12F92180D63C45CF86BC751806C40301","order_id":1,"type_id":6,"title":"Section","source":{"title":"Finishing Up"}},{"id":1054724,"guid":"26AB1797DCAB4B0BA8EBE1B4EDB80158","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Next, clean up intermediate files.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">rm PBase_rep1_trimBC.fastq.gz<\/div><div class = \"text-block\">rm PBase_rep1_trimmed.fastq.gz<\/div><div class = \"text-block\">rm PBase_rep1_trimmed.sam<\/div><div class = \"text-block\">rm PBase_rep1_mapped.bam<\/div><div class = \"text-block\">rm PBase_rep1_tagged.bam<\/div><div class = \"text-block\">rm PBase_rep1_tagged2.bam<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#EA9F6C","critical":null,"critical_id":null,"duration":0},{"id":774693,"guid":"4BBA34909D1111E98172456EA9B23331","previous_id":774694,"previous_guid":"087C80609D1211E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"8F5DFEF761A141D0A8CCAF70F15FF82C","order_id":1,"type_id":6,"title":"Section","source":{"title":"Notes"}},{"id":1054724,"guid":"F3ACCEA720834DCA8A58C7C6CD929C35","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>This workflow described how to process a <\/span><span style = \"font-weight:bold;\">SINGLE<\/span><span> biological replicate. After each replicate has been processed, CCF files can be combined to consolidate all insertions from a given experiment. For example, to combine data from all replicates from our wild-type <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> libraries, we can use cat and bedops (preferred):<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">cat \\<\/div><div class = \"text-block\">PBase_rep1_final.ccf \\<\/div><div class = \"text-block\">PBase_rep2_final.ccf \\<\/div><div class = \"text-block\">PBase_rep3_final.ccf \\<\/div><div class = \"text-block\">PBase_rep4_final.ccf \\<\/div><div class = \"text-block\">PBase_rep5_final.ccf \\<\/div><div class = \"text-block\">PBase_rep6_final.ccf \\<\/div><div class = \"text-block\">PBase_rep7_final.ccf \\<\/div><div class = \"text-block\">PBase_rep8_final.ccf \\<\/div><div class = \"text-block\">PBase_rep9_final.ccf \\<\/div><div class = \"text-block\">PBase_rep10_final.ccf | sort-bed - > PBase.ccf<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Similarly, CCFs from the YFTF replicates can be combined:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">cat YFTF-PBase_rep*_final.ccf | sort-bed - > YFTF-PBase.ccf<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">The concatenated CCF files can also be sorted using bedtools:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">cat PBase_rep*_final.ccf | bedtools sort -i - > PBase.ccf<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Or, using the standard shell sort command:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">cat PBase_rep*_final.ccf | sort -k1V -k2n -k3n > PBase.ccf<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#E57785","critical":null,"critical_id":null,"duration":0},{"id":774694,"guid":"087C80609D1211E98172456EA9B23331","previous_id":774691,"previous_guid":"1FD099009D1111E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"CD200D0482D94FF38A9042FD1BB9EA5A","order_id":1,"type_id":6,"title":"Section","source":{"title":"Finishing Up"}},{"id":1054724,"guid":"37348C38027B46688574A0C0033998F5","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Lastly, convert the BAM file to a CCF file.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"><a href=\"#\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">python BamToCallingCard.py \\<\/span><\/a><\/div><div class = \"text-block\"><pre><code>python BamToCallingCard.py\u00a0-bXP XJ\u00a0-i$out_map_sort_prefix\"_final.bam\"-o$out_map_sort_prefix\"_final.ccf\"<\/code><\/pre><\/div><div class = \"text-block\"><span>    <\/span><a href=\"#\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">-b XP XJ \\<\/span><\/a><\/div><div class = \"text-block\"><pre><code>python BamToCallingCard.py\u00a0-bXP XJ\u00a0-i$out_map_sort_prefix\"_final.bam\"-o$out_map_sort_prefix\"_final.ccf\"<\/code><\/pre><\/div><div class = \"text-block\"><span>    <\/span><a href=\"#\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">-i <\/span><\/a><span>PBase_rep1_final.bam<\/span><a href=\"#\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\"> \\<\/span><\/a><\/div><div class = \"text-block\"><pre><code>python BamToCallingCard.py\u00a0-bXP XJ\u00a0-i$out_map_sort_prefix\"_final.bam\"-o$out_map_sort_prefix\"_final.ccf\"<\/code><\/pre><\/div><div class = \"text-block\"><pre><code>python BamToCallingCard.py\u00a0-bXP XJ\u00a0-i$out_map_sort_prefix\"_final.bam\"-o$out_map_sort_prefix\"_final.ccf\"<\/code><\/pre><\/div><div class = \"text-block\"><span>    <\/span><a href=\"#\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">-o <\/span><\/a><span>PBase_rep1_final.ccf<\/span><\/div><div class = \"text-block\"><pre><code>python BamToCallingCard.py\u00a0-bXP XJ\u00a0-i$out_map_sort_prefix\"_final.bam\"-o$out_map_sort_prefix\"_final.ccf\"<\/code><\/pre><\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">This will use the combination of primer barcode and index sequence (XP and XJ, respectively) to identify insertions derived from different biological replicates.<\/div><div class = \"text-block\">Here is an example of a CCF file:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">chr1\t28575\t28579\t2\t+\tGCA\/TCGCCACCC<\/div><div class = \"text-block\">chr1\t28575\t28579\t10\t+\tTAG\/GAGGTACAG<\/div><div class = \"text-block\">chr1\t28575\t28579\t1\t+\tGAT\/GAGGTACAG<\/div><div class = \"text-block\">chr1\t31191\t31195\t1\t+\tGCA\/TCGCCACCC<\/div><div class = \"text-block\">chr1\t31191\t31195\t49\t+\tTAG\/TCGCCACCC<\/div><div class = \"text-block\">chr1\t46620\t46624\t5\t+\tCTA\/GAGGTACAG<\/div><div class = \"text-block\">chr1\t54136\t54140\t42\t-\tGCA\/TCGCCACCC<\/div><div class = \"text-block\">chr1\t54818\t54822\t16\t-\tCTA\/TCGCCACCC<\/div><div class = \"text-block\">chr1\t57829\t57833\t6\t-\tCGT\/GAGGTACAG<\/div><div class = \"text-block\">chr1\t58414\t58418\t40\t+\tCTA\/TCGCCACCC<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#EA9F6C","critical":null,"critical_id":null,"duration":0},{"id":774697,"guid":"BE48E0509D1211E98172456EA9B23331","previous_id":774693,"previous_guid":"4BBA34909D1111E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"3180E22289C04D6C939A0A5C9F9FCAD2","order_id":1,"type_id":6,"title":"Section","source":{"title":"Notes"}},{"id":1054724,"guid":"12AB2DF858F441B59CAE89D9CD698D03","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Analogously, we can combine BAM files from biological replicates into a single archival-quality BAM file for an entire experiment:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">samtools merge PBase.bam PBase_rep*_final.bam<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#E57785","critical":null,"critical_id":null,"duration":0},{"id":774698,"guid":"A2D46A009D1311E98172456EA9B23331","previous_id":774697,"previous_guid":"BE48E0509D1211E98172456EA9B23331","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"88C44A04D1544BCB9AE36A6AA9781B17","order_id":1,"type_id":6,"title":"Section","source":{"title":"Notes"}},{"id":1054724,"guid":"000CF2CBD3AA490F88B97880DAB68741","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Ideally, each biological replicate will have a unique primer barcode AND unique index sequence. However, sometimes this is not possible. If so, each replicate should be identifiable from a unique combination of primer barcode and index sequence. If multiple replicates share an index, their reads will be found in the same FASTQ file. This is okay as step 3 can separate each replicate based on an exact match to the primer barcode sequence. In that case, you will have to provide the same input file to step 4 multiple times, each with a different primer barcode at the start of the adapter.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#E57785","critical":null,"critical_id":null,"duration":0},{"id":778017,"guid":"FABD28B0A26811E9A533C994DAFFA939","previous_id":null,"previous_guid":null,"modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"5863F2968E2A4596A8082812DCC75A1B","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preamble"}},{"id":1054724,"guid":"8FFC335E75864CF597F0743E720346FA","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">The objective of this protocol is to take sequencing reads from a calling cards library and process them into a CCF (calling card format; .ccf) file. A CCF file is a modified BED file (BED3+3) that concisely enumerates every transposition event in the sequenced library.<\/div><div class = \"text-block\">CCF files typically have six columns:<\/div><div class = \"text-block\"><ol style = \"list-style-type: decimal;\"><li style = \"counter-reset:ol0;\">chrom: chromosome<\/li><li style = \"counter-reset:ol0;\">start: beginning coordinate of the insertion site<\/li><li style = \"counter-reset:ol0;\"><span>end: ending coordinate of the insertion site; since <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> inserts into TTAA's, this typically spans the motif itself.<\/span><\/li><li style = \"counter-reset:ol0;\">count: the number of reads supporting this insertion<\/li><li style = \"counter-reset:ol0;\">strand: + or -, indicating which strand was targetted (optional but highly recommended)<\/li><li style = \"counter-reset:ol0;\">barcode: a string identifying the library from which this insertion originated (optional but highly recommended)<\/li><\/ol><\/div><div class = \"text-block\">This workflow will walk through how to perform quality control, alignment, filtering, and processing of calling card sequencing libraries to generate a CCF file. This file can then be used in downstream applications, such as visualization on the (legacy) <\/div><div class = \"text-block\"><a href=\"http:\/\/epigenomegateway.wustl.edu\/legacy\/\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">WashU Epigenome Browser<\/span><\/a><\/div><div class = \"text-block\"> (instructions <\/div><div class = \"text-block\"><a href=\"http:\/\/wiki.wubrowse.org\/Calling_card\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">here<\/span><\/a><\/div><div class = \"text-block\">), and as input for peak calling.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","critical":null,"critical_id":null,"duration":0}],"document":null,"materials":[],"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Here we present a computational pipeline for processing bulk RNA calling card data. These data will have been generated from transfection\/-duction of either undirected <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> transposase or your favorite transcription factor (YFTF) fused to <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span>. Multiple biological replicates should have been generated, each with a unique combination of primer barcode and index sequences. This workflow demonstrates how to analyze a single replicate; the workflow can be parallelized on distributed computing architectures (e.g. slurm).<\/span><\/div><\/div>","changed_on":1572021017}