{"id":28641,"title":"Stranded Transcript Count Table Generation from Long Reads","title_html":"Stranded Transcript Count Table Generation from Long Reads","image":{"source":"https:\/\/www.protocols.io\/img\/default_protocol.png","placeholder":"https:\/\/www.protocols.io\/img\/default_protocol.png"},"doi":"dx.doi.org\/10.17504\/protocols.io.779hrr6","doi_status":2,"uri":"stranded-transcript-count-table-generation-from-lo-779hrr6","type_id":1,"published_on":1571099454,"parent_protocols":[],"parent_collections":[],"version_id":9,"created_on":1571090559,"categories":null,"creator":{"name":"David A. Eccles","affiliation":"Malaghan Institute of Medical Research (NZ)","affiliations":[{"affiliation":"Malaghan Institute of Medical Research (NZ)","url":"http:\/\/www.malaghan.org.nz\/","is_default":1}],"username":"david-eccles","link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg"},"badges":[{"id":3,"image":{"source":"\/img\/badges\/silver.svg","placeholder":"\/img\/badges\/silver.svg"},"name":"Power author!"},{"id":6,"image":{"source":"\/img\/badges\/socialbutterfly.svg","placeholder":"\/img\/badges\/socialbutterfly.svg"},"name":"Social butterfly"}],"research_interests":null,"blocked_by_you":false,"blocked_you":false},"journal":null,"journal_name":null,"journal_link":null,"article_citation":null,"public":1,"has_versions":1,"link":null,"total_collections":0,"number_of_steps":12,"authors":[{"name":"David Eccles","affiliation":"Malaghan Institute of Medical Research (NZ)","affiliations":[],"username":"david-eccles","link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false}],"versions":[],"groups":[],"has_subprotocols":0,"is_subprotocol":0,"is_bookmarked":0,"can_be_copied":1,"can_remove_fork":0,"forks_count":{"private":0,"public":0},"access":{"can_view":1,"can_remove":0,"can_add":0,"can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":1,"can_move":1,"can_move_outside":1,"can_transfer":1,"can_download":1,"is_locked":0},"guid":"B60DAD0B95094F18AF6DACE5BDD37887","steps":[{"id":825678,"guid":"329C69CA08934359B3769812C4B068FF","previous_id":825681,"previous_guid":"173E6E7058514347A8D0DEF74DB39A49","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"3A91B0672B1945818AB5A897B9C880E4","order_id":1,"type_id":6,"title":"Section","source":{"title":"Index Preparation"}},{"id":1054724,"guid":"03A84950E8464A58AD65662ADA0A331B","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Prepare transcript index (see Guidelines for data sources). Following <\/div><div class = \"text-block\"><a href=\"https:\/\/github.com\/mcfrith\/last-rna\/blob\/master\/last-long-reads.md#option-1-prepare-a-genome-without-repeat-masking\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">Martin Frith's recommendation<\/span><\/a><\/div><div class = \"text-block\">, the '-uNEAR' seeding scheme is used to slightly increase sensitivity. This will generate seven additional files of the form <index name>.XXX:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">lastdb -uNEAR Mus_musculus.GRCm38.cds.all.fa <(zcat Mus_musculus.GRCm38.cds.all.fa.gz)<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","critical":null,"critical_id":null,"duration":0},{"id":825679,"guid":"BE27722694504FCA96876AB86C0A7430","previous_id":825678,"previous_guid":"329C69CA08934359B3769812C4B068FF","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"59FBC9F09CDA40009E9446E7355AE8BC","order_id":1,"type_id":6,"title":"Section","source":{"title":"Transcriptome Mapping"}},{"id":1054724,"guid":"4EDC16969808480284494E10671A9A12","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Reads are mapped to the transcriptome with LAST.<\/div><div class = \"text-block\"><span>The results of that mapping can be piped through <\/span><span style = \"font-style:italic;\">last-map-probs<\/span><span> to exclude unlikely hits, then through '<\/span><span style = \"font-style:italic;\">maf-convert -n tab'<\/span><span> to convert to a one-line-per-mapping CSV format. This CSV format is further processed to make sure that there is only one mapping per transcript-read pair.<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">mkdir -p mapped<\/div><div class = \"text-block\">for bc in $(awk '{print $2}' barcode_counts.txt);<\/div><div class = \"text-block\">  do echo \"** ${bc} **\";<\/div><div class = \"text-block\">  lastal -Q 1 -P 10 Mus_musculus.GRCm38.cds.all.fa <(pv oriented\/${bc}_reads_dirAdjusted.fq.gz | zcat) | \\<\/div><div class = \"text-block\">    last-map-probs | maf-convert -n tab | cut -f 2,7,10 | sort | \\<\/div><div class = \"text-block\">    uniq | gzip > mapped\/trnMapping_LAST_${bc}_vs_Mmus_transcriptome.txt.gz;<\/div><div class = \"text-block\">done<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","critical":null,"critical_id":null,"duration":0},{"id":825680,"guid":"D1EE91D31051494BB8E2EDD9D077C64D","previous_id":825689,"previous_guid":"93B91DA3FD9244A382DE67AEA9FABF20","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"500466008A36465587A4DE3AF29902A0","order_id":1,"type_id":6,"title":"Section","source":{"title":"Annotation and Result generation"}},{"id":1054724,"guid":"2086F6E1FABF434B9A2D4976942ADF88","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Transcript counts are merged with ensembl gene annotation, then converted into wide format (one line per transcript) using an R script.<\/div><div class = \"text-block\">The transcript annotation in this case is from ensembl BioMart (see Guidelines for more details).<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">#!\/usr\/bin\/env Rscript<\/div><div class = \"text-block\">library(dplyr);<\/div><div class = \"text-block\">library(tidyr);<\/div><div class = \"text-block\">## load ensemble transcript metadata (including gene name)<\/div><div class = \"text-block\">ensembl.df <- as.tbl(read.delim('ensembl_mm10_geneFeatureLocations.txt.gz',                          <\/div><div class = \"text-block\">  col.names=c('transcript','Description','Start','End',<\/div><div class = \"text-block\">              'Strand','Gene','Chr'),<\/div><div class = \"text-block\">  stringsAsFactors=FALSE));<\/div><div class = \"text-block\">ensembl.df$Description <- sub(' \\\\[.*$','',ensembl.df$Description);<\/div><div class = \"text-block\">ensembl.df$Description <- sub('^(.{50}).+$','\\\\1...',ensembl.df$Description);<\/div><div class = \"text-block\">ensembl.df[,1:7] <- ensembl.df[,c(1,7,5,3,4,2,6)];<\/div><div class = \"text-block\">colnames(ensembl.df)[1:7] <- colnames(ensembl.df)[c(1,7,5,3,4,2,6)];<\/div><div class = \"text-block\">options(scipen=15); ## don't show scientific notation for large positions<\/div><div class = \"text-block\">## load used barcode identifiers<\/div><div class = \"text-block\">bcNames <- read.table(\"barcode_counts.txt\", stringsAsFactors=FALSE)[,2];<\/div><div class = \"text-block\">## load count data into 'narrow' array (one line per count)<\/div><div class = \"text-block\">trn.counts <- tibble(); for(bc in bcNames){<\/div><div class = \"text-block\">  trn.counts <-<\/div><div class = \"text-block\">    bind_rows(trn.counts,<\/div><div class = \"text-block\">      as.tbl(read.table(<\/div><div class = \"text-block\">        sprintf('mapped\/trnCounts_LAST_%s_vs_Mmus_transcriptome.txt.gz', bc),<\/div><div class = \"text-block\">        col.names=c('count','barcode','transcript','dir'),<\/div><div class = \"text-block\">        stringsAsFactors=FALSE)));<\/div><div class = \"text-block\">}<\/div><div class = \"text-block\">## remove revision number from transcript names (if present)<\/div><div class = \"text-block\">trn.counts$transcript <- sub('\\\\.[0-9]+$','',trn.counts$transcript);<\/div><div class = \"text-block\">## convert to wide format (one line per transcript)<\/div><div class = \"text-block\">trn.counts.wide <- spread(trn.counts, barcode, count) %>%<\/div><div class = \"text-block\">  mutate(dir = c('+'='fwd', '-'='rev')[dir]);<\/div><div class = \"text-block\">for(bd in colnames(trn.counts.wide[,-1])){<\/div><div class = \"text-block\">  trn.counts.wide[[bd]] <- replace_na(trn.counts.wide[[bd]],0);<\/div><div class = \"text-block\">}<\/div><div class = \"text-block\">## merge ensembl metadata with transcript counts<\/div><div class = \"text-block\">gene.counts.wide <- inner_join(ensembl.df, trn.counts.wide, by='transcript');<\/div><div class = \"text-block\">gene.counts.wide <- gene.counts.wide[order(-rowSums(gene.counts.wide[,-(1:8)])),];<\/div><div class = \"text-block\">## write result out to a file<\/div><div class = \"text-block\">write.csv(gene.counts.wide, file='wide_transcript_counts_LAST.csv', <\/div><div class = \"text-block\">  row.names=FALSE);<\/div><\/div><\/code><\/pre><\/div><\/div>"}},{"id":1054725,"guid":"02C0C1202B2211E9A10E9FC59ECBFD74","order_id":2,"type_id":23,"title":"file","source":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bcvaa.r","placeholder":"https:\/\/www.protocols.io\/img\/extensions\/r.png","original_name":"count_analysis.r"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","critical":null,"critical_id":null,"duration":0},{"id":825681,"guid":"173E6E7058514347A8D0DEF74DB39A49","previous_id":null,"previous_guid":null,"modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"6B723C7191DC4775B7860985F3C96F5C","order_id":1,"type_id":6,"title":"Section","source":{"title":"Demultiplex Reads    "}},{"id":1054724,"guid":"A9A1D467D93F456190FAE5999EB02E0E","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Demultiplex and orient reads as per the protocol <\/div><div class = \"text-block\"><a href=\"https:\/\/dx.doi.org\/10.17504\/protocols.io.57hg9j6\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">Preparing Reads for Stranded Mapping<\/span><\/a><\/div><div class = \"text-block\"><span>. It is expected that these demultiplexed reads will be split up in the current directory, and coupled with a '<\/span><span style = \"font-style:italic;\">barcode_counts.txt<\/span><span>' file. If that's the case, the following should work:<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">for bc in $(awk '{print $2}' barcode_counts.txt);<\/div><div class = \"text-block\">  do ls oriented\/${bc}_reads_dirAdjusted.fq.gz;<\/div><div class = \"text-block\">done<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Example expected output:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">oriented\/BC03_reads_dirAdjusted.fastq.gz<\/div><div class = \"text-block\">oriented\/BC04_reads_dirAdjusted.fastq.gz<\/div><div class = \"text-block\">oriented\/BC05_reads_dirAdjusted.fastq.gz<\/div><div class = \"text-block\">oriented\/BC06_reads_dirAdjusted.fastq.gz<\/div><div class = \"text-block\">oriented\/BC07_reads_dirAdjusted.fastq.gz<\/div><div class = \"text-block\">oriented\/BC08_reads_dirAdjusted.fastq.gz<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>If the '<\/span><span style = \"font-style:italic;\">barcode_counts.txt<\/span><span>' file is not present, this error will appear:<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">awk: fatal: cannot open file `barcode_counts.txt' for reading (No such file or directory)<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">If one or more of the oriented read files is missing, it will look something like this:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">oriented\/BC03_reads_dirAdjusted.fastq.gz<\/div><div class = \"text-block\">oriented\/BC04_reads_dirAdjusted.fastq.gz<\/div><div class = \"text-block\">ls: cannot access 'oriented\/BC05_reads_dirAdjusted.fastq.gz':<\/div><div class = \"text-block\">  No such file or directory<\/div><div class = \"text-block\">ls: cannot access 'oriented\/BC06_reads_dirAdjusted.fastq.gz':<\/div><div class = \"text-block\">  No such file or directory<\/div><div class = \"text-block\">oriented\/BC07_reads_dirAdjusted.fastq.gz<\/div><div class = \"text-block\">oriented\/BC08_reads_dirAdjusted.fastq.gz<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","critical":null,"critical_id":null,"duration":0},{"id":825682,"guid":"FFD657537A214A69BC8C6275B199A7FF","previous_id":825683,"previous_guid":"838B20F768A84619803CB1E092559333","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"06E8754012104546972AD5B22F3D1E2C","order_id":1,"type_id":6,"title":"Section","source":{"title":"Orienting Reads"}},{"id":1054724,"guid":"7D16124CF5214ECC963350B07977FA5A","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Map the reads to the adapter sequences. In this case it's important that the direction of mapping is also recorded, so the <\/span><span style = \"font-style:italic;\">cut<\/span><span> command selects three fields (query name [7], target name [2], mapping direction [10]):<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">for bc in $(awk '{print $2}' barcode_counts.txt);<\/div><div class = \"text-block\">  do echo \"** ${bc} **\";<\/div><div class = \"text-block\">  lastal -Q 1 -P10 adapter_seqs.fa <(pv reads_${bc}.fastq.gz) | \\<\/div><div class = \"text-block\">    maf-convert -n tab | cut -f 2,7,10 | uniq | \\<\/div><div class = \"text-block\">    gzip > adapter_assignments_${bc}.txt.gz<\/div><div class = \"text-block\">done<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","critical":null,"critical_id":null,"duration":0},{"id":825683,"guid":"838B20F768A84619803CB1E092559333","previous_id":null,"previous_guid":null,"modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"D9CF49778DFC4497AECD94631C3A72F4","order_id":1,"type_id":6,"title":"Section","source":{"title":"Adapter Mapping"}},{"id":1054724,"guid":"72C1ECACDD154F4D9F1ED7FA65D8A6A8","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Prepare the LAST index for the adapter file. This will generate seven additional files of the form <index name>.XXX:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">lastdb adapter_seqs.fa adapter_seqs.fa<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0},{"id":825684,"guid":"74F3339C99344D01ABD02692ACDFA8ED","previous_id":825682,"previous_guid":"FFD657537A214A69BC8C6275B199A7FF","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"76C6A0DA338E4427A673D1A700D61B29","order_id":1,"type_id":6,"title":"Section","source":{"title":"Orienting Reads"}},{"id":1054724,"guid":"EB8A5A5A5632428DA98F79BBE4E810C6","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Reads are filtered into two groups (and one group-by-omission) based on the mapped direction of the strand-switch primer, then reverse-complemented (if necessary) to match the orientation of the original RNA strand. I use my <\/div><div class = \"text-block\"><a href=\"https:\/\/gitlab.com\/gringer\/bioinfscripts\/blob\/master\/fastx-fetch.pl\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">fastx-fetch.pl<\/span><\/a><\/div><div class = \"text-block\"> and <\/div><div class = \"text-block\"><a href=\"https:\/\/gitlab.com\/gringer\/bioinfscripts\/blob\/master\/fastx-rc.pl\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">fastx-rc.pl<\/span><\/a><\/div><div class = \"text-block\"> scripts for this.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">mkdir -p oriented<\/div><div class = \"text-block\">for bc in $(awk '{print $2}' barcode_counts.txt);<\/div><div class = \"text-block\">  do echo \"** ${bc} **\";<\/div><div class = \"text-block\">  fastx-fetch.pl -i <(zgrep 'SSP' adapter_assignments_${bc}.txt.gz | awk '{if($3 == \"+\"){print $2}}') <(pv reads_${bc}.fastq.gz) | \\<\/div><div class = \"text-block\">    gzip > oriented\/${bc}_reads_fwd.fastq.gz<\/div><div class = \"text-block\">  fastx-fetch.pl -i <(zgrep 'SSP' adapter_assignments_${bc}.txt.gz | awk '{if($3 == \"-\"){print $2}}') <(pv reads_${bc}.fastq.gz) | \\<\/div><div class = \"text-block\">    fastx-rc.pl | gzip > oriented\/${bc}_reads_rev.fastq.gz<\/div><div class = \"text-block\">done<\/div><\/div><\/code><\/pre><\/div><\/div>"}},{"id":1054725,"guid":"7AB8B1A03BB311E99B905DCA0E5F54D4","order_id":2,"type_id":23,"title":"file","source":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bdwsa.pl","placeholder":"\/img\/extensions\/file.png","original_name":"fastx-fetch.pl"}},{"id":1054726,"guid":"83CD85E03BB311E99B905DCA0E5F54D4","order_id":3,"type_id":23,"title":"file","source":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bdwta.pl","placeholder":"\/img\/extensions\/file.png","original_name":"fastx-rc.pl"}}],"cases":[],"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0},{"id":825685,"guid":"97494BAC8C6C466FBC5B11C1E0B80CED","previous_id":825684,"previous_guid":"74F3339C99344D01ABD02692ACDFA8ED","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"9F6B2193C4E44A33A45E176618618FD2","order_id":1,"type_id":6,"title":"Section","source":{"title":"Orienting Reads"}},{"id":1054724,"guid":"EF5D711C42404210B438298BEF00D276","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Forward and reverse-oriented sequences are combined together to form a single group of RNA-oriented reads.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">for bc in $(awk '{print $2}' barcode_counts.txt);<\/div><div class = \"text-block\">  do echo \"** ${bc} **\";<\/div><div class = \"text-block\">  pv oriented\/${bc}_reads_fwd.fastq.gz oriented\/${bc}_reads_rev.fastq.gz | \\<\/div><div class = \"text-block\">    zcat | gzip > oriented\/${bc}_reads_dirAdjusted.fastq.gz<\/div><div class = \"text-block\">done<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0},{"id":825686,"guid":"A804D843EB154AAE8E9A2E7D496E73FC","previous_id":825685,"previous_guid":"97494BAC8C6C466FBC5B11C1E0B80CED","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"2112A7694B524ECB991012B3813A4BC3","order_id":1,"type_id":6,"title":"Section","source":{"title":"Transcriptome mapping"}},{"id":1054724,"guid":"B919ECF4D8674A00A29D4D57C0B68A4E","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Reads are mapped to the transcriptome with LAST.<\/div><div class = \"text-block\"><span>The results of that mapping are piped through <\/span><span style = \"font-style:italic;\">last-map-probs<\/span><span> to exclude unlikely hits, then through maf-convert to convert to a one-line-per-mapping tab-separated format using the same fields as with the adapter mapping (query name [7], target name [2], mapping direction [10]). <\/span><\/div><div class = \"text-block\">This format is further processed to make sure that there is only one mapping per transcript-read pair, and then aggregated to sum up counts per transcript.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">mkdir -p mapped<\/div><div class = \"text-block\">for bc in $(awk '{print $2}' barcode_counts.txt);<\/div><div class = \"text-block\">  do echo \"** ${bc} **\";<\/div><div class = \"text-block\">  lastal -Q 1 -P 10 Mus_musculus.GRCm38.cds.all.fa <(pv oriented\/${bc}_reads_dirAdjusted.fastq.gz | zcat) | \\<\/div><div class = \"text-block\">    last-map-probs | maf-convert -n tab | cut -f 2,7,10 | \\<\/div><div class = \"text-block\">    sort | uniq | awk -F'\\t' -v \"bc=${bc}\" '{print bc,$1,$3}' | \\<\/div><div class = \"text-block\">    sort | uniq -c | \\<\/div><div class = \"text-block\">      gzip > mapped\/trnCounts_LAST_${bc}_vs_Mmus_transcriptome.txt.gz;<\/div><div class = \"text-block\">done<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","critical":null,"critical_id":null,"duration":0},{"id":825687,"guid":"26F9E12F42C845F2AE973942821C98C9","previous_id":825686,"previous_guid":"A804D843EB154AAE8E9A2E7D496E73FC","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"33CED3DF23F54E94B16B681D6A00912E","order_id":1,"type_id":6,"title":"Section","source":{"title":"Annotation and Result Generation"}},{"id":1054724,"guid":"FBE98BB439334BA1906E8B8D43C9370D","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Transcript counts are merged with ensembl gene annotation, then converted into wide format (one line per transcript) using an R script.<\/div><div class = \"text-block\">The transcript annotation in this case is from ensembl BioMart (see Guidelines for more details).<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">#!\/usr\/bin\/env Rscript<\/div><div class = \"text-block\">library(dplyr);<\/div><div class = \"text-block\">library(tidyr);<\/div><div class = \"text-block\">## load used barcode identifiers<\/div><div class = \"text-block\">bcNames <- read.table(\"barcode_counts.txt\", stringsAsFactors=FALSE)[,2];<\/div><div class = \"text-block\">## load count data into \"narrow\" array (one line per count)<\/div><div class = \"text-block\">trn.counts <- tibble();<\/div><div class = \"text-block\">for(bc in bcNames){<\/div><div class = \"text-block\">    trn.counts <-<\/div><div class = \"text-block\">        bind_rows(trn.counts,<\/div><div class = \"text-block\">                  as.tbl(read.table(<\/div><div class = \"text-block\">                      sprintf(\"mapped\/trnCounts_LAST_%s_vs_Mmus_transcriptome.txt.gz\", bc),<\/div><div class = \"text-block\">                      col.names=c(\"count\",\"barcode\",\"transcript\",\"dir\"),<\/div><div class = \"text-block\">                      stringsAsFactors=FALSE)));<\/div><div class = \"text-block\">}<\/div><div class = \"text-block\">## remove revision number from transcript names (if present)<\/div><div class = \"text-block\">trn.counts$transcript <- sub(\"\\\\.[0-9]+$\",\"\",trn.counts$transcript);<\/div><div class = \"text-block\">## convert to wide format (one line per transcript)<\/div><div class = \"text-block\">trn.counts.wide <- spread(trn.counts, barcode, count) %>%<\/div><div class = \"text-block\">    mutate(dir = c(\"+\"=\"fwd\", \"-\"=\"rev\")[dir]);<\/div><div class = \"text-block\">for(bd in colnames(trn.counts.wide[,-1])){<\/div><div class = \"text-block\">    trn.counts.wide[[bd]] <- replace_na(trn.counts.wide[[bd]],0);<\/div><div class = \"text-block\">}<\/div><div class = \"text-block\">## load ensemble transcript metadata (including gene name)<\/div><div class = \"text-block\">ensembl.df <- as.tbl(read.delim(\"ensembl_mm10_geneFeatureLocations.txt.gz\",<\/div><div class = \"text-block\">                         col.names=c(\"transcript\",\"Description\",\"Start\",\"End\",<\/div><div class = \"text-block\">                                     \"Strand\",\"Gene\",\"Chr\"),<\/div><div class = \"text-block\">                         stringsAsFactors=FALSE));<\/div><div class = \"text-block\">ensembl.df$Description <- sub(\" \\\\[.*$\",\"\",ensembl.df$Description);<\/div><div class = \"text-block\">ensembl.df$Description <- sub(\"^(.{50}).+$\",\"\\\\1...\",ensembl.df$Description);<\/div><div class = \"text-block\">ensembl.df[,1:7] <- ensembl.df[,c(1,7,5,3,4,2,6)];<\/div><div class = \"text-block\">colnames(ensembl.df)[1:7] <- colnames(ensembl.df)[c(1,7,5,3,4,2,6)];<\/div><div class = \"text-block\">options(scipen=15); ## don't show scientific notation for large positions<\/div><div class = \"text-block\">## merge ensembl metadata with transcript counts<\/div><div class = \"text-block\">gene.counts.wide <- inner_join(ensembl.df, trn.counts.wide, by=\"transcript\");<\/div><div class = \"text-block\">gene.counts.wide <- gene.counts.wide[order(-rowSums(gene.counts.wide[,-(1:8)])),];<\/div><div class = \"text-block\">bcNames <- colnames(gene.counts.wide[,-(1:8)]);<\/div><div class = \"text-block\">## ignore columns with extremely low read counts<\/div><div class = \"text-block\">bcNames <- bcNames[colSums(gene.counts.wide[,bcNames]) > 10];<\/div><div class = \"text-block\">## write result out to a file<\/div><div class = \"text-block\">write.csv(gene.counts.wide, file=\"wide_transcript_counts_LAST.csv\",<\/div><div class = \"text-block\">          row.names=FALSE);<\/div><\/div><\/code><\/pre><\/div><\/div>"}},{"id":1054725,"guid":"382DBA903BD311E99B905DCA0E5F54D4","order_id":2,"type_id":23,"title":"file","source":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bdw9a.r","placeholder":"https:\/\/www.protocols.io\/img\/extensions\/r.png","original_name":"count_analysis.r"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","critical":null,"critical_id":null,"duration":0},{"id":825688,"guid":"679F21E34B4E44348475AEAF0BF4904B","previous_id":825680,"previous_guid":"D1EE91D31051494BB8E2EDD9D077C64D","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"DE967F15AD084F3E98823B076B3120D4","order_id":1,"type_id":6,"title":"Section","source":{"title":"Downstream Workflows"}},{"id":1054724,"guid":"FF41406716B7441AB5AA32F1F99DD8F4","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">A downstream workflow is still <\/div><div class = \"text-block\"><a href=\"https:\/\/support.bioconductor.org\/p\/120764\/\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">in development<\/span><\/a><\/div><div class = \"text-block\">. I have had reasonable succes doing transcript-level differential expression analysis using <\/div><div class = \"text-block\"><a href=\"https:\/\/bioconductor.org\/packages\/release\/bioc\/html\/DESeq2.html\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">DESeq2<\/span><\/a><\/div><div class = \"text-block\">.<\/div><div class = \"text-block\"><span>I would like to emphasise that batch effects should be considered for nanopore sequencing, given how frequently the technology changes. Make sure that at least the sequencing <\/span><span style = \"font-style:italic;\">library<\/span><span> (i.e. samples prepared in tandem on the same day from the same kit) is added into the statistical model, and try to make sure that sequencing libraries are fairly heterogeneous - replicates from a sample with skewed transcript distributions could influence the outcome of statistical tests.<\/span><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#EA9F6C","critical":null,"critical_id":null,"duration":0},{"id":825689,"guid":"93B91DA3FD9244A382DE67AEA9FABF20","previous_id":825679,"previous_guid":"BE27722694504FCA96876AB86C0A7430","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"3783EAB56F3C4A65A3906B1724EF1657","order_id":1,"type_id":6,"title":"Section","source":{"title":"Transcriptome Mapping"}},{"id":1054724,"guid":"47F7C1E406D54669B24A0565A07A7939","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">The result is then aggregated to sum up counts per transcript:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">for bc in $(awk '{print $2}' barcode_counts.txt);<\/div><div class = \"text-block\">  do echo \"** ${bc} **\";<\/div><div class = \"text-block\">  zcat mapped\/trnMapping_LAST_${bc}_vs_Mmus_transcriptome.txt.gz | \\<\/div><div class = \"text-block\">    awk -F'\\t' -v \"bc=${bc}\" '{print bc,$1,$3}' | sort | uniq -c | \\<\/div><div class = \"text-block\">    gzip > mapped\/trnCounts_LAST_${bc}_vs_Mmus_transcriptome.txt.gz;<\/div><div class = \"text-block\">done<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Note: I've split this up into two steps (compared to previous versions of this protocol) so that an intermediate count of the total number of mapped transcripts per barcode can be done:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">for bc in $(awk '{print $2}' barcode_counts.txt);<\/div><div class = \"text-block\">  do echo -n \"${bc} \";<\/div><div class = \"text-block\">  zcat mapped\/trnMapping_LAST_${bc}_vs_Mmus_transcriptome.txt.gz | \\<\/div><div class = \"text-block\">    awk '{print $2}' | sort | uniq | wc -l;<\/div><div class = \"text-block\">done<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","critical":null,"critical_id":null,"duration":0}],"document":null,"materials":[],"description":"<div class = \"text-blocks\"><div class = \"text-block\">This protocol is for comparing different samples at the transcript level, using long reads that are mapped to transcripts.<\/div><div class = \"text-block\"><span style = \"font-weight:bold;\">Input(s)<\/span><span>: demultiplexed and oriented fastq files (see protocol <\/span><a href=\"https:\/\/dx.doi.org\/10.17504\/protocols.io.57hg9j6\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">Preparing Reads for Stranded Mapping<\/span><\/a><span>), transcript reference fasta file, annotation file<\/span><\/div><div class = \"text-block\"><span style = \"font-weight:bold;\">Output(s):<\/span><span> transcript table, sorted by differential coverage, annotated with gene name \/ description \/ location<\/span><\/div><\/div>","changed_on":1571099454}