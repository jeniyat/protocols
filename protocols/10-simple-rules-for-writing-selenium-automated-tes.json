{"id":27715,"title":"10 simple rules for writing Selenium automated tests","title_html":"<p>10 simple rules for writing Selenium automated tests<\/p>","image":{"source":"https:\/\/www.protocols.io\/img\/default_protocol.png","placeholder":"https:\/\/www.protocols.io\/img\/default_protocol.png"},"doi":"dx.doi.org\/10.17504\/protocols.io.7bbhiin","doi_status":2,"uri":"10-simple-rules-for-writing-selenium-automated-tes-7bbhiin","type_id":4,"published_on":1568361177,"parent_protocols":[],"parent_collections":[],"version_id":0,"created_on":1568330166,"categories":null,"creator":{"name":"Sebastian Bassi","affiliation":"Globant","affiliations":[{"affiliation":"Globant","url":"globant.com","is_default":1}],"username":"sebastian-bassi","link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/pfhhzbe.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/pfhhzbe.jpg"},"badges":[{"id":2,"image":{"source":"\/img\/badges\/bronze.svg","placeholder":"\/img\/badges\/bronze.svg"},"name":"Author"},{"id":5,"image":{"source":"\/img\/badges\/earlyadopter.svg","placeholder":"\/img\/badges\/earlyadopter.svg"},"name":"Early adopter"}],"research_interests":null,"blocked_by_you":false,"blocked_you":false},"journal":null,"journal_name":null,"journal_link":null,"article_citation":null,"public":1,"has_versions":0,"link":null,"total_collections":0,"number_of_steps":1,"authors":[{"name":"Sebastian Bassi","affiliation":"Globant","affiliations":[],"username":"sebastian-bassi","link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/pfhhzbe.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/pfhhzbe.jpg"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false}],"versions":[],"groups":[],"has_subprotocols":0,"is_subprotocol":0,"is_bookmarked":0,"can_be_copied":1,"can_remove_fork":1,"forks_count":{"private":0,"public":0},"access":{"can_view":1,"can_remove":0,"can_add":0,"can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":1,"can_move":1,"can_move_outside":1,"can_transfer":1,"can_download":1,"is_locked":0},"steps":[{"id":812385,"guid":"B6EA27D0D5FA11E98BC851DA3DDDEBA3","previous_id":null,"previous_guid":null,"modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"6D6B5969B7164317800490E7444849E0","order_id":1,"type_id":6,"title":"Section","source":{"title":""}},{"id":1054724,"guid":"8D3BFABABB66449DB0E85A08C7C98A59","order_id":1,"type_id":1,"title":"Description","source":{"description":""}}],"cases":[],"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0}],"document":"<div class = \"text-blocks\"><div class = \"text-block\">1- Use Page Object Model (POM) to structure your tests.<\/div><div class = \"text-block\">Page Object Model (POM): It is a design pattern where objects are used to represent web pages. The elements in the page are properties of the class and user interactions should be implemented as methods of the class.<\/div><div class = \"text-block\">Example:<\/div><div class = \"text-block\">A BasePage class for elements common to all pages, like titles, styles and basic actions such as click on buttons and wait for elements to be displayed.<\/div><div class = \"text-block\">All POM should inherited from BasePage class, you can have a Footer POM, a left menu POM, a Sign-up POM and more according to the site structure.<\/div><div class = \"text-block\">Properties:<\/div><div class = \"text-block\">Submit_button, log_in link,  regular_text, title. code_display_box.<\/div><div class = \"text-block\">Methods:<\/div><div class = \"text-block\">register_a new user. login. add_item_to_cart. post_a_message.<\/div><div class = \"text-block\"><span>2- Use UI Maps (aka Object Repository<\/span><span style = \"font-weight:bold;\">)<\/span><\/div><div class = \"text-block\">Since object location may change during an application life cycle, you could end up updating several parts of the code each time there is a change in the CSS. To avoid this problem and you should have an object repository to store all object locations. This can be implemented with a key\/value database or with a hash table or Python dictionary.  The key will be the name or alias of the object, while the value would be the location.<\/div><div class = \"text-block\">Example:<\/div><div class = \"text-block\">UImap.py<\/div><div class = \"text-block\">loginpagemap = {\"userfield\": \"input[type=text][name='user[login]']\",<\/div><div class = \"text-block\">                                \"passwordfield\" : \"input[type=password][name='user[password]']\",<\/div><div class = \"text-block\">                                \"loginbutton\" : \"button[class='btn-mktg btn-primary-mktg']\"}<\/div><div class = \"text-block\">To use it:<\/div><div class = \"text-block\">from UImap import loginpagemap<\/div><div class = \"text-block\">class LoginPage(BasePage):<\/div><div class = \"text-block\">def login(self):<\/div><div class = \"text-block\">    self.fill_form(loginpagemap[\"userfield\"], username)<\/div><div class = \"text-block\">    self.fill_form(loginpagemap[\"passwordfield\"], password)<\/div><div class = \"text-block\">    self.click_button(loginpagemap[\"loginbutton\"])<\/div><div class = \"text-block\">3- Use CSS locator over XPATH when possible. <\/div><div class = \"text-block\">Xpath engines may be different on each browser so they may be inconsistent. Since Xpath tend to become complex, are not so easy to read as CSS locators. In some browsers (IE based mostly) Xpath selectors are slower. Performance may not be an issue for small projects, but when tests are ran several times per day, each second ads to the total time.<\/div><div class = \"text-block\">4- Use tools to find elements. <\/div><div class = \"text-block\">There are several browsers add-ons or extensions that can help to find elements in a web page. Eskry for Chrome and FirePath for Firefox. Both allows to select an item in the page and get the CSS and the XPATH location of it.<\/div><div class = \"text-block\">5- Write independent tests. <\/div><div class = \"text-block\">This is one of the basic principles of automation testing. It avoids code duplication and prevents a failure to mask another failure. How to write independent tests? One of the causes that produce dependency between tests is that some tests depends on a state generated by another test. To reach a specific state the application could support URIs (instead of using the UI) and by using flags.<\/div><div class = \"text-block\">6- Use tags.<\/div><div class = \"text-block\">Tags allows to apply metadata to your tests. This way you can set a filter at runtime to execute desired tests according to your needs. There are several criteria that can be used, like functionality, execution speed, priority and so on. Let's see some criteria. <\/div><div class = \"text-block\">Functionality: Registration, Login, Managing the profile, checkout and other functionality on your web site that may need to be tested in a separate way. <\/div><div class = \"text-block\">Execution speed: Slow, medium, fast. This is useful for sorting tests to be run in different continuous integration (CI) pipelines. <\/div><div class = \"text-block\">Priority: Lowest, medium, highest. This criteria may be related with business value of each functionality.<\/div><div class = \"text-block\">Story number: Group tests by user story related to the test<\/div><div class = \"text-block\">7- Wrap selenium calls.<\/div><div class = \"text-block\">Selenium calls like sending keys, waiting for an element, selecting an option from a drop down menu and more, all should be wrapped to avoid code duplication.<\/div><div class = \"text-block\">8- Don't use fixed timers.<\/div><div class = \"text-block\">When your code needs for an element to appear, instead of waiting for a fixed amount of time, always try to explicit wait for the object to be displayed or available. Fixed waits could be larger than the actual time needed for the element to appear, that would increase test runs without any benefit. <\/div><div class = \"text-block\">Example:<\/div><div class = \"text-block\">from selenium.webdriver.support.ui import WebDriverWait<\/div><div class = \"text-block\">from selenium.webdriver.support import expected_conditions as ec<\/div><div class = \"text-block\">driver = webdriver.Chrome()<\/div><div class = \"text-block\">driver.get(website)<\/div><div class = \"text-block\">def is_visible(locator, timeout = 50): <\/div><div class = \"text-block\">    try:<\/div><div class = \"text-block\">        WebDriverWait(driver, timeout).until(ec.visibility_of_element_located((By.XPATH, locator))) <\/div><div class = \"text-block\">        return True<\/div><div class = \"text-block\">    except TimeoutException: <\/div><div class = \"text-block\">        return False<\/div><div class = \"text-block\">9- Hide Selenium objects. <\/div><div class = \"text-block\">Your POM should not have Selenium properties nor methods. The code in the tests should be understandable by anybody who knows about the subject without any knowledge of Selenium<\/div><div class = \"text-block\">10- Document you tests<\/div><div class = \"text-block\">Each test should have the goal stated, with all steps needed to reach this goal. Comment on all methods and page objects. Don't forget to document also how to Install the test and its dependencies.<\/div><\/div>","materials":[],"description":"<div class = \"text-blocks\"><div class = \"text-block\">Some advices regarding writing Selenium tests. The examples are in Python but the rules are language agnostic, so it can be implemented in any supported language.<\/div><\/div>","changed_on":1568361177}