{"id":18218,"title":"Plant leaf tooth feature extraction","title_html":"Plant leaf tooth feature extraction","image":{"source":"https:\/\/www.protocols.io\/img\/default_protocol.png","placeholder":"https:\/\/www.protocols.io\/img\/default_protocol.png"},"doi":"dx.doi.org\/10.17504\/protocols.io.v2ie8ce","doi_status":2,"uri":"plant-leaf-tooth-feature-extraction-v2ie8ce","type_id":1,"published_on":1546529000,"version_id":1,"created_on":1543591299,"categories":null,"creator":{"name":"Di Tian","affiliation":null,"username":"di-tian","link":null,"image":{"source":"\/img\/avatars\/002.png","placeholder":"\/img\/avatars\/002.png"},"badges":[{"id":2,"image":{"source":"\/img\/badges\/bronze.svg","placeholder":"\/img\/badges\/bronze.svg"},"name":"Author"}],"research_interests":null},"journal":null,"journal_name":null,"journal_link":null,"public":1,"has_versions":1,"link":null,"number_of_steps":1,"authors":[{"name":"Wang Hu","affiliation":"China Shipbuilding Industry Corporation","username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null},{"name":"Li Chu","affiliation":"China Shipbuilding Industry Corporation","username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null},{"name":"Tian Yan","affiliation":"Huazhong University of Science and Technology","username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null},{"name":"Zhou Haoyu","affiliation":"China Shipbuilding Industry Corporation","username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null},{"name":"Tian Di","affiliation":"Wenhua College","username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null}],"versions":[],"groups":[],"has_subprotocols":0,"is_subprotocol":0,"is_bookmarked":0,"forks_count":{"private":0,"public":0},"steps":[{"id":694371,"guid":"C08778F00F6811E99BD11532EFD0C286","previous_id":null,"previous_guid":null,"modified_on":1546528892,"protocol_id":0,"components":[{"id":1054723,"guid":"7F92B95B028948B697EF55DC9E1AF26A","order_id":1,"type_id":6,"title":"Section","source":{"title":"Experiment 1"}},{"id":1054723,"guid":"D8BF5979CF084A4F9D802ABE091F2EE8","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">To verify whether the proposed leaf structure feature description algorithm is scientific and effective, <\/div><div class = \"text-block\"><a style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">we implemented the algorithm using MATLAB 2017 (MathWorks, Natick, MA, USA) on a standard desktop PC (4.2 GHz CPU, 24 GB RAM). Processing of a single leaf took approximately 1.4 s. This could undoubtedly be improved through further optimization and\/or using parallel computing. <\/span><\/a><\/div><\/div>"}},{"id":1054723,"guid":"38B0BBC00F6911E99BD11532EFD0C286","order_id":2,"type_id":15,"title":"command","source":{"name":"toothFeature_finished('D:\\Experiment 1\\data\\1.jpg')","command":"Leaf tooth Feature Extraction","os_name":"windows","os_version":"10"}},{"id":1054723,"guid":"00255F300F6A11E99BD11532EFD0C286","order_id":3,"type_id":15,"title":"command","source":{"name":"% Leaf tooth Feature Extraction \n% \n%Locates and measures the teeth found at the margin of a leaf.\n%Input: leafFile, a leaf object or a file containing a single leaf object. This\n% object has fields 'image_name' = RGB image of single leaf; 'x' and 'y' = set of \n% Cartesian coordinates of boundary of leaf.\n% \n%\n%Output:toothNumber,sinusShape,flagRegular,order,flag\n%  Tooth number: the total number of teeth found\n%  flagRegular:Tooth spacing\n%  sinusShape: Sinus shape\n%  order: Number of orders of teeth  \n%  toothShape: Tooth shape\n%\n%Requires Matlab Image Processing Toolbox.\n%\n% Authors:\n%WangHu, TianDi\n% CSIC, 2016-2018\n% holmoak@qq.com\n\n% v.1.0  March 2012\nfunction [data]=toothFeature_finished(image_name)   %%Main function  \"data=toothFeature_finished('C:\\Users\\Beaut\\Desktop\\testimages\\6.jpg');\"\n\nPara=[1.5,162,4,0.25,0,1,3];\nC=Para(1);\nT_angle=Para(2);\nsig=Para(3);\nH=Para(4);\nL=Para(5);\nEndpoint=Para(6);\nGap_size=Para(7);\nI=imread(image_name);  \nclc;\nclose all;\n \nI1=preprocess(I);\nBW=edge(I1,'canny',[L,H]);  % Detect edges\n[curve,curve_start,curve_end,curve_mode,curve_num]=extract_curve(BW,Gap_size);  % Extract curves\n[cout,K1]=get_corner(curve,curve_start,curve_end,curve_mode,curve_num,BW,sig,Endpoint,C,T_angle); % Detect corners\n[convex,toothNumber]=convexFinder(cout,7,I1);%convex extraction\n%curve\u4f1a\u6709\u5206\u6bb5\u7684\u60c5\u51b5\n [r,c]=size(curve);\n A=curve{1,1};\n for i=2:c\n     A=[A\n        curve{1,i}];\n end\n%K1\u4e3a\u8f6e\u5ed3\u70b9\u5750\u6807\uff0c\u5bf9\u5e94\u7684\u66f2\u7387\n B=K1{1,1};\n for i=2:c\n     B=[B\n        K1{1,i}];\n end\n%concave classify Angular and Rounded sinus\n[concave,sinusShape]=concaveFinder(A,convex,B);\n%% Orders of teeth distribution \n[distan,convex,order]=toothOrder(convex,concave);%order\nflagRegular=toothSpacing(convex);\n % Tooth shape\ntoothShape=toothShapeFinder(curve,convex,concave,I1,I);\ndata=[toothNumber,sinusShape,flagRegular,order,toothShape];%%sinusShape=1 Angular sinus ,sinusShape=0 Rounded sinus; flagRegular=1 Irregular, flagRegular=0 Regular\ndisp(data);                                                %% toothShape=1 CC ;toothShape=2 CV ;toothShape=3 ST ;toothShape=12 FL ;   toothShape=21 RT \n end\n\nfunction [curve,curve_start,curve_end,curve_mode,cur_num]=extract_curve(BW,Gap_size)\n%   Function to extract curves from binary edge map, if the endpoint of a\n%   contour is nearly connected to another endpoint, fill the gap and continue\n%   the extraction. The default gap size is 1 pixles.\n\n[L,W]=size(BW);\nBW1=zeros(L+2*Gap_size,W+2*Gap_size);\nBW_edge=zeros(L,W);\nBW1(Gap_size+1:Gap_size+L,Gap_size+1:Gap_size+W)=BW;\n[r,c]=find(BW1==1);%\ncur_num=0;\n\nwhile size(r,1)>0\n    point=[r(1),c(1)]; \n    cur=point; \n    BW1(point(1),point(2))=0; \n    [I,J]=find(BW1(point(1)-Gap_size:point(1)+Gap_size,point(2)-Gap_size:point(2)+Gap_size)==1); \n    b=0;\n    while size(I,1)>0\n        dist=(I-Gap_size-1).^2+(J-Gap_size-1).^2;\n        [min_dist,index]=min(dist);\n        point=point+[I(index),J(index)]-Gap_size-1; \n        cur=[cur;point]; \n        BW1(point(1),point(2))=0;\n        [I,J]=find(BW1(point(1)-Gap_size:point(1)+Gap_size,point(2)-Gap_size:point(2)+Gap_size)==1); \n        b=b+1;\n    end\n    \n    % Extract edge towards another direction\n    point=[r(1),c(1)];\n    BW1(point(1),point(2))=0;\n    [I,J]=find(BW1(point(1)-Gap_size:point(1)+Gap_size,point(2)-Gap_size:point(2)+Gap_size)==1);\n    while size(I,1)>0\n        dist=(I-Gap_size-1).^2+(J-Gap_size-1).^2;\n        [min_dist,index]=min(dist);\n        point=point+[I(index),J(index)]-Gap_size-1;\n        cur=[point;cur];\n        BW1(point(1),point(2))=0;\n        [I,J]=find(BW1(point(1)-Gap_size:point(1)+Gap_size,point(2)-Gap_size:point(2)+Gap_size)==1);\n    end\n        \n    if size(cur,1)>(size(BW,1)+size(BW,2))\/25\n        cur_num=cur_num+1;\n        curve{cur_num}=cur-Gap_size;\n    end\n    [r,c]=find(BW1==1);\n    \nend\n\nfor i=1:cur_num\n    curve_start(i,:)=curve{i}(1,:);\n    curve_end(i,:)=curve{i}(size(curve{i},1),:);\n    if (curve_start(i,1)-curve_end(i,1))^2+...\n        (curve_start(i,2)-curve_end(i,2))^2<=32\n        curve_mode(i,:)='loop';\n    else\n        curve_mode(i,:)='line';\n    end \n    \n    BW_edge(curve{i}(:,1)+(curve{i}(:,2)-1)*L)=1;\nend\n% figure(1)\n% imshow(~BW_edge)\n% title('Edge map')\n% imwrite(~BW_edge,'edge.jpg');\nend\n\n function [cout,K1]=get_corner(curve,curve_start,curve_end,curve_mode,curve_num,BW,sig,Endpoint,C,T_angle)%\u89d2\u70b9\u68c0\u6d4b\n\ncorner_num=0;\ncout=[];\nGaussianDieOff = .0001; \npw = 1:30; \nssq = sig*sig;\nwidth = max(find(exp(-(pw.*pw)\/(2*ssq))>GaussianDieOff));\nif isempty(width)\n    width = 1;  \nend\nt = (-width:width);\ngau = exp(-(t.*t)\/(2*ssq))\/(2*pi*ssq); \ngau=gau\/sum(gau);\n\nfor i=1:curve_num;\n    [m,n] = size(curve{1,i});\n    x=curve{i}(:,1);\n    y=curve{i}(:,2);\n    K1{i}(:,1)=x;\n    K1{i}(:,2)=y;\n    W=width;\n    L=size(x,1);\n    if L>W\n        % Calculate curvature\n        if curve_mode(i,:)=='loop'\n            x1=[x(L-W+1:L);x;x(1:W)];\n            y1=[y(L-W+1:L);y;y(1:W)];\n        else\n            x1=[ones(W,1)*2*x(1)-x(W+1:-1:2);x;ones(W,1)*2*x(L)-x(L-1:-1:L-W)];\n            y1=[ones(W,1)*2*y(1)-y(W+1:-1:2);y;ones(W,1)*2*y(L)-y(L-1:-1:L-W)];\n        end\n         \n        xx=conv(x1,gau);  \n        xx=xx(W+1:L+3*W);\n        yy=conv(y1,gau);\n        yy=yy(W+1:L+3*W);\n        Xu=[xx(2)-xx(1) ; (xx(3:L+2*W)-xx(1:L+2*W-2))\/2 ; xx(L+2*W)-xx(L+2*W-1)];\n        Yu=[yy(2)-yy(1) ; (yy(3:L+2*W)-yy(1:L+2*W-2))\/2 ; yy(L+2*W)-yy(L+2*W-1)];\n        Xuu=[Xu(2)-Xu(1) ; (Xu(3:L+2*W)-Xu(1:L+2 *W-2))\/2 ; Xu(L+2*W)-Xu(L+2*W-1)];\n        Yuu=[Yu(2)-Yu(1) ; (Yu(3:L+2*W)-Yu(1:L+2*W-2))\/2 ; Yu(L+2*W)-Yu(L+2*W-1)];\n        K=abs((Xu.*Yuu-Xuu.*Yu).\/((Xu.*Xu+Yu.*Yu).^1.5));\n        %Kreal=(Xu.*Yuu-Xuu.*Yu).\/((Xu.*Xu+Yu.*Yu).^1.5);\n        K1{i}(:,3)=K(13:m+12)';   \n        \n            \n        K=ceil(K*100)\/100;\n               \n        % Find curvature local maxima as corner candidates\n        extremum=[];\n        N=size(K,1);\n        n=0;\n        Search=1;\n        \n        for j=1:N-1\n            if (K(j+1)-K(j))*Search>0\n                n=n+1;\n                extremum(n)=j;  % In extremum, odd points is minima and even points is maxima\n                Search=-Search;\n            end\n        end\n        if mod(size(extremum,2),2)==0\n            n=n+1;\n            extremum(n)=N;\n        end\n    \n        n=size(extremum,2);\n        flag=ones(size(extremum));\n  \n        % Compare with adaptive local threshold to remove round corners\n        for j=2:2:n\n            %I=find(K(extremum(j-1):extremum(j+1))==max(K(extremum(j-1):extremum(j+1))));\n            %extremum(j)=extremum(j-1)+round(mean(I))-1; % Regard middle point of plateaus as maxima\n            \n            [x,index1]=min(K(extremum(j):-1:extremum(j-1)));\n            [x,index2]=min(K(extremum(j):extremum(j+1)));\n            ROS=K(extremum(j)-index1+1:extremum(j)+index2-1);\n            K_thre(j)=C*mean(ROS);\n            if K(extremum(j))<K_thre(j)\n                flag(j)=0;\n            end\n        end\n        extremum=extremum(2:2:n);\n        flag=flag(2:2:n);\n        extremum=extremum(find(flag==1));\n        \n        % Check corner angle to remove false corners due to boundary noise and trivial details\n        flag=0;\n        smoothed_curve=[xx,yy];\n        while sum(flag==0)>0\n            n=size(extremum,2);\n            flag=ones(size(extremum)); \n            for j=1:n\n                if j==1 & j==n\n                    ang=curve_tangent(smoothed_curve(1:L+2*W,:),extremum(j));\n                elseif j==1 \n                    ang=curve_tangent(smoothed_curve(1:extremum(j+1),:),extremum(j));\n                elseif j==n\n                    ang=curve_tangent(smoothed_curve(extremum(j-1):L+2*W,:),extremum(j)-extremum(j-1)+1);\n                else\n                    ang=curve_tangent(smoothed_curve(extremum(j-1):extremum(j+1),:),extremum(j)-extremum(j-1)+1);\n                end     \n                if ang>T_angle & ang<(360-T_angle)\n                    flag(j)=0;  \n                end\n            end\n             \n            if size(extremum,2)==0\n                extremum=[];\n            else\n                extremum=extremum(find(flag~=0));\n            end\n        end\n            \n        extremum=extremum-W;\n        extremum=extremum(find(extremum>0 & extremum<=L));\n        n=size(extremum,2);     \n        for j=1:n     \n            corner_num=corner_num+1;\n            cout(corner_num,:)=curve{i}(extremum(j),:);\n        end\n    end\nend\n\n\n% Add Endpoints\nif Endpoint\n    for i=1:curve_num\n        if size(curve{i},1)>0 & curve_mode(i,:)=='line'\n            \n            % Start point compare with detected corners\n            compare_corner=cout-ones(size(cout,1),1)*curve_start(i,:);\n            compare_corner=compare_corner.^2;\n            compare_corner=compare_corner(:,1)+compare_corner(:,2);\n            if min(compare_corner)>25       % Add end points far from detected corners \n                corner_num=corner_num+1;\n                cout(corner_num,:)=curve_start(i,:);\n            end\n            \n            % End point compare with detected corners\n            compare_corner=cout-ones(size(cout,1),1)*curve_end(i,:);\n            compare_corner=compare_corner.^2;\n            compare_corner=compare_corner(:,1)+compare_corner(:,2);\n            if min(compare_corner)>25\n                corner_num=corner_num+1;\n                cout(corner_num,:)=curve_end(i,:);\n            end\n        end\n    end\nend\n end\n\nfunction ang=curve_tangent(cur,center)\n\nfor i=1:2\n    if i==1\n        curve=cur(center:-1:1,:);\n    else\n        curve=cur(center:size(cur,1),:);\n    end\n    L=size(curve,1);\n    \n    if L>3\n        if sum(curve(1,:)~=curve(L,:))~=0\n            M=ceil(L\/2);\n            x1=curve(1,1);\n            y1=curve(1,2);\n            x2=curve(M,1);\n            y2=curve(M,2);\n            x3=curve(L,1);\n            y3=curve(L,2);\n        else\n            M1=ceil(L\/3);\n            M2=ceil(2*L\/3);\n            x1=curve(1,1);\n            y1=curve(1,2);\n            x2=curve(M1,1);\n            y2=curve(M1,2);\n            x3=curve(M2,1);\n            y3=curve(M2,2);\n        end\n        \n        if abs((x1-x2)*(y1-y3)-(x1-x3)*(y1-y2))<1e-8  % straight line\n            tangent_direction=angle(complex(curve(L,1)-curve(1,1),curve(L,2)-curve(1,2)));\n        else\n            % Fit a circle \n            x0 = 1\/2*(-y1*x2^2+y3*x2^2-y3*y1^2-y3*x1^2-y2*y3^2+x3^2*y1+y2*y1^2-y2*x3^2-y2^2*y1+y2*x1^2+y3^2*y1+y2^2*y3)\/(-y1*x2+y1*x3+y3*x2+x1*y2-x1*y3-x3*y2);\n            y0 = -1\/2*(x1^2*x2-x1^2*x3+y1^2*x2-y1^2*x3+x1*x3^2-x1*x2^2-x3^2*x2-y3^2*x2+x3*y2^2+x1*y3^2-x1*y2^2+x3*x2^2)\/(-y1*x2+y1*x3+y3*x2+x1*y2-x1*y3-x3*y2);\n            % R = (x0-x1)^2+(y0-y1)^2;\n\n            radius_direction=angle(complex(x0-x1,y0-y1));\n            adjacent_direction=angle(complex(x2-x1,y2-y1));\n            tangent_direction=sign(sin(adjacent_direction-radius_direction))*pi\/2+radius_direction;\n        end\n    \n    else % very short line\n        tangent_direction=angle(complex(curve(L,1)-curve(1,1),curve(L,2)-curve(1,2)));\n    end\n    direction(i)=tangent_direction*180\/pi;\nend\nang=abs(direction(1)-direction(2));\nend\n\nfunction img1=mark(img,x,y,w)%use to draw figure of concave and convex points\n\n[M,N,C]=size(img);\nimg1=img;\n\nif isa(img,'logical')\n    img1(max(1,x-floor(w\/2)):min(M,x+floor(w\/2)),max(1,y-floor(w\/2)):min(N,y+floor(w\/2)),:)=...\n        (img1(max(1,x-floor(w\/2)):min(M,x+floor(w\/2)),max(1,y-floor(w\/2)):min(N,y+floor(w\/2)),:)<1);\n    img1(x-floor(w\/2)+1:x+floor(w\/2)-1,y-floor(w\/2)+1:y+floor(w\/2)-1,:)=...\n        img(x-floor(w\/2)+1:x+floor(w\/2)-1,y-floor(w\/2)+1:y+floor(w\/2)-1,:);\nelse\n    img1(max(1,x-floor(w\/2)):min(M,x+floor(w\/2)),max(1,y-floor(w\/2)):min(N,y+floor(w\/2)),:)=...\n        (img1(max(1,x-floor(w\/2)):min(M,x+floor(w\/2)),max(1,y-floor(w\/2)):min(N,y+floor(w\/2)),:)<128)*255;\n    img1(x-floor(w\/2)+1:x+floor(w\/2)-1,y-floor(w\/2)+1:y+floor(w\/2)-1,:)=...\n        img(x-floor(w\/2)+1:x+floor(w\/2)-1,y-floor(w\/2)+1:y+floor(w\/2)-1,:);\nend\nend\n   % red point -- One order leaf tooth\nfunction img2=mark2(img,x,y,w)\n     [M,N,C]=size(img);\n     img2=img;\n   \n     img2(max(1,x-floor(w\/2)):min(M,x+floor(w\/2)),max(1,y-floor(w\/2)):min(N,y+floor(w\/2)),1)=255;\n     img2(max(1,x-floor(w\/2)):min(M,x+floor(w\/2)),max(1,y-floor(w\/2)):min(N,y+floor(w\/2)),2)=0;\n     img2(max(1,x-floor(w\/2)):min(M,x+floor(w\/2)),max(1,y-floor(w\/2)):min(N,y+floor(w\/2)),3)=0;\n\n\n    img2(x-floor(w\/2)+1:x+floor(w\/2)-1,y-floor(w\/2)+1:y+floor(w\/2)-1,:)=...\n        img(x-floor(w\/2)+1:x+floor(w\/2)-1,y-floor(w\/2)+1:y+floor(w\/2)-1,:);\nend\n   % blue point -- two orders leaf tooth \nfunction img3=mark1(img,x,y,w)\n     [M,N,C]=size(img);\n     img3=img;\n   \n     img3(max(1,x-floor(w\/2)):min(M,x+floor(w\/2)),max(1,y-floor(w\/2)):min(N,y+floor(w\/2)),1)=0;\n     img3(max(1,x-floor(w\/2)):min(M,x+floor(w\/2)),max(1,y-floor(w\/2)):min(N,y+floor(w\/2)),2)=0;\n     img3(max(1,x-floor(w\/2)):min(M,x+floor(w\/2)),max(1,y-floor(w\/2)):min(N,y+floor(w\/2)),3)=255;\n\n\n    img3(x-floor(w\/2)+1:x+floor(w\/2)-1,y-floor(w\/2)+1:y+floor(w\/2)-1,:)=...\n        img(x-floor(w\/2)+1:x+floor(w\/2)-1,y-floor(w\/2)+1:y+floor(w\/2)-1,:);\nend\n\nfunction [I,C,T_angle,sig,H,L,Endpoint,S,Gap_size,Name] = parse_inputs(varargin);\n\nerror(nargchk(0,8,nargin));\n\nPara=[1.5,162,6,0.25,0,1,60,3]; %Default experience value;H=0.35\n\nif nargin>=2\n    I=varargin{1};\n    for i=2:nargin\n        if size(varargin{i},1)>0\n            Para(i-1)=varargin{i};\n        end\n    end\nend\n\nif nargin==1\n    I=varargin{1};\nend\n    \nif nargin==0 | size(I,1)==0\n    [fname,dire]=uigetfile('*.bmp;*.jpg;*.gif','Open the image to be detected');\n    I=imread([dire,fname]);\nend\n\nC=Para(1);\nT_angle=Para(2);\nsig=Para(3);\nH=Para(4);\nL=Para(5);\nEndpoint=Para(6);\nS=Para(7);\nGap_size=Para(8);\nend%\u6682\u4e0d\u7528\n\nfunction [h1]=preprocess(img)%preprocess\n\nI = rgb2gray(img);\nthreshold = graythresh(I);%\nbw = ~im2bw(I,threshold);%\nse = strel('disk',2);%\nbw = imclose(bw,se);%\nbw = imfill(bw,'holes');%\nh1=~bw;\n\nend\n\nfunction [convex,toothNumber]=convexFinder(cout,r,img)%classsify concave and convex points\n\nimg=double(img);\nconvex=[];\ntoothNumber=0;\n\nfor k=1:size(cout,1)\ntarget=0;\nbase=0;\n\nfor m=-r:r\n    for n=-r:r\n        if m^2+n^2<=r^2\n            if img(cout(k,1)+m,cout(k,2)+n)==0\n                target=target+1;\n            elseif img(cout(k,1)+m,cout(k,2)+n)==1\n                base=base+1;\n            end\n        end\n    end\nend\nif target<0.8*base% it is concave when the number of black points less than the white points \n   toothNumber=toothNumber+1;\n   convex(toothNumber,1)=cout(k,1);\n   convex(toothNumber,2)=cout(k,2);\n\n \nend\nend\nend\n\nfunction [concave,sinusShape]=concaveFinder(curve,convex,K1)%concave fingding\n\nconcave=[];\ncur=[];\nm=1;\n%calculate the distance between the edge points and the points between two\n%convex points \nfor i=1:size(convex,1)-1\n    x1=convex(i,2);\n    y1=convex(i,1);\n    x2=convex(i+1,2);\n    y2=convex(i+1,1);\n    [rc1,lc1]=find(curve(:,2)==x1);\n    [rc2,lc2]=find(curve(:,1)==y1);\n    j=intersect(rc1,rc2);%\u6c42\u4ea4\u96c6\n    [rc1,lc1]=find(curve(:,2)==x2);\n    [rc2,lc2]=find(curve(:,1)==y2);\n    k=intersect(rc1,rc2); \n \n   x3=curve(j:k,2);\n   y3=curve(j:k,1);\n  [rx3,cx3]=size(x3);\n   x1=ones(rx3,1).*x1;\n   y1=ones(rx3,1).*y1;\n   x2=ones(rx3,1).*x2;\n   y2=ones(rx3,1).*y2;\n   distan=abs((x2-x1).*y3-(y2-y1).*x3-(x2-x1).*y1+x1.*(y2-y1)).\/sqrt((x2-x1).*(x2-x1)+(y2-y1).*(y2-y1));\n      \n   [mem,Pos]=max(distan(:,1)); \n   concave(m,1)=curve(j+Pos-1,1);\n   concave(m,2)=curve(j+Pos-1,2);\n   cur(m,1)=K1(j+Pos-1,3);\n   m=m+1;\n    \n    \n    \nend\n%classify sinus shape\nif mean(cur)>0.0512\n    sinusShape=1;\nelse\n    sinusShape=0;\nend\n\nend\n\nfunction [distan,convex,order]=toothOrder(convex,concave)  % calculate the number of orders of teeth\ndistan=[];\nx1=concave(1:size(concave(:,1))-1,2);\ny1=concave(1:size(concave(:,1))-1,1);\nx2=concave(2:size(concave(:,1)),2);\ny2=concave(2:size(concave(:,1)),1);\nx3=convex(2:size(convex(:,1))-1,2);\ny3=convex(2:size(convex(:,1))-1,1);\ndistan=abs((x2-x1).*y3-(y2-y1).*x3-(x2-x1).*y1+x1.*(y2-y1)).\/sqrt((x2-x1).*(x2-x1)+(y2-y1).*(y2-y1));\n%excluded the abnormal points\n[n,m]=size(distan);\n[rc,lc]=find(distan>2*mean(distan));\ndistan(rc(1:size(rc)))=[];\nconvex(rc(1:size(rc))+1,:)=[];\n%normalization\n%distan=distan\/max(distan);\n[rc,lc]=find(distan<mean(distan));\nsize_rc =size(rc);\nif size_rc(1,1)>(n\/2)\n    distan(1,2)=2;\n    order=2;\n    for i=2:size(distan)-1        \n       if  (distan(i)>distan(i-1))&&(distan(i)>distan(i+1))\n           distan(i,2)=1;\n       else\n           distan(i,2)=2;\n       end        \n    end  \n    distan(size(distan),2)=2;\nelse \n    %one order only\n    order=1;\n    distan(:,2)=1;\nend\n    \nconvex(2:size(convex(:,1))-1,3)=distan(:,2);\n \nend\n\nfunction flag=toothSpacing(convex)% Tooth spacing Regularor or Irregular\n     first=[];\n     secord=[];\n     firstdistan=[];\n     secorddistan=[];\n     [rc1,lc1]=find(convex(:,3)==1);\n     [rc2,lc2]=find(convex(:,3)==2);\n     %the distance between 1st order of teeth\n     x1=convex(rc1(1:size(rc1)-1),2);\n     y1=convex(rc1(1:size(rc1)-1),1);\n     x2=convex(rc1(2:size(rc1)),2);\n     y2=convex(rc1(2:size(rc1)),1);\n     firstdistan=sqrt((x2-x1).*(x2-x1)+(y2-y1).*(y2-y1));\n     %the distance between 2nd order of teeth\n     x1=convex(rc2(1:size(rc2)-1),2);\n     y1=convex(rc2(1:size(rc2)-1),1);\n     x2=convex(rc2(2:size(rc2)),2);\n     y2=convex(rc2(2:size(rc2)),1);\n     secorddistan=sqrt((x2-x1).*(x2-x1)+(y2-y1).*(y2-y1));\n     %\u5224\u65ad\u662f\u5426\u662fRegular\u7684\u53f6\u9f7f\n     if isempty(rc2)\n     %\u82e5\u4ec5\u6709\u4e00\u7ea7\u9f7f\n         firstdistan=sort(firstdistan);\n         [rc,lc]=size(firstdistan);\n         %\u53bb\u9664\u5f02\u5e38\u503c\u70b9\n         while firstdistan(rc)*0.7>firstdistan(rc-1)\n             firstdistan(rc)=[];\n             [rc,lc]=size(firstdistan);\n         end\n          d2=min(firstdistan);\n          [rc,lc]=find(firstdistan==d2);\n          firstdistan(rc)=[];\n          [rc,lc]=size(firstdistan);\n         if  rc>=20  %\u4e00\u7ea7\u9f7f\u4e2a\u6570\u5927\u4e8e10\n         d1=mean(firstdistan(size(firstdistan)-15:size(firstdistan)-5));\n         d2=mean(firstdistan(1:10));\n         else\n             d1=firstdistan(size(firstdistan));\n             d2=firstdistan(1);\n         end\n     else\n         %\u82e5\u6709\u4e8c\u7ea7\u9f7f\n         firstdistan=sort(firstdistan);\n         secorddistan=sort(secorddistan);\n         t=size(firstdistan);\n         if size(firstdistan)>5 & size(secorddistan)>5 %\u4e00\u4e8c\u7ea7\u9f7f\u4e2a\u6570\u5927\u4e8e5\n         d1=mean(firstdistan(size(firstdistan)-4:size(firstdistan)));\n         d2=mean(secorddistan(1:5));\n         else\n             d1=firstdistan(size(firstdistan));\n             d2=secorddistan(1);\n         end\n     end\n     \n     if d2>=d1*0.6\n        flag=0;%Regular\n     else\n        flag=1;%Irregular\n     end\n     \nend\n\nfunction toothShape=toothShapeFinder(curve1,convex,concave,I1,I)%calculate Tooth shape\n\n x1=convex(1,2);y1=convex(1,1);\n x2=concave(1,2);y2=concave(1,1);\n curve=curve1{1,1};\n%linear fitting \n    [rc1,lc1]=find(curve(:,2)==x1);\n    [rc2,lc2]=find(curve(:,1)==y1);\n    j=intersect(rc1,rc2);%\u6c42\u4ea4\u96c6\n    [rc1,lc1]=find(curve(:,2)==x2);\n    [rc2,lc2]=find(curve(:,1)==y2);\n    k=intersect(rc1,rc2); \n    d=abs(k-j)\/2;\n    m=2;\n\n   if j<k\n   x=curve(j:k,2);\n   y=curve(j:k,1);\n   [p,s]=polyfit(x,y,m);\n   end  \n    flag=0;\n    a1=p(1,1); \n    a2=p(1,2);\n    a3=p(1,3);\n    if a1>-0.007&&a1<0.005\n        flag=3;\n    else     \n       crossPoints = [];\n       number_crossPoint=0;\n        yN=(y2-y1)\/(x2-x1)*(x-x1)+y1;\n        yN_int=round((y2-y1)\/(x2-x1)*(x-x1)+y1);\n        xN=x;\n        % C point finding\n        for index_line =round(2+(0.05*(k-j))):round(0.95*(k-j))\n            for index_curve =2:k-j\n                if (xN(index_line)==x(index_curve) && yN_int(index_line)==y(index_curve))\n                    number_crossPoint = number_crossPoint+1;\n                    crossPoints = [crossPoints;index_line,index_curve,y(index_curve),x(index_curve)];\n                end\n            end\n        end\n    %%%%%%%%%%%%%%%%%%%%%%%%% showing the shape of the tooth  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n%         figure\n%         plot(yN_int,xN);\n%         hold on;\n%         plot(y,x);\n\n    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    \n        size_cp = size(crossPoints);\n        index_mid = round(size_cp(1,1)\/2);\n        [NumberWhite,NumberBlack,NumberWhiteCE,NumberBlackCE] =deal(0);\n\n        if isempty(crossPoints)==true \n            %%  CrossPoint C exist \n            for index_x = 3:k-j-1\n              for indexImage_y = yN_int(index_x):y(index_x)\n                  if I1(indexImage_y,x(index_x))==false\n                    NumberBlack = NumberBlack + 1;\n                  else\n                    NumberWhite = NumberWhite + 1;\n                  end\n              end          \n            end\n            if NumberWhite>NumberBlack  \n                flag =1; % concave \n            else\n                flag =2; % convex \n            end\n\n        else\n        %%CrossPoint C  doesn't exist \n%             hold on;\n%             plot(crossPoints(:,3),crossPoints(:,4),'rp');\n            \n            for index_x = 3:crossPoints(index_mid,2)\n              for indexImage_y = yN_int(index_x):y(index_x)\n                  if I1(indexImage_y,x(index_x))==false\n                    NumberBlack = NumberBlack + 1;\n                  else\n                    NumberWhite = NumberWhite +1;\n                  end\n              end          \n            end\n\n            %%%%%%%%%%%%%%%%% The second part %%%%%%%%%%%%%%%%\n            for index_x = crossPoints(index_mid,2)+2:k-j-1\n              for indexImage_y = yN_int(index_x):y(index_x)\n                  if I1(indexImage_y,x(index_x))==false\n                    NumberBlackCE = NumberBlackCE + 1;\n                  else\n                    NumberWhiteCE = NumberWhiteCE +1;\n                  end\n              end          \n            end\n            \n            if (NumberWhite<NumberBlack && NumberWhiteCE>NumberBlackCE)\n                flag =21; % Fl\n            elseif (NumberWhite>NumberBlack && NumberWhiteCE<NumberBlackCE)\n                flag =12; % RT\n            elseif (NumberWhite>NumberBlack && NumberWhiteCE>=NumberBlackCE)\n                flag =1; \n            elseif (NumberWhite<=NumberBlack && NumberWhiteCE<=NumberBlackCE)\n                flag =2; \n\n            end         \n\n        end\n    end\n    toothShape=flag;\nend","command":"toothFeature_finished.m","os_name":"windows","os_version":"10"}}],"cases":null,"data":null,"section":null,"section_color":"#A492FF"}],"materials":[],"description":"<div class = \"text-blocks\"><div class = \"text-block\">Previous studies extract features that are not strictly defined in botany; therefore, a uniform standard to compare the accuracies of various feature extraction methods cannot be used. For efficient and automatic retrieval of plant leaves from a leaf database, in this study, we propose an image-based description and measurement of leaf teeth by referring to the leaf structure classification system in botany. First, image preprocessing is carried out to obtain a binary map of plant leaves. Then, corner detection based on the curvature scale-space (CSS) algorithm is used to extract the inflection point from the edges; next, the leaf tooth apex is extracted by screening the convex points; then, according to the definition of the leaf structure, the characteristics of the leaf teeth are described and measured in terms of number of orders of teeth, tooth spacing, number of teeth, sinus shape, and tooth shape.<\/div><\/div>","changed_on":1546529000}