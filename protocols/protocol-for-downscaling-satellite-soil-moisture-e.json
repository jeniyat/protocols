{"id":26722,"title":"Protocol for Downscaling Satellite Soil Moisture Estimates using Geomorphometry and Machine Learning","title_html":"Protocol for Downscaling Satellite Soil Moisture Estimates using Geomorphometry and Machine Learning","image":{"source":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/ef3c9df7190ee7ef2ffaa81371db1e42ee2b8312b31157256cb03cdfa6dae36f\/bpga8mpn.png","placeholder":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/ef3c9df7190ee7ef2ffaa81371db1e42ee2b8312b31157256cb03cdfa6dae36f\/bpga8mpn.png"},"doi":"dx.doi.org\/10.17504\/protocols.io.6cahase","doi_status":2,"uri":"protocol-for-downscaling-satellite-soil-moisture-e-6cahase","type_id":1,"published_on":1569427562,"parent_protocols":[],"parent_collections":[],"version_id":0,"created_on":1565377345,"categories":null,"creator":{"name":"Mario Guevara","affiliation":"University of Delaware","affiliations":[{"affiliation":"University of Delaware","url":"","is_default":1}],"username":"mario-guevara","link":"https:\/\/www.biorxiv.org\/content\/10.1101\/688846v1.abstract","image":{"source":"\/img\/avatars\/011.png","placeholder":"\/img\/avatars\/011.png"},"badges":[{"id":2,"image":{"source":"\/img\/badges\/bronze.svg","placeholder":"\/img\/badges\/bronze.svg"},"name":"Author"}],"research_interests":null,"blocked_by_you":false,"blocked_you":false},"journal":"PLOS One","journal_name":"PLOS One","journal_link":"https:\/\/doi.org\/10.1371\/journal.pone.0219639","article_citation":"Guevara M,  Vargas R (2019) Downscaling satellite soil moisture using geomorphometry and machine learning. PLoS ONE  14(9): e0219639. doi: <a target=\"_blank\" href=\"https:\/\/dx.doi.org\/10.1371\/journal.pone.0219639\">10.1371\/journal.pone.0219639<\/a> ","public":1,"has_versions":0,"link":"https:\/\/www.biorxiv.org\/content\/10.1101\/688846v1.abstract","total_collections":0,"number_of_steps":5,"authors":[{"name":"Mario Guevara","affiliation":"University of Delaware, Department of Plant and Soil Sciences","affiliations":[],"username":"mario-guevara","link":null,"image":{"source":"\/img\/avatars\/011.png","placeholder":"\/img\/avatars\/011.png"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false},{"name":"Rodrigo Vargas","affiliation":"University of Delaware, Department of Plant and Soil Sciences","affiliations":[],"username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false}],"versions":[],"groups":[],"has_subprotocols":0,"is_subprotocol":0,"is_bookmarked":0,"can_be_copied":1,"can_remove_fork":1,"forks_count":{"private":0,"public":0},"access":{"can_view":1,"can_remove":0,"can_add":0,"can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":1,"can_move":1,"can_move_outside":1,"can_transfer":1,"can_download":1,"is_locked":0},"guid":"60B5A56FBDB711E9A1D70242AC11000B","steps":[{"id":795033,"guid":"38D9F060BAD811E992E2231785C6865A","previous_id":null,"previous_guid":null,"modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"D99FFC48BB4E4AB2AB8F0168B746436A","order_id":1,"type_id":6,"title":"Section","source":{"title":""}},{"id":1054724,"guid":"24393EB47C324E23B1708175958DAA44","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>PREPARE PREDICTION FACTORS: This first stetp is to prepare the prediction factors. Once R is installed and running, please load the library <\/span><span style = \"font-style:italic;\">raster<\/span><span> and import the DEM terrain parameters. This example is using a geographical coordinate system (lat, long) in degrees ('+proj=longlat +datum=WGS84 +no_defs'). We will consider (as in this <\/span><\/div><div class = \"text-block\"><a href=\"https:\/\/www.biorxiv.org\/content\/biorxiv\/early\/2019\/07\/01\/688846.full.pdf\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">case<\/span><\/a><\/div><div class = \"text-block\"><span>) that the topographic prediction factors are in a specified path in the local computer (e.g., 'path\/to\/topographic\/files') and that all of them (n=15) have a SAGA-GIS native *.sdat format (these can be *.tif, *.asc or any other generic raster files).  If you have your own set of prediction factors in the same projection system and pixel size, reproject (if needed) to a geographical coordinate system (because that is the projection of the ESA-CCI satellite soil moisture product that we are using for testing this protocol), convert to a <\/span><span style = \"font-style:italic;\">'SpatialPixelDataFrame' <\/span><span>object and go to step 2.  <\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-style:italic;\">##library to manage raster files<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">library(raster)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">##path to prediction factors (e.g., a folder with *.tif predictors)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">lis1 <- 'path\/to\/topographic\/files' <\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">##object with the names of the predictor raster files <\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#(can be *.tif or *.asc, or *.img files)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">lis2 <-list.files(lis1, full.name=TRUE, pattern ='sdat')<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">##make a raster stack of the files<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">x <- stack(lis2)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#function to remove NAs<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">NA2mean <- function(x) replace(x, is.na(x), median(x, na.rm = TRUE))<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#convert to spatial pixels dataframe (this will take overnight on conventional systems, but will work)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">x=as(x,'SpatialPixelsDataFrame')<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#for global downscaling use this line<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#x=as(s,'SpatialPixelsDataFrame')<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#transform NAs to median values of layer<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">x@data[] <- lapply(x@data, NA2mean)<\/span><\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>The resulting object <\/span><span style = \"font-style:italic;\">x<\/span><span> (from this step) contains the prediction factors used as the basis of the downscaling process. This object containing all terrain parameters is an internal R format tyme known as '<\/span><span style = \"font-style:italic;\">SpatialPixelsDataFrame'.<\/span><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0},{"id":795089,"guid":"7E8FA540BADE11E9997EFF9CD2505F07","previous_id":795033,"previous_guid":"38D9F060BAD811E992E2231785C6865A","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"8484DC07BDBA4564AF70C3C57ACCA16D","order_id":1,"type_id":6,"title":"Section","source":{"title":""}},{"id":1054724,"guid":"91EA8AC475CD4DB9BB5743CC8D09AA25","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">PREPARE RESPONSE VARIABLE: The next step is about getting and importing the soil moisture dataset that is going to be downscaled to a finer pixel size. For our <\/div><div class = \"text-block\"><a href=\"https:\/\/www.biorxiv.org\/content\/biorxiv\/early\/2019\/07\/01\/688846.full.pdf\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">paper<\/span><\/a><\/div><div class = \"text-block\"> we used the European Space Agency-Climate Change Initiative soil moisture product (ESA-CCI). These data sets are provided here: <\/div><div class = \"text-block\"><a href=\"https:\/\/www.esa-soilmoisture-cci.org\/\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">https:\/\/www.esa-soilmoisture-cci.org\/<\/span><\/a><\/div><div class = \"text-block\"> . These data is provided yearly folders and in *.nc files (one file per day) and we can import these files in R using the following code for listing the folders with the satellite soil moisture data. Download the satellite soil moisture maps of your convenience and place them in your working directory. <\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-style:italic;\">#list.dirs is a function used for generating a list of the annual soil moisture #folders as provided by the ESA-CCI initiative<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">dirs <- list.dirs()[-1]<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#we can start a loop but first test with a yearly mean or median first<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#test with i=1 before the loop<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#i=1<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#for (i in 1:26){#if you want it to make it daily use 1:366, <\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#1:26 means 26 years between 1991 and 2016<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#stack soil moisture records for a given folder\/year<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#in this case i = 1 = year 1991<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#change the nc extention if your satellite data is in another format<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">r <- stack(paste0(dirs[i], '\/',list.files(dirs[i], pattern='nc')), varname='sm')<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#crop, if needed, to area of interes using an extent <\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#this is the extent of the prediction factors<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#consider that satellite soil moisture has 27km pixels, select at least 30 - 50 of #this pixels to build the models. Higher pixels for training models higher accuracy.  <\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">r <- crop (r, extent(x))<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#calculate median year value from daily estimates, <\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#avoid this line if you want to go in day or month basis<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">r <- calc(r, median,  na.rm=TRUE)<\/span><\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>The resulting raster object <\/span><span style = \"font-style:italic;\">r<\/span><span> will be harmonized with the result of step 1 in order to build a regression matrix for soil moisture. In this case <\/span><span style = \"font-style:italic;\">r<\/span><span> is the mean value of soil moisture estimates avaialable in the ESA-CCI product for the year 1991.<\/span><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0},{"id":795108,"guid":"828234D0BAE111E9997EFF9CD2505F07","previous_id":795089,"previous_guid":"7E8FA540BADE11E9997EFF9CD2505F07","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"87B60A5F3861452E99898D9CAA5ACA05","order_id":1,"type_id":6,"title":"Section","source":{"title":""}},{"id":1054724,"guid":"BAC5DDF841B544AE9F202FF039933629","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">REGRESSION MATRIX: Next step is building a regresion matrix. This is a data frame with columns for coordinates, colum for soil moisture data and columns of terrain parameters. This regression matrix will be used for building a model in the next step. <\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-style:italic;\">#define lat long projection<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">proj4string(r) <- CRS(\"+proj=longlat +datum=WGS84 +no_defs\")<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#convert to data frame<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">df=as.data.frame(r, xy=T)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#remove no data values<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">df=na.omit(df)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#define column coordinates <\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">coordinates(df)=~x+y<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#and lat long projection system<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">proj4string(df) <- CRS(\"+proj=longlat +datum=WGS84 +no_defs\")<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#overlay soil moisture centroids and prediction factors (x)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">ov=over(df, x)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#generate a data frame<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">d=as.data.frame(df)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#combine extracted values<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">y=cbind(d,  ov)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#remove no data values<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">y=na.omit(y)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#training set year i<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">z=data.frame(z=y[,3],y[,1:2],  y[,4:18])<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#print dimensions of the regression matrix<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">print(dim(z))<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">ion (correlation obs vs mod [cd] and RMSE as well as N) in a data frame named results<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#empty dataframe to store results<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">results<-data.frame(year=numeric(), cor=numeric(),rmse=numeric(), n=numeric(),kernel=as.character(),stringsAsFactors=FALSE,k=numeric()<\/span><\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>The resulting object is a data frame <\/span><span style = \"font-style:italic;\">z<\/span><span>, with the coordinate colums of centroids of ESA-CCI pixels and the corresponding values for those coordinates of the terrain parameters. This regression is used for building models and generating digital soil moisture maps. We additionally generate an empty data frame <\/span><span style = \"font-style:italic;\">results<\/span><span> for saving the modeling results (cross validation accuracy).<\/span><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0},{"id":795151,"guid":"E34FA7C0BAEB11E9A225697DE10542BA","previous_id":795108,"previous_guid":"828234D0BAE111E9997EFF9CD2505F07","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"B3E3355D90C142DDB3AD392575494B44","order_id":1,"type_id":6,"title":"Section","source":{"title":""}},{"id":1054724,"guid":"7A63B6D9732E48DC81CA24B80FCE6F86","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">MODELING SOIL MOISTURE: Next we build a prediction model. We used as in our paper a kernel based machine learning model, but it can be any model able to account for non linear relationships see methos section of our <\/div><div class = \"text-block\"><a href=\"https:\/\/www.biorxiv.org\/content\/biorxiv\/early\/2019\/07\/01\/688846.full.pdf\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">paper<\/span><\/a><\/div><div class = \"text-block\"><span>. We start loading the required library <\/span><span style = \"font-style:italic;\">kknn. <\/span><span>The 'optimal' model parameters k and the kernel function will be stored in the previously generated <\/span><span style = \"font-style:italic;\">results<\/span><span> object. In this results object we will also save the accuracy indicators (cor and rmse) indicating the correlation between observed and predicted and the corresponding root mean squared error. This accuracy metrics are derived from a 10-fold cross validation strategy. <\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-style:italic;\">library(kknn)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#you must select the best parameters by tunning them with CV,  the parameter K and the parameter kernel<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">##<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#k between 1 and 50 <\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">kmax=50<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#find optimal k and kernel type via 10 fold cross validation<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">knnTuning <- train.kknn(z~., data=z, kmax = kmax, distance = 2,<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">kernel = c(\"rectangular\", \"triangular\", \"epanechnikov\",\"gaussian\", \"rank\", \"optimal\"),<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">           ykernel = NULL, scale = TRUE,kcv=10)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#identify best kernel<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">n<-which(knnTuning$best.parameters$kernel==c(\"rectangular\", \"triangular\", \"epanechnikov\",\"gaussian\", \"rank\", \"optimal\"))<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#store best parameters<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">mejoresresultados <- data.matrix(unlist(knnTuning$fitted.values[[(kmax*(n-1))+knnTuning$best.parameters$k]]))<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#lowest rmse<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">rmse <- sqrt(knnTuning$MEAN.SQU[knnTuning$best.parameters$k,n])<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#highest correlation<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">cd <- cor(z[,1], mejoresresultados)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#modeling year (1991-2016)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">year=1990+i<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#prepare best kernel<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">as.character(unlist(knnTuning$best.parameters[1]))<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#prepare best k<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">k=as.numeric(knnTuning$best.parameters[2])<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#store results for year i in the data frame <\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">results[i,1]<-year<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">results[i,2]<-cd<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">results[i,3]<-rmse<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">results[i,4]<-dim(z)[1]<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">results[i,5]<-unlist(knnTuning$best.parameters[1])<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">results[i,6]<-k<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#print accuracy results on screen <\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">print(results)<\/span><\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>The resulting object of this section is a model that we can use to generate predictions. This model is cross validated and the accuracy report is in the object <\/span><span style = \"font-style:italic;\">results<\/span><span>. In this example we predict across all CONUS using 1km grids. <\/span><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0},{"id":795219,"guid":"748B0240BB6C11E9A225697DE10542BA","previous_id":795151,"previous_guid":"E34FA7C0BAEB11E9A225697DE10542BA","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"8A9C30B4722948A7A05E122E72C2A093","order_id":1,"type_id":6,"title":"Section","source":{"title":""}},{"id":1054724,"guid":"77C80D7A15CF4B00854B3129449EFD9B","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">PREDICTION ACROSS ALL AREA OF INTEREST: This is the final step. We apply the coefficients of the model (for each day or year) to all the prediction domain (defined by the terrain parameters). Thus we obtain a soil prediction for each pixel across the study area. These prediction values are acoupled with the coordinates of the center of each pixel and a digital soil moisture map is generated. <\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-style:italic;\">##build a model with best parameters, predict to all CONUS and make a map of it<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">mejorKKNN <- kknn(z~.,train=z,test=x,kernel=unlist(knnTuning$best.parameters[1]),<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">                        scale=TRUE,k=as.numeric(knnTuning$best.parameters[2]))<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#add fitted values to the prediction domain <\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">x$kknn=mejorKKNN$fitted.values<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#make a raster of the prediction<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">r <- raster(x['kknn'])<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#visualize the map <\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#plot(r)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#proj4string(r) <- CRS(\"+proj=longlat +datum=WGS84 +no_defs\")<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#save results<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">writeRaster(r, file=paste0('predicted-', 1990+i, '-esa-sm-topo-CONUS.tif'), overwrite=TRUE) ### change the name of the output files if necessary<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#print accuracy results on screen<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">print(results)<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">#save accuracy results<\/span><\/div><div class = \"text-block\"><span style = \"font-style:italic;\">write.csv(results, file=paste0('accuracy-', 1990+i, '-esa-sm-topo-CONUS.csv'))<\/span><\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span> The resulting objects from this step are a data frame <\/span><span style = \"font-style:italic;\">results<\/span><span> with the accuracy report of the model for each year, and the object <\/span><span style = \"font-style:italic;\">r<\/span><span>, a raster file containing the predictions of soil moisture across the study area. These objects are going to be saved in the working directory as a *.tif file for the raster object and in a *.csv for the <\/span><span style = \"font-style:italic;\">results<\/span><span> file.  <\/span><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0}],"document":null,"materials":[{"id":205102,"mol_weight":0,"name":"satellite soil moisture ","linfor":"","url":"https:\/\/www.esa-soilmoisture-cci.org\/node\/137","sku":"","cas_number":"","rrid":"","public":0,"vendor":{"name":"Contributed by users","affiliation":null,"affiliations":[],"username":null,"link":"https:\/\/www.protocols.io","image":{"source":"https:\/\/www.protocols.io\/img\/vendors\/1.png","placeholder":"https:\/\/www.protocols.io\/img\/vendors\/1.png"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"id":1},"can_edit":0,"stats":{"total_protocols":0}},{"id":205103,"mol_weight":0,"name":"SAGA GIS for calculating terrain parameters","linfor":"","url":"http:\/\/www.saga-gis.org\/","sku":"","cas_number":"","rrid":"","public":0,"vendor":{"name":"Contributed by users","affiliation":null,"affiliations":[],"username":null,"link":"https:\/\/www.protocols.io","image":{"source":"https:\/\/www.protocols.io\/img\/vendors\/1.png","placeholder":"https:\/\/www.protocols.io\/img\/vendors\/1.png"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"id":1},"can_edit":0,"stats":{"total_protocols":0}},{"id":205104,"mol_weight":0,"name":"digital elevation model","linfor":"","url":"https:\/\/topex.ucsd.edu\/sandwell\/publications\/124_MG_Becker.pdf","sku":"","cas_number":"","rrid":"","public":0,"vendor":{"name":"Contributed by users","affiliation":null,"affiliations":[],"username":null,"link":"https:\/\/www.protocols.io","image":{"source":"https:\/\/www.protocols.io\/img\/vendors\/1.png","placeholder":"https:\/\/www.protocols.io\/img\/vendors\/1.png"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"id":1},"can_edit":0,"stats":{"total_protocols":0}},{"id":205105,"mol_weight":0,"name":"R for statistical computing","linfor":"","url":"https:\/\/www.r-project.org\/","sku":"","cas_number":"","rrid":"","public":0,"vendor":{"name":"Contributed by users","affiliation":null,"affiliations":[],"username":null,"link":"https:\/\/www.protocols.io","image":{"source":"https:\/\/www.protocols.io\/img\/vendors\/1.png","placeholder":"https:\/\/www.protocols.io\/img\/vendors\/1.png"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"id":1},"can_edit":0,"stats":{"total_protocols":0}},{"id":205106,"mol_weight":0,"name":"reference preprint ","linfor":"","url":"https:\/\/www.biorxiv.org\/content\/biorxiv\/early\/2019\/07\/01\/688846.full.pdf","sku":"","cas_number":"","rrid":"","public":0,"vendor":{"name":"Contributed by users","affiliation":null,"affiliations":[],"username":null,"link":"https:\/\/www.protocols.io","image":{"source":"https:\/\/www.protocols.io\/img\/vendors\/1.png","placeholder":"https:\/\/www.protocols.io\/img\/vendors\/1.png"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"id":1},"can_edit":0,"stats":{"total_protocols":0}}],"description":"<div class = \"text-blocks\"><div class = \"text-block\">This protocol is composed of five steps for downscaling satellite soil moisture estimates using digital terrain parameters derived from a digital elevation models. We provide an alternative approach to predict soil moisture spatial patterns at higher spatial resolution (compared with current satellite soil moisture estimates) across areas where no information is otherwise available. This approach relies on geomorphometry derived terrain parameters and machine learning models to improve the statistical accuracy and the spatial resolution (from 27km to 1km grids) of satellite soil moisture information. This approach has been tested for this study across the conterminous United States on an annual basis (1991-2016). <\/div><div class = \"text-block\"><ul style = \"list-style-type:disc;\"><li style = \"counter-reset:ol0;list-style-type:disc;\">We first derived 15 primary and secondary terrain parameters from a digital elevation model. <\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">We trained a machine learning algorithm (i.e., kernel weighted nearest neighbors) for each year. <\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">Terrain parameters were used as predictors and annual satellite soil moisture estimates were used to train the models. <\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">We validate the models using cross-validation strategies and independent validation. <\/li><\/ul><\/div><div class = \"text-block\">The explained variance for all models-years was >70% (10-fold cross-validation). The 1km soil moisture grids (compared to the original satellite soil moisture estimates) had higher correlations with field soil moisture observations from the North American Soil Moisture Database (n=668 locations with available data between 1991-2013; 0-5cm depth) than the original product. We conclude that the fusion of geomorphometry methods and satellite soil moisture estimates is useful to increase the spatial resolution and accuracy of satellite-derived soil moisture. This approach can be applied to other satellite-derived soil moisture estimates and regions across the world.<\/div><\/div>","changed_on":1569427562}