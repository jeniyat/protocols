{"uri":"stranded-mapping-from-long-reads-n8cdhsw","version_id":"0","protocol_name":"Stranded Mapping from Long Reads","protocol_name_html":"Stranded Mapping from Long Reads","is_prepublished":"0","can_edit":"0","parent_id":null,"api_version":"1","is_new_mode":"0","last_modified":"1522818008","type_id":"1","link":"https:\/\/bioinformatics.stackexchange.com\/a\/3922\/73","fork_id":"","public_fork_note":"","number_of_steps":"6","has_versions":"1","first_published_date":"1522818008","publish_date":"2018-04-04 05:00:08","documents":null,"have_protocol_in_step":"0","is_protocol_in_step":"0","vendor_name":"Contributed by users","vendor_link":"https:\/\/www.protocols.io","vendor_logo":"\/img\/vendors\/1.png","mod_mins":"-45","mod_secs":"1","description":"<p>This protocol demonstrates how to convert raw long reads produced using a strand-specific sequencing protocol (e.g. ONT's strand-switching protocol) into strand-specific mapped reads.<\/p>\n<p>\u00a0<\/p>\n<p>The general ides is to use LAST to identify the adapter orientation relative to the genome, and then use that information to split BAM files up and recombine them to create two strand-specific files that are displayable in a genome browser.<\/p>","is_bookmarked":"0","can_reassign":"1","before_start":"<p>I have written <a href=\"https:\/\/github.com\/gringer\/bioinfscripts\/blob\/master\/maf_bcsplit.pl\" target=\"_blank\" rel=\"noopener noreferrer\">my own script<\/a> to process LAST results into a CSV format, which makes it easier to do line-by-line data filtering. I have also created a <a href=\"https:\/\/github.com\/gringer\/bioinfscripts\/blob\/master\/fastx-fetch.pl\" target=\"_blank\" rel=\"noopener noreferrer\">fastq filtering script<\/a> that helps for filtering reads into different files.<\/p>\n<p>\u00a0<\/p>\n<p>You will also need access to the following free and open-source software programs:<\/p>\n<ul>\n<li><a href=\"http:\/\/last.cbrc.jp\/\" target=\"_blank\" rel=\"noopener noreferrer\">LAST<\/a><\/li>\n<li><a href=\"https:\/\/github.com\/lh3\/minimap2#install\" target=\"_blank\" rel=\"noopener noreferrer\">minimap2<\/a><\/li>\n<li><a href=\"http:\/\/www.htslib.org\/download\/\" target=\"_blank\" rel=\"noopener noreferrer\">samtools<\/a><\/li>\n<\/ul>\n<p>And the following additional data files:<\/p>\n<ul>\n<li>a FASTA file containing strand-specific primer \/ adapter sequences.<\/li>\n<\/ul>","has_guidelines":"0","materials":[],"warning":"<p><em>T<\/em>hese scripts have been slightly modified from scripts that I have run. Consider them demonstrative: pay attention to the words rather than the script.<\/p>","version_class":"11236","public":"1","is_owner":"1","is_original_owner":"1","created_on":"1522816396","protocol_affiliation":"Malaghan Institute of Medical Research (NZ)","affiliation":"Malaghan Institute of Medical Research (NZ)","doi":"dx.doi.org\/10.17504\/protocols.io.n8cdhsw","doi_status":"2","changed_fork_steps":null,"profile_url":"DavidEccles-y2138443y2","protocol_img":"https:\/\/s3.amazonaws.com\/pr-journal\/vi4jpt6.png","profile_image":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg","full_name":"David Eccles","created_by":"David Eccles","private_link":"C105386313F31BBE2B05C52A131D8B8D","original_img":"1","username":"david-eccles","is_retracted":"0","retraction_reason":null,"plos_id":null,"manuscript_citation":null,"journal_name":null,"is_donations_disabled":"0","is_donations_disabled_by_user":"9","item_record_id":301058,"fork_info":[],"compare_forks":[],"protocols":[],"groups":[],"number_of_shared_runs":[],"ownership_history":[],"keywords":"","transfer_to_user":[],"sub_transfer":false,"is_transfer_pending":false,"number_of_bookmarks":"0","collections":[],"tags":[{"tag_id":"8","tag_name":"RNA-seq"},{"tag_id":"454","tag_name":"bioinformatics"},{"tag_id":"472","tag_name":"RNA"},{"tag_id":"643","tag_name":"long read sequencing"},{"tag_id":"767","tag_name":"Analysis"},{"tag_id":"893","tag_name":"cDNA"}],"archived":0,"sub_authors":[],"sub_protocols_number":0,"can_edit_shared":0,"shared_runs":[],"is_shared_run":0,"is_shared":1,"banner":null,"contact_badges":[{"badge_id":"2","badge_image":"\/img\/badges\/bronze.svg","badge_description":"Author!"},{"badge_id":"6","badge_image":"\/img\/badges\/socialbutterfly.svg","badge_description":"Social butterfly"}],"number_of_comments":0,"big_protocol_img":"https:\/\/s3.amazonaws.com\/pr-journal\/vi3jpt6.png","big_protocol_img_ofn":"stranded_mtdna.png","is_locked":0,"is_locked_by":false,"authors":"David Eccles","authors_list":[{"name":"David Eccles","affiliation":"Malaghan Institute of Medical Research (NZ)","username":"david-eccles","profile_image":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg"}],"user":{"profile_image":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg","username":"david-eccles","full_name":"David Eccles","created_by":"David Eccles"},"access":{"can_view":"1","can_remove":"0","can_add":"0","can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":"0","can_move":"1","can_transfer":"1","can_download":"1","is_locked":"0"},"is_contact_suspended":0,"guidelines":null,"status_id":"2","is_research":"1","status_info":"We are still developing and optimizing this protocol","steps":[{"id":"618696","is_changed":1,"original_id":"0","is_skipped":"0","is_checked":"0","guid":"109D6B96D7EF4F7ABADF6BE422713EFA","previous_guid":null,"previous_id":"0","last_modified":"1522817298","components":[{"component_id":"1083159","previous_id":0,"original_id":"0","guid":"A868885B169E47ADB249FFF54C121101","previous_guid":null,"component_type_id":"6","data_id":"0","data":"Read Correction","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Read Correction"},"is_project":0},{"component_id":"1083158","previous_id":"1083159","original_id":"0","guid":"974ABCD36BBE4A9D9D8095C01A11BAF8","previous_guid":"A868885B169E47ADB249FFF54C121101","component_type_id":"1","data_id":null,"data":"<p>I prefer starting off my data analysis with a read correction with Canu (ideally v1.7 now that it's out, because that attempts correction of <em>all<\/em> reads, but here I use canu v1.6). I use <code>minimap<\/code> as the mapper to speed this up. The <code>genomeSize<\/code> parameter should be approximately a tenth to a fortieth of the number of bases in your dataset to make sure that no sequences are excluded (bigger is better, as long as Canu doesn't freak out about memory consumption):<\/p>\n<pre>~\/install\/canu\/canu-1.6\/Linux-amd64\/bin\/canu overlapper=minimap \\\n  genomeSize=100M minReadLength=100 minOverlapLength=30 -correct \\\n  -p 4T1_BC06 -d 4T1_BC06 -nanopore-raw \\\n  workspace\/pass\/barcode06\/fastq_runid_*.fastq\n<\/pre>\n<p>This creates a file <code>4T1_BC06\/4T1_BC06.correctedReads.fasta.gz<\/code>.<\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>I prefer starting off my data analysis with a read correction with Canu (ideally v1.7 now that it's out, because that attempts correction of <em>all<\/em> reads, but here I use canu v1.6). I use <code>minimap<\/code> as the mapper to speed this up. The <code>genomeSize<\/code> parameter should be approximately a tenth to a fortieth of the number of bases in your dataset to make sure that no sequences are excluded (bigger is better, as long as Canu doesn't freak out about memory consumption):<\/p>\n<pre>~\/install\/canu\/canu-1.6\/Linux-amd64\/bin\/canu overlapper=minimap \\\n  genomeSize=100M minReadLength=100 minOverlapLength=30 -correct \\\n  -p 4T1_BC06 -d 4T1_BC06 -nanopore-raw \\\n  workspace\/pass\/barcode06\/fastq_runid_*.fastq\n<\/pre>\n<p>This creates a file <code>4T1_BC06\/4T1_BC06.correctedReads.fasta.gz<\/code>.<\/p>"},"is_project":0}],"available_protocols":["11237"]},{"id":"618697","is_changed":0,"original_id":"0","is_skipped":"0","is_checked":"0","guid":"AD9D229EA4FF46209BEC1BFAFC66F7B5","previous_guid":"109D6B96D7EF4F7ABADF6BE422713EFA","previous_id":"618696","last_modified":"1522817364","components":[{"component_id":"1083161","previous_id":0,"original_id":"0","guid":"ECDA4B573AF445B8AD1E0127661D81CD","previous_guid":null,"component_type_id":"6","data_id":"0","data":"Chimeric read filtering","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Chimeric read filtering"},"is_project":0},{"component_id":"1083160","previous_id":"1083161","original_id":"0","guid":"AA9418458F6644E8B771261C8E5D7FC0","previous_guid":"ECDA4B573AF445B8AD1E0127661D81CD","component_type_id":"1","data_id":null,"data":"<p>The next step I carry out is a basic read-level QC to exclude <a href=\"https:\/\/f1000research.com\/articles\/6-631\/v2\" target=\"_blank\" rel=\"noopener noreferrer\">chimeric reads<\/a>. <a href=\"https:\/\/github.com\/rrwick\/Porechop\" target=\"_blank\" rel=\"noopener noreferrer\">Porechop<\/a> can be used for this, although that removes adapters by default, which is not particularly useful in this case.<\/p>\n<p>I use LAST to search for adapter sequences within the corrected reads, pass it through my conversion script, and extract out duplicated mappings (i.e. where the same read\/adapter pair appears more than once in the mapping results):<\/p>\n<pre><code>lastal -P 10 ONT_barcodes_adapters.fa &lt;(zcat 4T1_BC06\/4T1_BC06.correctedReads.fasta.gz) | \\\n  ~\/scripts\/maf_bcsplit.pl | awk -F',' '{print $1,$2}' | sort | \\\n  uniq -d | awk '{print $1}' | uniq &gt; reads_with_duplicated_adapters.txt\n<\/code><\/pre>\n<p>I use this file to filter out chimeric reads from the corrected dataset using another <a href=\"https:\/\/github.com\/gringer\/bioinfscripts\/blob\/master\/fastx-fetch.pl\" target=\"_blank\" rel=\"noopener noreferrer\">fastq filtering script<\/a> I've created:<\/p>\n<pre><code>~\/scripts\/fastx-fetch.pl -v -i reads_with_duplicated_adapters.txt 4T1_BC06\/4T1_BC06.correctedReads.fasta.gz | \\\n  gzip &gt; 4T1_BC06.correctedReads.uniqueOnly.fasta.gz<\/code><\/pre>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>The next step I carry out is a basic read-level QC to exclude <a href=\"https:\/\/f1000research.com\/articles\/6-631\/v2\" target=\"_blank\" rel=\"noopener noreferrer\">chimeric reads<\/a>. <a href=\"https:\/\/github.com\/rrwick\/Porechop\" target=\"_blank\" rel=\"noopener noreferrer\">Porechop<\/a> can be used for this, although that removes adapters by default, which is not particularly useful in this case.<\/p>\n<p>I use LAST to search for adapter sequences within the corrected reads, pass it through my conversion script, and extract out duplicated mappings (i.e. where the same read\/adapter pair appears more than once in the mapping results):<\/p>\n<pre><code>lastal -P 10 ONT_barcodes_adapters.fa &lt;(zcat 4T1_BC06\/4T1_BC06.correctedReads.fasta.gz) | \\\n  ~\/scripts\/maf_bcsplit.pl | awk -F',' '{print $1,$2}' | sort | \\\n  uniq -d | awk '{print $1}' | uniq &gt; reads_with_duplicated_adapters.txt\n<\/code><\/pre>\n<p>I use this file to filter out chimeric reads from the corrected dataset using another <a href=\"https:\/\/github.com\/gringer\/bioinfscripts\/blob\/master\/fastx-fetch.pl\" target=\"_blank\" rel=\"noopener noreferrer\">fastq filtering script<\/a> I've created:<\/p>\n<pre><code>~\/scripts\/fastx-fetch.pl -v -i reads_with_duplicated_adapters.txt 4T1_BC06\/4T1_BC06.correctedReads.fasta.gz | \\\n  gzip &gt; 4T1_BC06.correctedReads.uniqueOnly.fasta.gz<\/code><\/pre>"},"is_project":0}],"available_protocols":[]},{"id":"618698","is_changed":1,"original_id":"0","is_skipped":"0","is_checked":"0","guid":"300B95DD3B874B36AAAB01AE7460A6A4","previous_guid":"AD9D229EA4FF46209BEC1BFAFC66F7B5","previous_id":"618697","last_modified":"1522817412","components":[{"component_id":"1083163","previous_id":0,"original_id":"0","guid":"67BA3D62CA2A4DF1A45465D18F4265E6","previous_guid":null,"component_type_id":"6","data_id":"0","data":"Adapter filtering","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Adapter filtering"},"is_project":0},{"component_id":"1083162","previous_id":"1083163","original_id":"0","guid":"3959A90DAB674D678414F2E44CCBF3DE","previous_guid":"67BA3D62CA2A4DF1A45465D18F4265E6","component_type_id":"1","data_id":null,"data":"<p>Along roughly similar lines to the chimeric read filtering, I then look for the strand switch and VNT adapters in the sequences. For a forward-orientated query, I expect the strand switch primer to be in the forward direction, and the VNP primer to be in the reverse direction:<\/p>\n<pre><code>lastal -P 10 ONT_barcodes_adapters.fa &lt;(zcat 4T1_BC06.correctedReads.uniqueOnly.fasta.gz) | \\\n  ~\/scripts\/maf_bcsplit.pl | grep -e 'ONT_SSP,+' -e 'ONT_VNP,-' | \\\n  awk -F',' '{print $1}' | sort | uniq &gt; fwdQry_seqs_BC06.txt\nlastal -P 10 barcodes_primerSeqs.fa &lt;(zcat 4T1_BC06.correctedReads.uniqueOnly.fasta.gz) | \\\n  ~\/scripts\/maf_bcsplit.pl | grep -e 'ONT_SSP,-' -e 'ONT_VNP,+' | \\\n  awk -F',' '{print $1}' | sort | uniq &gt; revQry_seqs_BC06.txt\n<\/code><\/pre>\n<p>And then more filtering to split the reads up into forward and reverse [genome-relative] subsets:<\/p>\n<pre><code>~\/scripts\/fastx-fetch.pl -i fwdQry_seqs_BC06.txt 4T1_BC06.correctedReads.uniqueOnly.fasta.gz | \\\n  gzip &gt; fwd_4T1_BC06.correctedReads.uniqueOnly.fasta.gz\n~\/scripts\/fastx-fetch.pl -i revQry_seqs_BC06.txt 4T1_BC06.correctedReads.uniqueOnly.fasta.gz | \\\n  gzip &gt; rev_4T1_BC06.correctedReads.uniqueOnly.fasta.gz\n<\/code><\/pre>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Along roughly similar lines to the chimeric read filtering, I then look for the strand switch and VNT adapters in the sequences. For a forward-orientated query, I expect the strand switch primer to be in the forward direction, and the VNP primer to be in the reverse direction:<\/p>\n<pre><code>lastal -P 10 ONT_barcodes_adapters.fa &lt;(zcat 4T1_BC06.correctedReads.uniqueOnly.fasta.gz) | \\\n  ~\/scripts\/maf_bcsplit.pl | grep -e 'ONT_SSP,+' -e 'ONT_VNP,-' | \\\n  awk -F',' '{print $1}' | sort | uniq &gt; fwdQry_seqs_BC06.txt\nlastal -P 10 barcodes_primerSeqs.fa &lt;(zcat 4T1_BC06.correctedReads.uniqueOnly.fasta.gz) | \\\n  ~\/scripts\/maf_bcsplit.pl | grep -e 'ONT_SSP,-' -e 'ONT_VNP,+' | \\\n  awk -F',' '{print $1}' | sort | uniq &gt; revQry_seqs_BC06.txt\n<\/code><\/pre>\n<p>And then more filtering to split the reads up into forward and reverse [genome-relative] subsets:<\/p>\n<pre><code>~\/scripts\/fastx-fetch.pl -i fwdQry_seqs_BC06.txt 4T1_BC06.correctedReads.uniqueOnly.fasta.gz | \\\n  gzip &gt; fwd_4T1_BC06.correctedReads.uniqueOnly.fasta.gz\n~\/scripts\/fastx-fetch.pl -i revQry_seqs_BC06.txt 4T1_BC06.correctedReads.uniqueOnly.fasta.gz | \\\n  gzip &gt; rev_4T1_BC06.correctedReads.uniqueOnly.fasta.gz\n<\/code><\/pre>"},"is_project":0}],"available_protocols":["11237"]},{"id":"618699","is_changed":1,"original_id":"0","is_skipped":"0","is_checked":"0","guid":"9521648B1BD34A00993C294347ABCF0D","previous_guid":"300B95DD3B874B36AAAB01AE7460A6A4","previous_id":"618698","last_modified":"1522817538","components":[{"component_id":"1083165","previous_id":0,"original_id":"0","guid":"53524117A9ED4ED2A1176F94518BC96E","previous_guid":null,"component_type_id":"6","data_id":"0","data":"Read Mapping","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Read Mapping"},"is_project":0},{"component_id":"1083164","previous_id":"1083165","original_id":"0","guid":"C1540C8E366848C0AF50EA8AB9AB1D46","previous_guid":"53524117A9ED4ED2A1176F94518BC96E","component_type_id":"1","data_id":null,"data":"<p>Now that the reads have been oriented, the mapping can be done:<\/p>\n<pre><code>~\/install\/minimap2\/minimap2 -t 10 -a mmus_ucsc_all_cdna.idx -x splice \\\n  fwd_4T1_BC06.correctedReads.uniqueOnly.fasta.gz \\\n  &gt; fwd_4T1_BC06.CU_vs_mmus.bam\n~\/install\/minimap2\/minimap2 -t 10 -a mmus_ucsc_all_cdna.idx -x splice \\\n  rev_4T1_BC06.correctedReads.uniqueOnly.fasta.gz \\\n  &gt; rev_4T1_BC06.CU_vs_mmus.bam\n<\/code><\/pre>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Now that the reads have been oriented, the mapping can be done:<\/p>\n<pre><code>~\/install\/minimap2\/minimap2 -t 10 -a mmus_ucsc_all_cdna.idx -x splice \\\n  fwd_4T1_BC06.correctedReads.uniqueOnly.fasta.gz \\\n  &gt; fwd_4T1_BC06.CU_vs_mmus.bam\n~\/install\/minimap2\/minimap2 -t 10 -a mmus_ucsc_all_cdna.idx -x splice \\\n  rev_4T1_BC06.correctedReads.uniqueOnly.fasta.gz \\\n  &gt; rev_4T1_BC06.CU_vs_mmus.bam\n<\/code><\/pre>"},"is_project":0}],"available_protocols":["11237"]},{"id":"618700","is_changed":0,"original_id":"0","is_skipped":"0","is_checked":"0","guid":"1E153D31A23D4AF0800722C75285503F","previous_guid":"9521648B1BD34A00993C294347ABCF0D","previous_id":"618699","last_modified":"1522817577","components":[{"component_id":"1083167","previous_id":0,"original_id":"0","guid":"4023CADF87BF4F2F94FD3D3406686F98","previous_guid":null,"component_type_id":"6","data_id":"0","data":"Splitting and recombining strands","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Splitting and recombining strands"},"is_project":0},{"component_id":"1083166","previous_id":"1083167","original_id":"0","guid":"AAC9265ADEB94E06B008081BA3A71513","previous_guid":"4023CADF87BF4F2F94FD3D3406686F98","component_type_id":"1","data_id":null,"data":"<p>The mapped files are then split based on their mapping direction using <code>samtools view<\/code> flag filtering to exclude or include reverse-mapped reads:<\/p>\n<pre><code>samtools view -F 0x10 -b fwd_4T1_BC06.CU_vs_mmus.bam &gt; fwd_fwd_4T1_BC06.CU_vs_mmus.bam\nsamtools view -f 0x10 -b fwd_4T1_BC06.CU_vs_mmus.bam &gt; rev_fwd_4T1_BC06.CU_vs_mmus.bam\nsamtools view -F 0x10 -b rev_4T1_BC06.CU_vs_mmus.bam &gt; fwd_rev_4T1_BC06.CU_vs_mmus.bam\nsamtools view -f 0x10 -b rev_4T1_BC06.CU_vs_mmus.bam &gt; rev_rev_4T1_BC06.CU_vs_mmus.bam\n<\/code><\/pre>\n<p>And finally the files are recombined to identify forward and reverse-encoded transcripts via <code>samtools merge<\/code>. I'm calling the \"pos\" strand the one that is encoded in the same direction as the genome, and the \"neg\" strand the reverse-complement direction:<\/p>\n<pre><code>samtools merge pos_4T1_BC06.CU_vs_mmus.bam \\\n  rev_fwd_4T1_BC06.CU_vs_mmus.bam fwd_rev_4T1_BC06.CU_vs_mmus.bam\nsamtools merge neg_4T1_BC06.CU_vs_mmus.bam \\\n  fwd_fwd_4T1_BC06.CU_vs_mmus.bam rev_rev_4T1_BC06.CU_vs_mmus.bam\n<\/code><\/pre>\n<p>Alternatively, it's possible to set the BAM flags for read 1 and read 2 for the reverse and forward-encoded adapters respectively, which allows everything to then be combined into a single BAM file (and treated in the same way as a strand-specific Illumina BAM file).<\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>The mapped files are then split based on their mapping direction using <code>samtools view<\/code> flag filtering to exclude or include reverse-mapped reads:<\/p>\n<pre><code>samtools view -F 0x10 -b fwd_4T1_BC06.CU_vs_mmus.bam &gt; fwd_fwd_4T1_BC06.CU_vs_mmus.bam\nsamtools view -f 0x10 -b fwd_4T1_BC06.CU_vs_mmus.bam &gt; rev_fwd_4T1_BC06.CU_vs_mmus.bam\nsamtools view -F 0x10 -b rev_4T1_BC06.CU_vs_mmus.bam &gt; fwd_rev_4T1_BC06.CU_vs_mmus.bam\nsamtools view -f 0x10 -b rev_4T1_BC06.CU_vs_mmus.bam &gt; rev_rev_4T1_BC06.CU_vs_mmus.bam\n<\/code><\/pre>\n<p>And finally the files are recombined to identify forward and reverse-encoded transcripts via <code>samtools merge<\/code>. I'm calling the \"pos\" strand the one that is encoded in the same direction as the genome, and the \"neg\" strand the reverse-complement direction:<\/p>\n<pre><code>samtools merge pos_4T1_BC06.CU_vs_mmus.bam \\\n  rev_fwd_4T1_BC06.CU_vs_mmus.bam fwd_rev_4T1_BC06.CU_vs_mmus.bam\nsamtools merge neg_4T1_BC06.CU_vs_mmus.bam \\\n  fwd_fwd_4T1_BC06.CU_vs_mmus.bam rev_rev_4T1_BC06.CU_vs_mmus.bam\n<\/code><\/pre>\n<p>Alternatively, it's possible to set the BAM flags for read 1 and read 2 for the reverse and forward-encoded adapters respectively, which allows everything to then be combined into a single BAM file (and treated in the same way as a strand-specific Illumina BAM file).<\/p>"},"is_project":0}],"available_protocols":[]},{"id":"618701","is_changed":1,"original_id":"0","is_skipped":"0","is_checked":"0","guid":"EA148BD0FF09417583674D3499C56ADE","previous_guid":"1E153D31A23D4AF0800722C75285503F","previous_id":"618700","last_modified":"1522817606","components":[{"component_id":"1083169","previous_id":0,"original_id":"0","guid":"8797885318C5412DA7112967657C3EFD","previous_guid":null,"component_type_id":"6","data_id":"0","data":"Sanity Check","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Sanity Check"},"is_project":0},{"component_id":"1083168","previous_id":"1083169","original_id":"0","guid":"584692CBD3D44AB5952CE718A875F8AF","previous_guid":"8797885318C5412DA7112967657C3EFD","component_type_id":"1","data_id":null,"data":"<p>If this has worked properly, then mapping human or mouse to the mitochondrial genome should show most expression appearing on the positive strand, with a small scattering of negative-strand expression, a bit like this:<\/p>\n<p><a href=\"https:\/\/i.stack.imgur.com\/YU56W.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https:\/\/i.stack.imgur.com\/YU56W.png\" alt=\"mtDNA transcript expression (nanopore)\" \/><\/a><\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>If this has worked properly, then mapping human or mouse to the mitochondrial genome should show most expression appearing on the positive strand, with a small scattering of negative-strand expression, a bit like this:<\/p>\n<p><a href=\"https:\/\/i.stack.imgur.com\/YU56W.png\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https:\/\/i.stack.imgur.com\/YU56W.png\" alt=\"mtDNA transcript expression (nanopore)\" \/><\/a><\/p>"},"is_project":0}],"available_protocols":["11237"]}]}