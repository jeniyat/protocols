{"uri":"elucidation-and-analyses-of-the-regulatory-network-saxeafn","version_id":"0","protocol_name":"Elucidation and Analyses of the Regulatory Networks of Upland and Lowland Ecotypes of Switchgrass in Response to Drought and Salt Stresses","protocol_name_html":"Elucidation and Analyses of the Regulatory Networks of Upland and Lowland Ecotypes of Switchgrass in Response to Drought and Salt Stresses","is_retracted":"0","is_prepublished":"0","can_edit":"0","parent_id":null,"api_version":"1","is_new_mode":"0","last_modified":"1537891562","type_id":"1","link":"https:\/\/doi.org\/10.1371\/journal.pone.0204426","fork_id":"","public_fork_note":null,"number_of_steps":"10","has_versions":"0","first_published_date":"1534214602","publish_date":"2018-09-25 16:06:02","documents":null,"have_protocol_in_step":"0","is_protocol_in_step":"0","vendor_name":"Contributed by users","vendor_link":"https:\/\/www.protocols.io","vendor_logo":"\/img\/vendors\/1.png","mod_mins":"-40","mod_secs":"1","description":null,"is_bookmarked":"1","can_reassign":"1","before_start":null,"has_guidelines":"0","materials":[],"materials_text":null,"warning":"<p>This command take hours to complete: \u2018screen\u2019 or \u2018nohup\u2019 command to avoid process being killed \u00a0if the connection to the server is lost.<\/p>","version_class":"14391","public":"1","is_owner":"1","is_original_owner":"1","created_on":"1533175217","protocol_affiliation":"College of Computer Science and Technology, Jilin University, Changchun, China,Noble Research Institute, LLC., Ardmore, OK, USA,North Automatic Control Technology Institute, Taiyuan, China,Department of Crop and Soil Environmental Science, Virginia Polytechnic Institute and State University, Blacksburg, Virginia, USA,Department of Horticulture, Virginia Polytechnic Institute and State University, Blacksburg, Virginia, USA","affiliation":"Jilin University","doi":"dx.doi.org\/10.17504\/protocols.io.saxeafn","doi_status":"2","changed_fork_steps":null,"profile_url":"ChunmanZuo-w2t23413w2w2","protocol_img":"https:\/\/www.protocols.io\/img\/default_protocol.png","profile_image":"\/img\/avatars\/018.png","full_name":"Chunman Zuo","created_by":"Chunman Zuo","private_link":"ED3384B80E439041B634522144082FB2","original_img":"1","username":"chunman-zuo","retraction_reason":null,"plos_id":"10.1371\/journal.pone.0204426","manuscript_citation":"Zuo C,  Tang Y,  Fu H,  Liu Y,  Zhang X,  Zhao B,  Xu Y (2018) Elucidation and analyses of the regulatory networks of upland and lowland ecotypes of switchgrass in response to drought and salt stresses. PLoS ONE  13(9): e0204426. doi: <a target=\"_blank\" href=\"https:\/\/dx.doi.org\/10.1371\/journal.pone.0204426\">10.1371\/journal.pone.0204426<\/a> ","journal_name":"PLOS One","journal_link":"https:\/\/doi.org\/10.1371\/journal.pone.0204426","is_donations_disabled":"0","is_donations_disabled_by_user":"9","item_record_id":336513,"fork_info":[],"compare_forks":[],"protocols":[],"groups":[],"number_of_shared_runs":[],"ownership_history":[],"keywords":"","transfer_to_user":[],"sub_transfer":false,"is_transfer_pending":false,"number_of_bookmarks":"1","collections":[],"tags":[],"archived":0,"sub_authors":[],"sub_protocols_number":0,"can_edit_shared":0,"shared_runs":[],"is_shared_run":0,"is_shared":1,"banner":null,"contact_badges":[{"badge_id":"2","badge_image":"\/img\/badges\/bronze.svg","badge_description":"Author"}],"number_of_comments":0,"is_locked":0,"is_locked_by":false,"authors":"Chunman Zuo,Yuhong Tang,Hao Fu,Yiming Liu,Xunzhong Zhang,Bingyu Zhao,Ying Xu","authors_list":[{"name":"Chunman Zuo","affiliation":"College of Computer Science and Technology, Jilin University, Changchun, China","username":null,"profile_image":null},{"name":"Yuhong Tang","affiliation":"Noble Research Institute, LLC., Ardmore, OK, USA","username":null,"profile_image":null},{"name":"Hao Fu","affiliation":"North Automatic Control Technology Institute, Taiyuan, China","username":null,"profile_image":null},{"name":"Yiming Liu","affiliation":"Department of Crop and Soil Environmental Science, Virginia Polytechnic Institute and State University, Blacksburg, Virginia, USA","username":null,"profile_image":null},{"name":"Xunzhong Zhang","affiliation":"Department of Crop and Soil Environmental Science, Virginia Polytechnic Institute and State University, Blacksburg, Virginia, USA","username":null,"profile_image":null},{"name":"Bingyu Zhao","affiliation":"Department of Horticulture, Virginia Polytechnic Institute and State University, Blacksburg, Virginia, USA","username":null,"profile_image":null},{"name":"Ying Xu","affiliation":"College of Computer Science and Technology, Jilin University, Changchun, China","username":null,"profile_image":null}],"user":{"profile_image":"\/img\/avatars\/018.png","username":"chunman-zuo","full_name":"Chunman Zuo","created_by":"Chunman Zuo"},"access":{"can_view":"1","can_remove":"0","can_add":"0","can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":"0","can_move":"1","can_transfer":"1","can_download":"1","is_locked":"0"},"is_contact_suspended":0,"guidelines":"","status_id":"1","is_research":null,"status_info":null,"steps":[{"id":"651607","is_changed":"0","original_id":"0","is_skipped":"0","is_checked":"0","guid":"B5B9138A669B4E9F979E069FAF45E9B6","previous_guid":null,"data":"{\"blocks\":[{\"key\":\"7vn1t\",\"text\":\"Download Illumina-based sequencing data from NCBI.\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"7oelg\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":0}],\"data\":[]},{\"key\":\"a1ilo\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":1}],\"data\":[]},{\"key\":\"am31h\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":2}],\"data\":[]},{\"key\":\"k0km\",\"text\":\" my $fastq_dump = $project_dir.\\\"\\\/sratoolkit\\\/2.8.2-1\\\".\\\"\\\/bin\\\/fastq-dump\\\"; foreach my $code (@SRR_codes) { system(\\\"$fastq_dump -I --split-files $code -o $out_dir\\\"); } For each sample of each project, the SRR code and corresponding information are mannually collected. Then, the script 'fastq-dump' was used to download each sample based on SRR code in the current directory, with fastq format. Note: $project_dir and $out_dir indicate the software installation directory and fastq file output directory, respectively. Unix - Perl script \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":534,\"key\":3}],\"data\":[]}],\"entityMap\":[{\"type\":\"dataset\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"148\",\"guid\":\"60023548EBF14C2896742ECB6020E35E\",\"name\":\"Illumina Hiseq 2500 RNA-seq data NCBI BioProject Accession: PRJN\",\"link\":\"https:\\\/\\\/www.ncbi.nlm.nih.gov\\\/bioproject\\\/?term=PRJNA323349\",\"can_edit\":true}},{\"type\":\"dataset\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"147\",\"guid\":\"3A1EAD741C444DF28BBDE5E3A8AAC9ED\",\"name\":\"Illumina Hiseq 2500 RNA-seq data NCBI BioProject Accession: PRJN\",\"link\":\"https:\\\/\\\/www.ncbi.nlm.nih.gov\\\/bioproject\\\/PRJNA323435\",\"can_edit\":true}},{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"362\",\"guid\":\"C93AFF8284914BA4A8E32F7323FB3390\",\"name\":\"NCBI SRA Toolkit\",\"version\":\"2.8.2-1\",\"developer\":\"\",\"repository\":\"\",\"link\":\"https:\\\/\\\/trace.ncbi.nlm.nih.gov\\\/Traces\\\/sra\\\/sra.cgi?view=toolkit_doc&f=std\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"command\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"4461\",\"guid\":\"31D3C30063A7407D80896F445BC25BA9\",\"name\":\"my $fastq_dump = $project_dir.\\\"\\\/sratoolkit\\\/2.8.2-1\\\".\\\"\\\/bin\\\/fastq-dump\\\"; \\nforeach my $code (@SRR_codes) \\n{ \\n  system(\\\"$fastq_dump -I --split-files $code -o $out_dir\\\");\\n}\",\"description\":\"For each sample of each project, the SRR code and corresponding information are mannually collected. Then, the script 'fastq-dump' was used to download each sample based on SRR code in the current directory, with fastq format. Note: $project_dir and $out_dir indicate the software installation directory and fastq file output directory, respectively.\",\"os_name\":\"Unix - Perl script\",\"os_version\":\"\",\"command\":\"For each sample of each project, the SRR code and corresponding information are mannually collected. Then, the script 'fastq-dump' was used to download each sample based on SRR code in the current directory, with fastq format. Note: $project_dir and $out_dir indicate the software installation directory and fastq file output directory, respectively.\",\"can_edit\":true}}]}","section":"","case_id":"0","section_color":null,"protocol_id":"14391","previous_id":"0","last_modified":"1534141802"},{"id":"651608","is_changed":"0","original_id":"0","is_skipped":"0","is_checked":"0","guid":"8AF1C7ED5CF84328BD6E7E9D8D35308E","previous_guid":"B5B9138A669B4E9F979E069FAF45E9B6","data":"{\"blocks\":[{\"key\":\"5vser\",\"text\":\"Adapter-trimming, quality-trimming, filtering and contaminant-filtering, were applied to each fastq file\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"fj37v\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":0}],\"data\":[]},{\"key\":\"a7cb4\",\"text\":\" my $bbduk = $project_dir.\\\"\\\/bbmap\\\/35.82\\\".\\\"\\\/bbduk.sh\\\"; my $contam_seq = $project_dir.\\\"\\\/bbmap\\\/35.82\\\".\\\"\\\/resources\\\/phix174_ill.ref.fa.gz\\\"; my $adapter_seq = $project_dir.\\\"\\\/bbmap\\\/35.82\\\".\\\"\\\/resources\\\/adapters.fa\\\"; foreach my $code (@SRR_codes) { my $fq_file_1 = $out_dir.$code.\\\"_1.fastq\\\"; my $fq_file_2 = $out_dir.$code.\\\"_2.fastq\\\"; my $fq_file_trim_1 = $out_dir.$code.\\\"_1_trim.fastq\\\"; my $fq_file_trim_2 = $out_dir.$code.\\\"_2_trim.fastq\\\"; my $fq_file_final_1 = $out_dir.$code.\\\"_1_final.fastq\\\"; my $fq_file_final_2 = $out_dir.$code.\\\"_2_final.fastq\\\"; my $fq_file_m_1 = $out_dir.$code.\\\"_1_match.fastq\\\"; my $fq_file_m_2 = $out_dir.$code.\\\"_2_match.fastq\\\"; my $fq_match_status = $out_dir.$code.\\\"_status.txt\\\"; # adapter-trimming, quality-trimming, filtering system(\\\"$bbduk -Xmx5g in=$fq_file_1 in2=$fq_file_2 out=$fq_file_trim_1 out2=$fq_file_trim_2 ref=$adapter_seq threads=10 qtrim=rl trimq=10 ktrim=r k=23 mink=11 hdist=1 tpe tbo\\\"); # contaminant-filtering system(\\\"$bbduk -Xmx5g in=$fq_file_trim_1 in2=$fq_file_trim_2 out=$fq_file_final_1 out2=$fq_file_final_2 outm=$fq_file_m_1 outm2=$fq_file_m_2 ref=$contam_seq threads=10 k=31 hdist=1 stats=$fq_match_status\\\"); } Regarding each SRR sample, bbduk tools were used to simultaneously process two fastq files. Unix - Perl script \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1265,\"key\":1}],\"data\":[]}],\"entityMap\":[{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"363\",\"guid\":\"1C3189CDA335463786832C500994F858\",\"name\":\"BBDuk tools\",\"version\":\"35.82\",\"developer\":\"\",\"repository\":\"\",\"link\":\"https:\\\/\\\/sourceforge.net\\\/projects\\\/bbmap\\\/\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"command\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"4462\",\"guid\":\"A9C751D3678C45C4BFC4BDFCCE4E7F24\",\"name\":\"my $bbduk = $project_dir.\\\"\\\/bbmap\\\/35.82\\\".\\\"\\\/bbduk.sh\\\";\\nmy $contam_seq =  $project_dir.\\\"\\\/bbmap\\\/35.82\\\".\\\"\\\/resources\\\/phix174_ill.ref.fa.gz\\\";\\nmy $adapter_seq = $project_dir.\\\"\\\/bbmap\\\/35.82\\\".\\\"\\\/resources\\\/adapters.fa\\\";\\n\\nforeach my $code (@SRR_codes)\\n{\\n  my $fq_file_1 = $out_dir.$code.\\\"_1.fastq\\\";\\n  my $fq_file_2 = $out_dir.$code.\\\"_2.fastq\\\";\\n  \\n  my $fq_file_trim_1 = $out_dir.$code.\\\"_1_trim.fastq\\\";\\n  my $fq_file_trim_2 = $out_dir.$code.\\\"_2_trim.fastq\\\";\\n\\n  my $fq_file_final_1 = $out_dir.$code.\\\"_1_final.fastq\\\";\\n  my $fq_file_final_2 = $out_dir.$code.\\\"_2_final.fastq\\\";\\n\\n  my $fq_file_m_1 = $out_dir.$code.\\\"_1_match.fastq\\\";\\n  my $fq_file_m_2 = $out_dir.$code.\\\"_2_match.fastq\\\";\\n  \\n  my $fq_match_status = $out_dir.$code.\\\"_status.txt\\\";\\n\\n  # adapter-trimming, quality-trimming, filtering \\n  system(\\\"$bbduk -Xmx5g in=$fq_file_1 in2=$fq_file_2 out=$fq_file_trim_1 out2=$fq_file_trim_2 ref=$adapter_seq threads=10 qtrim=rl trimq=10 ktrim=r k=23 mink=11 hdist=1 tpe tbo\\\");\\n  # contaminant-filtering\\n  system(\\\"$bbduk -Xmx5g in=$fq_file_trim_1 in2=$fq_file_trim_2 out=$fq_file_final_1 out2=$fq_file_final_2 outm=$fq_file_m_1 outm2=$fq_file_m_2 ref=$contam_seq threads=10 k=31 hdist=1 stats=$fq_match_status\\\");\\n}\",\"description\":\"Regarding each SRR sample, bbduk tools were used to simultaneously process two fastq files. \",\"os_name\":\"Unix - Perl script\",\"os_version\":\"\",\"command\":\"Regarding each SRR sample, bbduk tools were used to simultaneously process two fastq files. \",\"can_edit\":true}}]}","section":"","case_id":"0","section_color":null,"protocol_id":"14391","previous_id":"651607","last_modified":"1534140133"},{"id":"651609","is_changed":"0","original_id":"0","is_skipped":"0","is_checked":"0","guid":"390B582E2B44419D9A7C412CBF89A88C","previous_guid":"8AF1C7ED5CF84328BD6E7E9D8D35308E","data":"{\"blocks\":[{\"key\":\"u0rg\",\"text\":\"Mapping the high-quality reads to the genome\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"ejod5\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":0}],\"data\":[]},{\"key\":\"97bb8\",\"text\":\" my $Hisat2_mapp = $project_dir.\\\"\\\/hisat2\\\/2.1.0\\\/hisat2\\\"; my $hisat2_build = $project_dir.\\\"\\\/hisat2\\\/2.1.0\\\".\\\"\\\/bin\\\/hisat2-build\\\"; # go into genome directory, and generate one directory to save genome index files system(\\\"cd $genome_dir\\\"); system(\\\"mkdir index\\\"); # build index files for genome of switchgrass (indicated by variable '$genome_fa') my $genome_index = $genome_dir.\\\"\\\/index\\\/switchgrass\\\"; system(\\\"$hisat2_build -f $genome_fa $genome_index\\\"); # for each sample, hisat2 was used to map the raw reads into genome foreach my $code (@SRR_codes) { my $fq_1 = $out_dir.$code.\\\"_1_final.fastq\\\"; my $fq_2 = $out_dir.$code.\\\"_2_final.fastq\\\"; my $file1 = $out_dir.$code.\\\"_mapping.sam\\\"; #mapping system(\\\"$Hisat2_mapp -x $genome_index -q -t -k 1 -p 10 -1 $fq_1 -2 $fq_2 -s $file1\\\"); } Firstly, the script 'hisat2-build' was used to build HISAT2 index for the genome fasta file. Then, for each SRR sample, based on the index files, the script \\\"hisat2\\\" was used to map the raw reads to the genome of switchgrass. Unix - Perl script \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1018,\"key\":1}],\"data\":[]}],\"entityMap\":[{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"365\",\"guid\":\"9A02119AAE39497BBB03CE5DF4DB0744\",\"name\":\"Hisat2\",\"version\":\"2.1.0\",\"developer\":\"\",\"repository\":\"\",\"link\":\"http:\\\/\\\/ccb.jhu.edu\\\/software\\\/hisat2\\\/manual.shtml\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"command\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"4463\",\"guid\":\"56F6997EB6024FA790B5EE19DA70DDF1\",\"name\":\"my $Hisat2_mapp = $project_dir.\\\"\\\/hisat2\\\/2.1.0\\\/hisat2\\\";\\nmy $hisat2_build = $project_dir.\\\"\\\/hisat2\\\/2.1.0\\\".\\\"\\\/bin\\\/hisat2-build\\\";\\n\\n# go into genome directory, and generate one directory to save genome index files \\nsystem(\\\"cd $genome_dir\\\");\\nsystem(\\\"mkdir index\\\");\\n\\n# build index files for genome of switchgrass (indicated by variable '$genome_fa')\\nmy $genome_index = $genome_dir.\\\"\\\/index\\\/switchgrass\\\";\\nsystem(\\\"$hisat2_build -f $genome_fa $genome_index\\\");\\n\\n# for each sample, hisat2 was used to map the raw reads into genome\\nforeach my $code (@SRR_codes)\\n{\\n  my $fq_1 = $out_dir.$code.\\\"_1_final.fastq\\\";\\n  my $fq_2 = $out_dir.$code.\\\"_2_final.fastq\\\";\\n  \\n  my $file1 = $out_dir.$code.\\\"_mapping.sam\\\";\\n  \\n  #mapping\\n  system(\\\"$Hisat2_mapp -x $genome_index -q -t -k 1 -p 10 -1 $fq_1  -2 $fq_2 -s $file1\\\");\\n}\",\"description\":\"Firstly, the script 'hisat2-build' was used to build HISAT2 index for the genome fasta file. Then, for each SRR sample, based on the index files, the script \",\"os_name\":\"Unix - Perl script\",\"os_version\":\"\",\"command\":\"Firstly, the script 'hisat2-build' was used to build HISAT2 index for the genome fasta file. Then, for each SRR sample, based on the index files, the script \\\"hisat2\\\" was used to map the raw reads to the genome of switchgrass.\",\"can_edit\":true}}]}","section":"","case_id":"0","section_color":null,"protocol_id":"14391","previous_id":"651608","last_modified":"1533261268"},{"id":"651621","is_changed":"0","original_id":"0","is_skipped":"0","is_checked":"0","guid":"B9BC483A43CD4CD2A391BB0EA87B3ADE","previous_guid":"390B582E2B44419D9A7C412CBF89A88C","data":"{\"blocks\":[{\"key\":\"37uti\",\"text\":\"Summary gene-level read counts by featureCounts\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"1hoj5\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":0}],\"data\":[]},{\"key\":\"7dme6\",\"text\":\" my $subread = $project_dir.\\\"subread-1.5.0-Linux-x86_64\\\/bin\\\/featureCounts\\\"; # collect all the mapping files for each project opendir($AA, $out_dir); my @list_ = readdir($AA); closedir($AA); ### the variable $line was used to save all the mapping files directory my $line = \\\"\\\"; foreach my $file (@list_) { if( $file =~ \\\/_mapping.sam\\\/) { if($line eq \\\"\\\") { $line = $out_dir.$file; }else{ $line = $line.\\\" \\\".$out_dir.$file; } } } # summary gene-level read counts my $out_file = $out_dir.\\\"Raw_reads_count.txt\\\"; # ref_file is the SAF formatted gene annotation file including GeneID, Chr, Start, End and Strand system(\\\"$subread -T 10 -p -g gene_id -a $ref_file -F SAF -o $out_file $line\\\"); Based on the gene annotation and raw reads mapping files, the software featureCounts was used to summary gene-level read counts. Unix - Perl script \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":830,\"key\":1}],\"data\":[]}],\"entityMap\":[{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"367\",\"guid\":\"EEADAC3F939E4E70A37C7122333D0977\",\"name\":\"Subread\",\"version\":\"1.5.0\",\"developer\":\"\",\"repository\":\"\",\"link\":\"http:\\\/\\\/omictools.com\\\/subread-tool\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"command\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"4464\",\"guid\":\"A65EA67134BE4E258A3DAE730E5E10CC\",\"name\":\"my $subread = $project_dir.\\\"subread-1.5.0-Linux-x86_64\\\/bin\\\/featureCounts\\\";\\n\\n# collect all the mapping files for each project\\nopendir($AA, $out_dir);\\nmy @list_ = readdir($AA);\\nclosedir($AA);\\n\\n### the variable $line was used to save all the mapping files directory\\nmy $line = \\\"\\\";\\nforeach my $file (@list_)\\n{\\n   if( $file =~ \\\/_mapping.sam\\\/)\\n   {\\n      if($line eq \\\"\\\")\\n      {\\n         $line = $out_dir.$file;\\n      }else{\\n         $line = $line.\\\" \\\".$out_dir.$file; \\n      }\\n   }\\n}\\n\\n# summary gene-level read counts\\nmy $out_file = $out_dir.\\\"Raw_reads_count.txt\\\";\\n\\n# ref_file is the SAF formatted gene annotation file including GeneID, Chr, Start, End and Strand\\nsystem(\\\"$subread -T 10 -p -g gene_id -a $ref_file -F SAF -o $out_file $line\\\");\",\"description\":\"Based on the gene annotation and raw reads mapping files, the software featureCounts was used to summary gene-level read counts.\",\"os_name\":\"Unix - Perl script\",\"os_version\":\"\",\"command\":\"Based on the gene annotation and raw reads mapping files, the software featureCounts was used to summary gene-level read counts.\",\"can_edit\":true}}]}","section":"","case_id":"0","section_color":null,"protocol_id":"14391","previous_id":"651609","last_modified":"1533261276"},{"id":"651622","is_changed":"0","original_id":"0","is_skipped":"0","is_checked":"0","guid":"7D08CFEE69F4463FB4C4D752827387FE","previous_guid":"B9BC483A43CD4CD2A391BB0EA87B3ADE","data":"{\"blocks\":[{\"key\":\"6tdl\",\"text\":\"Normalization and differentially expression analysis\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"66pmp\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":0}],\"data\":[]},{\"key\":\"athse\",\"text\":\"2) >= ceiling(0.9*length(sample_group)) d_new = DGEList(counts= reads_count[keep,]) d_new$genes$Length <- gene_length[keep] d_new$samples$group = sample_group d_new1 <- calcNormFactors(d_new) ##CPM normalization cpm_reads_new = cpm(d_new1,log = F) ### differentially expressed analysis condition1 = c(\\\"treated1\\\",\\\"treated2\\\") condtion2 = c(\\\"untreated1\\\",\\\"untreated2\\\") for(i in 1:length(condtion1)) { treat_loc1 = NULL untreat_loc1 = NULL for(j in 1:dim(reads_count)[2]) { if(regexpr(condtion1[i],colnames(reads_count)[j])[1]>-1) { treat_loc1 = c(treat_loc1,j) } if(regexpr(condtion2[i],colnames(reads_count)[j])[1]>-1) { untreat_loc1 = c(untreat_loc1,j) } } temp_data = reads_count[keep,c(treat_loc1, untreat_loc1)] colnames(temp_data) = c(paste((rep(\\\"A\\\",length(treat_loc1))),seq(1,length(treat_loc1)),sep=\\\"\\\"), paste((rep(\\\"B\\\",length(untreat_loc1))),seq(1,length(untreat_loc1)),sep=\\\"\\\")) row.names(temp_data) = row.names(reads_count[keep,]) d_s = DGEList(counts=temp_data,group=c(rep(\\\"A\\\",length(treat_loc1)),rep(\\\"B\\\",length(untreat_loc1)))) d_s <- calcNormFactors(d_s) design = model.matrix(~0+group, data=d_s$samples) colnames(design) = levels(d_s$samples$group) y <- estimateDisp(d_s, design,robust = T) fit <- glmQLFit(y, design, robust=TRUE) con = makeContrasts(contrasts= \\\"A-B\\\", levels=c(\\\"A\\\",\\\"B\\\")) annov = glmQLFTest(fit,contrast =con ) annova_com = topTags(annov,n = dim(temp_data)[1]) # up-regulated genes for treat samples relative to untreated samples, with p-value <=0.05 and fold-change >=2 up_genes = row.names(annova_com$table)[which((as.numeric(annova_com$table[[4]])<=0.05)&(as.numeric(annova_com$table[[1]])>=log2(2)))] # down-regulated genes for treated samples relative to untreated samples, with p-value <=0.05 and fold-change >=2 down_genes = row.names(annova_com$table)[which((as.numeric(annova_com$table[[4]])<=0.05)&(as.numeric(annova_com$table[[1]])<=log2(0.5)))] }\\\" description=\\\"Here, one R package edgeR was used to do normalization and differentially expressed analysis. \\\" os_version=\\\"\\\" os_name=\\\"Windows-R script\\\" guid=\\\"0EF1F739F7054A03A7DFAE60C65A924C\\\" > # load edgeR package library(\\\"edgeR\\\") # normalization steps: filter out genes with lower read counts and normalization by TMM methods # variable 'reads_count' indicates the gene expression matrix, with row for genes and column for samples. d <- DGEList(counts=reads_count) #variable 'gene_length' indicates gene length, with the same order for rows of reads_count d$genes$Length = gene_length #variable 'sample_group' indicates the class (ecotype+time) for each stress type d$samples$group = sample_group cpm_reads = cpm(d,log = F) # filter out genes with low reads count keep <- rowSums(cpm_reads >2) >= ceiling(0.9*length(sample_group)) d_new = DGEList(counts= reads_count[keep,]) d_new$genes$Length <- gene_length[keep] d_new$samples$group = sample_group d_new1 <- calcNormFactors(d_new) ##CPM normalization cpm_reads_new = cpm(d_new1,log = F) ### differentially expressed analysis condition1 = c(\\\"treated1\\\",\\\"treated2\\\") condtion2 = c(\\\"untreated1\\\",\\\"untreated2\\\") for(i in 1:length(condtion1)) { treat_loc1 = NULL untreat_loc1 = NULL for(j in 1:dim(reads_count)[2]) { if(regexpr(condtion1[i],colnames(reads_count)[j])[1]>-1) { treat_loc1 = c(treat_loc1,j) } if(regexpr(condtion2[i],colnames(reads_count)[j])[1]>-1) { untreat_loc1 = c(untreat_loc1,j) } } temp_data = reads_count[keep,c(treat_loc1, untreat_loc1)] colnames(temp_data) = c(paste((rep(\\\"A\\\",length(treat_loc1))),seq(1,length(treat_loc1)),sep=\\\"\\\"), paste((rep(\\\"B\\\",length(untreat_loc1))),seq(1,length(untreat_loc1)),sep=\\\"\\\")) row.names(temp_data) = row.names(reads_count[keep,]) d_s = DGEList(counts=temp_data,group=c(rep(\\\"A\\\",length(treat_loc1)),rep(\\\"B\\\",length(untreat_loc1)))) d_s <- calcNormFactors(d_s) design = model.matrix(~0+group, data=d_s$samples) colnames(design) = levels(d_s$samples$group) y <- estimateDisp(d_s, design,robust = T) fit <- glmQLFit(y, design, robust=TRUE) con = makeContrasts(contrasts= \\\"A-B\\\", levels=c(\\\"A\\\",\\\"B\\\")) annov = glmQLFTest(fit,contrast =con ) annova_com = topTags(annov,n = dim(temp_data)[1]) # up-regulated genes for treat samples relative to untreated samples, with p-value <=0.05 and fold-change >=2 up_genes = row.names(annova_com$table)[which((as.numeric(annova_com$table[[4]])<=0.05)&(as.numeric(annova_com$table[[1]])>=log2(2)))] # down-regulated genes for treated samples relative to untreated samples, with p-value <=0.05 and fold-change >=2 down_genes = row.names(annova_com$table)[which((as.numeric(annova_com$table[[4]])<=0.05)&(as.numeric(annova_com$table[[1]])<=log2(0.5)))] } Here, one R package edgeR was used to do normalization and differentially expressed analysis. Windows-R script \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":4671,\"key\":1}],\"data\":[]}],\"entityMap\":[{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"368\",\"guid\":\"BEAAB7605D4C4E738BB4F380191C2643\",\"name\":\"edgeR\",\"version\":\"3.20.9\",\"developer\":\"\",\"repository\":\"\",\"link\":\"http:\\\/\\\/omictools.com\\\/edger-tool\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"command\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"4465\",\"guid\":\"\",\"name\":\"# load edgeR package \\nlibrary(\\\"edgeR\\\")\\n\\n# normalization steps: filter out genes with lower read counts and normalization by TMM methods\\n\\n# variable 'reads_count' indicates the gene expression matrix, with row for genes and column for samples.\\nd <- DGEList(counts=reads_count) \\n\\n#variable 'gene_length' indicates gene length, with the same order for rows of reads_count\\nd$genes$Length = gene_length\\n\\n#variable 'sample_group' indicates the class (ecotype+time) for each stress type\\nd$samples$group = sample_group\\n\\ncpm_reads = cpm(d,log = F)\\n\\n# filter out genes with low reads count\\nkeep <- rowSums(cpm_reads >2) >= ceiling(0.9*length(sample_group))\\n\\nd_new = DGEList(counts= reads_count[keep,])\\nd_new$genes$Length <- gene_length[keep]\\nd_new$samples$group = sample_group\\n\\nd_new1 <- calcNormFactors(d_new)\\n\\n##CPM normalization\\ncpm_reads_new = cpm(d_new1,log = F)\\n\\n### differentially expressed analysis\\n\\ncondition1 = c(\\\"treated1\\\",\\\"treated2\\\")\\ncondtion2 = c(\\\"untreated1\\\",\\\"untreated2\\\")\\n\\nfor(i in 1:length(condtion1))\\n{\\n   treat_loc1 = NULL\\n   untreat_loc1 = NULL\\n  \\n  for(j in 1:dim(reads_count)[2])\\n  {\\n     if(regexpr(condtion1[i],colnames(reads_count)[j])[1]>-1)\\n     {\\n       treat_loc1 = c(treat_loc1,j)   \\n     }\\n\\n    if(regexpr(condtion2[i],colnames(reads_count)[j])[1]>-1)\\n     {\\n       untreat_loc1 = c(untreat_loc1,j)   \\n     }\\n  }\\n\\n  temp_data = reads_count[keep,c(treat_loc1, untreat_loc1)]\\n  colnames(temp_data) =     c(paste((rep(\\\"A\\\",length(treat_loc1))),seq(1,length(treat_loc1)),sep=\\\"\\\"),\\n                            paste((rep(\\\"B\\\",length(untreat_loc1))),seq(1,length(untreat_loc1)),sep=\\\"\\\"))\\n  row.names(temp_data) = row.names(reads_count[keep,])\\n  d_s = DGEList(counts=temp_data,group=c(rep(\\\"A\\\",length(treat_loc1)),rep(\\\"B\\\",length(untreat_loc1))))\\n  d_s <- calcNormFactors(d_s)\\n    \\n  design = model.matrix(~0+group, data=d_s$samples)\\n  colnames(design) = levels(d_s$samples$group)\\n    \\n  y <- estimateDisp(d_s, design,robust = T)\\n  fit <- glmQLFit(y, design, robust=TRUE)\\n    \\n  con = makeContrasts(contrasts= \\\"A-B\\\", levels=c(\\\"A\\\",\\\"B\\\"))\\n  annov = glmQLFTest(fit,contrast =con )\\n  annova_com = topTags(annov,n = dim(temp_data)[1])\\n\\n  # up-regulated genes for treat samples relative to untreated samples, with p-value <=0.05 and fold-change >=2\\n  up_genes = row.names(annova_com$table)[which((as.numeric(annova_com$table[[4]])<=0.05)&(as.numeric(annova_com$table[[1]])>=log2(2)))]\\n\\n  # down-regulated genes for treated samples relative to untreated samples, with p-value <=0.05 and fold-change >=2\\n  down_genes = row.names(annova_com$table)[which((as.numeric(annova_com$table[[4]])<=0.05)&(as.numeric(annova_com$table[[1]])<=log2(0.5)))]\\n\\n}\",\"description\":\"\",\"os_name\":\"Windows-R script\",\"os_version\":\"\",\"command\":\"Here, one R package edgeR was used to do normalization and differentially expressed analysis. \",\"can_edit\":true}}]}","section":"","case_id":"0","section_color":null,"protocol_id":"14391","previous_id":"651621","last_modified":"1533198270"},{"id":"651623","is_changed":"0","original_id":"0","is_skipped":"0","is_checked":"0","guid":"596D505D92A04D5FB8D7305494D6F01F","previous_guid":"7D08CFEE69F4463FB4C4D752827387FE","data":"{\"blocks\":[{\"key\":\"fdges\",\"text\":\"Construction of gene regulatory network\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"1vhb2\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":0}],\"data\":[]},{\"key\":\"1om2e\",\"text\":\" # Construction of gene regulatory network # Construction of initial gene regulatory network based on co-expression information measured using the Pearson correlations. # R method \\u2018cor.test()\\u2019 was used to calculate Pearson correlation coefficient (PCC) # variable \\u2018TFs_diff\\u2019 indicates differentially regulated TF TF_locs = match(TFs_diff,row.names(cpm_reads_new)) # variable \\u2018TGs_diff\\u2019 indicates differentially regulated TGs TG_locs = match(TGs_diff,row.names(cpm_reads_new)) TF_TG_matrix = matrix(0,length(TFs_diff),length(TGs_diff)) for(i in 1:length(TFs_diff)) { for(j in 1:length(TGs_diff)) { cor_value = cor.test(cpm_reads_new[TF_locs[i],], cpm_reads_new[TG_locs[j],],method = \\u201cpearson\\u201d) if(cor_value$p.value<0.01) { TF_TG_matrix[i,j] = cor_value$estimate } } } row.names(TF_TG_matrix) = TFs_diff colnames(TF_TG_matrix) = TGs_diff # Any pairs of TF-TG with PCC <=0.7 were filtered out TF_TG_matrix[which(abs(TF_TG_matrix)<=0.7)] = 0 #preparation data for the input of NCA algorithm # generate gene expression data gene_sample_X = NULL unique_group = unique(sample_group) for(i in 1:length(unique_group)) { gene_sample_X = cbind(gene_sample_X,apply(cpm_reads_new[,which(sample_group== unique_group[i])],1,mean)) } #generate binary regulatory matrix gene_regula_new = TF_TG_matrix gene_regula_new[which(gene_regula_new != 0)] = 1 gene_regulatory_input = t(gene_regula_new) row.names(gene_regulatory_input) = colnames(TF_TG_matrix) colnames(gene_regulatory_input) = row.nanes(TF_TG_matrix) For each stress type, a pair of transcriptional factors (TF) and genes with Pearson correlation coefficients (PCC) > 0.70 was predicted to have an regulatory relationship. Windows - R script \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1683,\"key\":1}],\"data\":[]},{\"key\":\"e0ueg\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":2}],\"data\":[]}],\"entityMap\":[{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"369\",\"guid\":\"2DB98D81BED84BAC981E63A1E4FF6C35\",\"name\":\"NCA algorithm\",\"version\":\"2.3\",\"developer\":\"\",\"repository\":\"\",\"link\":\"http:\\\/\\\/www.seas.ucla.edu\\\/liao_lab\\\/\\\/downloads.html\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"command\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"4466\",\"guid\":\"7A170FB8C2F7444595301F794CBD34E6\",\"name\":\"# Construction of gene regulatory network\\n# Construction of initial gene regulatory network based on co-expression information  measured using the Pearson correlations.\\n# R method \\u2018cor.test()\\u2019 was used to calculate Pearson correlation coefficient (PCC)\\n\\n# variable \\u2018TFs_diff\\u2019 indicates differentially regulated TF \\nTF_locs = match(TFs_diff,row.names(cpm_reads_new))\\n\\n# variable \\u2018TGs_diff\\u2019 indicates differentially regulated TGs \\nTG_locs = match(TGs_diff,row.names(cpm_reads_new))\\n\\nTF_TG_matrix = matrix(0,length(TFs_diff),length(TGs_diff))\\n\\nfor(i in 1:length(TFs_diff))\\n{\\n   for(j in 1:length(TGs_diff))\\n  {\\n     cor_value = cor.test(cpm_reads_new[TF_locs[i],], cpm_reads_new[TG_locs[j],],method = \\u201cpearson\\u201d)\\n     if(cor_value$p.value<0.01)\\n     {\\n       TF_TG_matrix[i,j] = cor_value$estimate\\n     }     \\n  }\\n}\\n\\nrow.names(TF_TG_matrix) = TFs_diff\\ncolnames(TF_TG_matrix) = TGs_diff\\n\\n# Any pairs of TF-TG with PCC <=0.7 were filtered out\\nTF_TG_matrix[which(abs(TF_TG_matrix)<=0.7)] = 0\\n\\n#preparation data for the input of NCA algorithm \\n\\n# generate gene expression data\\ngene_sample_X = NULL\\n\\nunique_group = unique(sample_group)\\nfor(i in 1:length(unique_group))\\n{\\n  gene_sample_X = cbind(gene_sample_X,apply(cpm_reads_new[,which(sample_group== unique_group[i])],1,mean))\\n}\\n\\n#generate binary regulatory matrix\\ngene_regula_new = TF_TG_matrix\\ngene_regula_new[which(gene_regula_new != 0)] = 1\\n\\ngene_regulatory_input = t(gene_regula_new)\\nrow.names(gene_regulatory_input) = colnames(TF_TG_matrix)\\ncolnames(gene_regulatory_input) = row.nanes(TF_TG_matrix)\",\"description\":\"For each stress type, a pair of transcriptional factors (TF) and genes with Pearson correlation coefficients (PCC) > 0.70 was predicted to have an regulatory relationship.\",\"os_name\":\"Windows - R script\",\"os_version\":\"\",\"command\":\"For each stress type, a pair of transcriptional factors (TF) and genes with Pearson correlation coefficients (PCC) > 0.70 was predicted to have an regulatory relationship.\",\"can_edit\":true}},{\"type\":\"command\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"4467\",\"guid\":\"D4A325829B87451998669FDD439EBD93\",\"name\":\"# run script 'RunNCAToolbox.m' and then follow each step in NCA algorithm\",\"description\":\"Input gene expression matrix and gene regulatory relationship into NCA algorithm, we can get transcription factor activity and control strength.\",\"os_name\":\"Windows - Matlab\",\"os_version\":\"\",\"command\":\"Input gene expression matrix and gene regulatory relationship into NCA algorithm, we can get transcription factor activity and control strength.\",\"can_edit\":true}}]}","section":"","case_id":"0","section_color":null,"protocol_id":"14391","previous_id":"651622","last_modified":"1533282632"},{"id":"651624","is_changed":"0","original_id":"0","is_skipped":"0","is_checked":"0","guid":"45CF6BB27778473ABFEB580B908C4B45","previous_guid":"596D505D92A04D5FB8D7305494D6F01F","data":"{\"blocks\":[{\"key\":\"dat5b\",\"text\":\"Validation of predicted TGs for each TF\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"eq57u\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":0}],\"data\":[]},{\"key\":\"ea38i\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":1}],\"data\":[]},{\"key\":\"ej2ap\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":2}],\"data\":[]},{\"key\":\"1m1k5\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":3}],\"data\":[]},{\"key\":\"1r8c1\",\"text\":\"max_tas) { max_tas = length(mac_is) } } matrix_Genes_gos = matrix(NA,length(unique_gens),max_tas) all_in_go = NULL for(i in 1:length(unique_gens)) { mac_is = which(unique_gens[i]==go_genss) matrix_Genes_gos[i,1:length(mac_is)] = GO_idss[mac_is] } row.names(matrix_Genes_gos) = paste(unique_gens,\\\".v4.1\\\",sep=\\\"\\\") # calculate the Go function similarity for any two BP GO term library(GOSemSim) library(\\\"org.Hs.eg.db\\\", lib.loc=\\\"~\\\/R\\\/x86_64-redhat-linux-gnu-library\\\/3.4\\\") GO_datass = list(NULL,NULL,NULL) wang_simia = list(NULL,NULL,NULL) ### all BP Go term similarity hsGO <- godata('org.Hs.eg.db', ont=\\\"BP\\\") go1_BP = unique(GO_idss) go2_BP = unique(GO_idss) wang_simia_BP = mgoSim(go1_BP, go2_BP, semData=hsGO, measure=\\\"Wang\\\", combine=NULL) # The function for the calculation of go term similarity of any two genes (G1 and G2) gene_similarity <- function(G1,G2,similarty) { max_simia1 = rep(0,length(G1)) max_simia2 = rep(0,length(G2)) max_simia1_1 = rep(1,length(G1)) max_simia2_2 = rep(1,length(G2)) for(i in 1:length(G1)) { G1_sima_max = similarty[which(row.names(similarty)==G1[i]),match(G2,colnames(similarty))] max_simia1[i] = max(G1_sima_max) } for(i in 1:length(G2)) { G2_sima_max = similarty[which(row.names(similarty)==G2[i]),match(G1,colnames(similarty))] max_simia2[i] = max(G2_sima_max) } return((sum(c(max_simia1,max_simia2))\\\/(sum(c(max_simia1_1,max_simia2_2))))) } # parallelly calculate the GO function similarity of TGs for each TF. Here, NCA_list is the variable of list, and each list is the gene regulatory matrix, with row for TF and column for TGs library(foreach) library(doParallel) cl <- makeCluster(10) registerDoParallel(cl, cores=10) drought_tar_sima <- foreach(jjj=1:dim(NCA_list[[1]])[1], .combine='c') %dopar% { temp_tae = colnames(NCA_list[[1]])[which(NCA_list[[1]][jjj,]!=0)] temp_gene_sima = NULL for(kk in 1:(length(temp_tae))) { for(kkk in (kk+1):length(temp_tae)) { int1 = which(row.names(matrix_Genes_gos)==temp_tae[kk]) int2 = which(row.names(matrix_Genes_gos)==temp_tae[kkk]) temp_go1 = matrix_Genes_gos[int1,][which(!is.na(matrix_Genes_gos[int1,]))] temp_go2 = matrix_Genes_gos[int2,][which(!is.na(matrix_Genes_gos[int2,]))] if((length(temp_go1)>0)&&(length(temp_go2)>0)) { temp_gene_sima = c(temp_gene_sima,gene_similarity(temp_go1,temp_go2,wang_simia_total)) }else{ temp_gene_sima = c(temp_gene_sima,NA) } } } return(temp_gene_sima) } stopCluster(cl) ### generate one random network, with the number of edge is the same with the number of total connections as pairs of TGs for each TF library(\\\"igraph\\\") set.seed(30) g1_r_f <- erdos.renyi.game(25971, length(which(!is.na(drought_tar_sima))), type = \\\"gnm\\\") g1_egde_r_f = get.edgelist(g1_r_f) droght_gens = setdiff(row.names(matrix_Genes_gos),unique(c(row.names(NCA_list[[1]]),colnames(NCA_list[[1]])))) g1_edge_names_r_f = cbind(droght_gens[g1_egde_r_f[,1]],droght_gens[g1_egde_r_f[,2]]) ### parallelly calculate the GO function similarity of two genes connected by one edge. library(foreach) library(doParallel) cl <- makeCluster(10) registerDoParallel(cl, cores=10) res2_p_r_drougt <- foreach(jjj=1:dim(g1_edge_names_r_f)[1], .combine='c') %dopar% { int1 = which(row.names(matrix_Genes_gos)==g1_edge_names_r_f[,1][jjj]) int2 = which(row.names(matrix_Genes_gos)==g1_edge_names_r_f[,2][jjj]) temp_go1 = matrix_Genes_gos[int1,][which(!is.na(matrix_Genes_gos[int1,]))] temp_go2 = matrix_Genes_gos[int2,][which(!is.na(matrix_Genes_gos[int2,]))] if((length(temp_go1)>0)&&(length(temp_go2)>0)) { return(gene_similarity(temp_go1,temp_go2,wang_simia_total)) # genes_sima_random = c(genes_sima_random,gene_similarity(temp_go1,temp_go2,wang_simia)) }else{ return(0) } } stopCluster(cl) \\\" description=\\\"To quantify functional relevance of the predicted TGs for each TF, we have calculated GO semantic similarity scores of the GO terms between each pair of the co-regulated TGs, using the GOSemSim package\\\" os_version=\\\"\\\" os_name=\\\"Unix - R script\\\" guid=\\\"B733E0AFFCD049F09031EB785EC5E590\\\" > # To quantify functional relevance of the predicted TGs for each TF, we have calculated GO semantic similarity scores of the GO terms between each pair of the co-regulated TGs, using the GOSemSim package #here, we considered only the GO biological processes # Here, we just mannually constructed the relationship between genes and go terms, focused on biological process (BP) # step1, for all BP, construct this relationship. go_annos = readLines(paste(go_paths,\\\"GO_annotation\\\",sep=\\\"\\\")) GO_idss = NULL go_genss = NULL for(i in 2:length(go_annos)) { temps = unlist(strsplit(go_annos[i],\\\"\\\\t\\\")) if(temps[4]==\\\"P\\\") { GO_idss = c(GO_idss,temps[2]) go_genss = c(go_genss,temps[1]) } } unique_gens = unique(go_genss) max_tas = 0 for(i in 1:length(unique_gens)) { mac_is = which(unique_gens[i]==go_genss) if(length(mac_is)>max_tas) { max_tas = length(mac_is) } } matrix_Genes_gos = matrix(NA,length(unique_gens),max_tas) all_in_go = NULL for(i in 1:length(unique_gens)) { mac_is = which(unique_gens[i]==go_genss) matrix_Genes_gos[i,1:length(mac_is)] = GO_idss[mac_is] } row.names(matrix_Genes_gos) = paste(unique_gens,\\\".v4.1\\\",sep=\\\"\\\") # calculate the Go function similarity for any two BP GO term library(GOSemSim) library(\\\"org.Hs.eg.db\\\", lib.loc=\\\"~\\\/R\\\/x86_64-redhat-linux-gnu-library\\\/3.4\\\") GO_datass = list(NULL,NULL,NULL) wang_simia = list(NULL,NULL,NULL) ### all BP Go term similarity hsGO <- godata('org.Hs.eg.db', ont=\\\"BP\\\") go1_BP = unique(GO_idss) go2_BP = unique(GO_idss) wang_simia_BP = mgoSim(go1_BP, go2_BP, semData=hsGO, measure=\\\"Wang\\\", combine=NULL) # The function for the calculation of go term similarity of any two genes (G1 and G2) gene_similarity <- function(G1,G2,similarty) { max_simia1 = rep(0,length(G1)) max_simia2 = rep(0,length(G2)) max_simia1_1 = rep(1,length(G1)) max_simia2_2 = rep(1,length(G2)) for(i in 1:length(G1)) { G1_sima_max = similarty[which(row.names(similarty)==G1[i]),match(G2,colnames(similarty))] max_simia1[i] = max(G1_sima_max) } for(i in 1:length(G2)) { G2_sima_max = similarty[which(row.names(similarty)==G2[i]),match(G1,colnames(similarty))] max_simia2[i] = max(G2_sima_max) } return((sum(c(max_simia1,max_simia2))\\\/(sum(c(max_simia1_1,max_simia2_2))))) } # parallelly calculate the GO function similarity of TGs for each TF. Here, NCA_list is the variable of list, and each list is the gene regulatory matrix, with row for TF and column for TGs library(foreach) library(doParallel) cl <- makeCluster(10) registerDoParallel(cl, cores=10) drought_tar_sima <- foreach(jjj=1:dim(NCA_list[[1]])[1], .combine='c') %dopar% { temp_tae = colnames(NCA_list[[1]])[which(NCA_list[[1]][jjj,]!=0)] temp_gene_sima = NULL for(kk in 1:(length(temp_tae))) { for(kkk in (kk+1):length(temp_tae)) { int1 = which(row.names(matrix_Genes_gos)==temp_tae[kk]) int2 = which(row.names(matrix_Genes_gos)==temp_tae[kkk]) temp_go1 = matrix_Genes_gos[int1,][which(!is.na(matrix_Genes_gos[int1,]))] temp_go2 = matrix_Genes_gos[int2,][which(!is.na(matrix_Genes_gos[int2,]))] if((length(temp_go1)>0)&&(length(temp_go2)>0)) { temp_gene_sima = c(temp_gene_sima,gene_similarity(temp_go1,temp_go2,wang_simia_total)) }else{ temp_gene_sima = c(temp_gene_sima,NA) } } } return(temp_gene_sima) } stopCluster(cl) ### generate one random network, with the number of edge is the same with the number of total connections as pairs of TGs for each TF library(\\\"igraph\\\") set.seed(30) g1_r_f <- erdos.renyi.game(25971, length(which(!is.na(drought_tar_sima))), type = \\\"gnm\\\") g1_egde_r_f = get.edgelist(g1_r_f) droght_gens = setdiff(row.names(matrix_Genes_gos),unique(c(row.names(NCA_list[[1]]),colnames(NCA_list[[1]])))) g1_edge_names_r_f = cbind(droght_gens[g1_egde_r_f[,1]],droght_gens[g1_egde_r_f[,2]]) ### parallelly calculate the GO function similarity of two genes connected by one edge. library(foreach) library(doParallel) cl <- makeCluster(10) registerDoParallel(cl, cores=10) res2_p_r_drougt <- foreach(jjj=1:dim(g1_edge_names_r_f)[1], .combine='c') %dopar% { int1 = which(row.names(matrix_Genes_gos)==g1_edge_names_r_f[,1][jjj]) int2 = which(row.names(matrix_Genes_gos)==g1_edge_names_r_f[,2][jjj]) temp_go1 = matrix_Genes_gos[int1,][which(!is.na(matrix_Genes_gos[int1,]))] temp_go2 = matrix_Genes_gos[int2,][which(!is.na(matrix_Genes_gos[int2,]))] if((length(temp_go1)>0)&&(length(temp_go2)>0)) { return(gene_similarity(temp_go1,temp_go2,wang_simia_total)) # genes_sima_random = c(genes_sima_random,gene_similarity(temp_go1,temp_go2,wang_simia)) }else{ return(0) } } stopCluster(cl) To quantify functional relevance of the predicted TGs for each TF, we have calculated GO semantic similarity scores of the GO terms between each pair of the co-regulated TGs, using the GOSemSim package Unix - R script \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":8660,\"key\":4}],\"data\":[]},{\"key\":\"bt1nn\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":5}],\"data\":[]}],\"entityMap\":[{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"371\",\"guid\":\"31E3CEA721394D9EA83C840D1F7267E0\",\"name\":\"GOSemSim\",\"version\":\"2.0.4\",\"developer\":\"\",\"repository\":\"\",\"link\":\"http:\\\/\\\/www.bioconductor.org\\\/packages\\\/release\\\/bioc\\\/html\\\/GOSemSim.html\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"372\",\"guid\":\"E9EE2208B8294673B4FBCCD90D8C29B5\",\"name\":\"org.Hs.eg.db\",\"version\":\"3.6.0\",\"developer\":\"\",\"repository\":\"\",\"link\":\"http:\\\/\\\/www.bioconductor.org\\\/packages\\\/release\\\/data\\\/annotation\\\/html\\\/org.Hs.eg.db.html\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"373\",\"guid\":\"4D16A06770C74447B2C9AF2698ECFB01\",\"name\":\"foreach\",\"version\":\"1.4.4\",\"developer\":\"\",\"repository\":\"\",\"link\":\"https:\\\/\\\/cran.r-project.org\\\/web\\\/packages\\\/foreach\\\/foreach.pdf\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"374\",\"guid\":\"159CCD82B26C42F5886054DE6C29D068\",\"name\":\"doParallel\",\"version\":\"1.0.11\",\"developer\":\"\",\"repository\":\"\",\"link\":\"https:\\\/\\\/cran.r-project.org\\\/web\\\/packages\\\/doParallel\\\/doParallel.pdf\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"command\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"4469\",\"guid\":\"\",\"name\":\"# To quantify functional relevance of the predicted TGs for each TF, we have calculated GO semantic similarity scores of the GO terms between each pair of the co-regulated TGs, using the GOSemSim package\\n\\n#here, we considered only the GO biological processes\\n\\n# Here, we just mannually constructed the relationship between genes and go terms, focused on biological process (BP)\\n\\n# step1, for all BP, construct this relationship. \\n\\ngo_annos = readLines(paste(go_paths,\\\"GO_annotation\\\",sep=\\\"\\\"))\\nGO_idss = NULL\\ngo_genss = NULL\\n\\nfor(i in 2:length(go_annos))\\n{\\n  temps = unlist(strsplit(go_annos[i],\\\"\\\\t\\\"))\\n  if(temps[4]==\\\"P\\\")\\n  {\\n    GO_idss = c(GO_idss,temps[2])\\n    go_genss = c(go_genss,temps[1])\\n  }\\n  \\n}\\n\\nunique_gens = unique(go_genss)\\nmax_tas = 0\\nfor(i in 1:length(unique_gens))\\n{\\n  mac_is = which(unique_gens[i]==go_genss)\\n  if(length(mac_is)>max_tas)\\n  {\\n    max_tas = length(mac_is)\\n  }\\n  \\n}\\n\\nmatrix_Genes_gos = matrix(NA,length(unique_gens),max_tas)\\nall_in_go = NULL\\n\\nfor(i in 1:length(unique_gens))\\n{\\n  mac_is = which(unique_gens[i]==go_genss)\\n  matrix_Genes_gos[i,1:length(mac_is)] = GO_idss[mac_is]\\n  \\n}\\n\\nrow.names(matrix_Genes_gos) = paste(unique_gens,\\\".v4.1\\\",sep=\\\"\\\")\\n\\n# calculate the Go function similarity for any two BP GO term\\n\\nlibrary(GOSemSim)\\nlibrary(\\\"org.Hs.eg.db\\\", lib.loc=\\\"~\\\/R\\\/x86_64-redhat-linux-gnu-library\\\/3.4\\\")\\n\\nGO_datass = list(NULL,NULL,NULL)\\nwang_simia = list(NULL,NULL,NULL)\\n\\n### all BP Go term similarity\\nhsGO <- godata('org.Hs.eg.db', ont=\\\"BP\\\")\\n\\ngo1_BP = unique(GO_idss)\\ngo2_BP = unique(GO_idss)\\n\\nwang_simia_BP = mgoSim(go1_BP, go2_BP, semData=hsGO, measure=\\\"Wang\\\", combine=NULL)\\n\\n# The function for the calculation of go term similarity of any two genes (G1 and G2)\\n\\ngene_similarity <- function(G1,G2,similarty)\\n{\\n  max_simia1 = rep(0,length(G1))\\n  max_simia2 = rep(0,length(G2))\\n  \\n  max_simia1_1 = rep(1,length(G1))\\n  max_simia2_2 = rep(1,length(G2))\\n  \\n  for(i in 1:length(G1))\\n  {\\n    G1_sima_max = similarty[which(row.names(similarty)==G1[i]),match(G2,colnames(similarty))]\\n    max_simia1[i] = max(G1_sima_max)\\n  }\\n  \\n  for(i in 1:length(G2))\\n  {\\n    G2_sima_max = similarty[which(row.names(similarty)==G2[i]),match(G1,colnames(similarty))]\\n    max_simia2[i] = max(G2_sima_max)\\n  }\\n  \\n  return((sum(c(max_simia1,max_simia2))\\\/(sum(c(max_simia1_1,max_simia2_2)))))\\n}\\n\\n# parallelly calculate the GO function similarity of TGs for each TF. Here, NCA_list is the variable of list, and each list is the gene regulatory matrix, with row for TF and column for TGs\\n\\nlibrary(foreach)\\nlibrary(doParallel)\\n\\ncl <- makeCluster(10)\\nregisterDoParallel(cl, cores=10)\\n\\ndrought_tar_sima <- foreach(jjj=1:dim(NCA_list[[1]])[1], .combine='c') %dopar%\\n{  \\n  temp_tae = colnames(NCA_list[[1]])[which(NCA_list[[1]][jjj,]!=0)]\\n  temp_gene_sima = NULL\\n  \\n  for(kk in 1:(length(temp_tae)))\\n  {\\n    for(kkk in (kk+1):length(temp_tae))\\n    {\\n      int1 = which(row.names(matrix_Genes_gos)==temp_tae[kk])\\n      int2 = which(row.names(matrix_Genes_gos)==temp_tae[kkk])\\n      \\n      temp_go1 = matrix_Genes_gos[int1,][which(!is.na(matrix_Genes_gos[int1,]))]\\n      temp_go2 = matrix_Genes_gos[int2,][which(!is.na(matrix_Genes_gos[int2,]))]\\n      \\n      if((length(temp_go1)>0)&&(length(temp_go2)>0))\\n      {\\n        temp_gene_sima = c(temp_gene_sima,gene_similarity(temp_go1,temp_go2,wang_simia_total))\\n      }else{\\n        temp_gene_sima = c(temp_gene_sima,NA)\\n      }\\n      \\n    }\\n  }\\n  \\n  return(temp_gene_sima)\\n  \\n}\\n\\nstopCluster(cl)\\n\\n### generate one random network, with the number of edge is the same with the number of total connections as pairs of TGs for each TF\\n\\nlibrary(\\\"igraph\\\")\\nset.seed(30)\\ng1_r_f <- erdos.renyi.game(25971, length(which(!is.na(drought_tar_sima))), type = \\\"gnm\\\")\\n\\n\\ng1_egde_r_f = get.edgelist(g1_r_f)\\n\\ndroght_gens = setdiff(row.names(matrix_Genes_gos),unique(c(row.names(NCA_list[[1]]),colnames(NCA_list[[1]]))))\\ng1_edge_names_r_f = cbind(droght_gens[g1_egde_r_f[,1]],droght_gens[g1_egde_r_f[,2]])\\n\\n\\n### parallelly calculate the GO function similarity of two genes connected by one edge.\\n\\nlibrary(foreach)\\nlibrary(doParallel)\\n\\ncl <- makeCluster(10)\\nregisterDoParallel(cl, cores=10)\\n\\nres2_p_r_drougt <- foreach(jjj=1:dim(g1_edge_names_r_f)[1], .combine='c') %dopar%\\n{  \\n  \\n  int1 = which(row.names(matrix_Genes_gos)==g1_edge_names_r_f[,1][jjj])\\n  int2 = which(row.names(matrix_Genes_gos)==g1_edge_names_r_f[,2][jjj])\\n  \\n  temp_go1 = matrix_Genes_gos[int1,][which(!is.na(matrix_Genes_gos[int1,]))]\\n  temp_go2 = matrix_Genes_gos[int2,][which(!is.na(matrix_Genes_gos[int2,]))]\\n  \\n  if((length(temp_go1)>0)&&(length(temp_go2)>0))\\n  {\\n    return(gene_similarity(temp_go1,temp_go2,wang_simia_total))\\n    # genes_sima_random = c(genes_sima_random,gene_similarity(temp_go1,temp_go2,wang_simia))\\n  }else{\\n   return(0)\\n  }\\n}\\n\\nstopCluster(cl)\\n\",\"description\":\"\",\"os_name\":\"Unix - R script\",\"os_version\":\"\",\"command\":\"To quantify functional relevance of the predicted TGs for each TF, we have calculated GO semantic similarity scores of the GO terms between each pair of the co-regulated TGs, using the GOSemSim package\",\"can_edit\":true}},{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"379\",\"guid\":\"15BDAB54460C4401871C5E7004D1FC98\",\"name\":\"igraph\",\"version\":\"1.2.1\",\"developer\":\"\",\"repository\":\"\",\"link\":\"https:\\\/\\\/cran.r-project.org\\\/web\\\/packages\\\/igraph\\\/index.html\",\"os_name\":\"\",\"os_version\":\"\"}}]}","section":"","case_id":"0","section_color":null,"protocol_id":"14391","previous_id":"651623","last_modified":"1534142804"},{"id":"651847","is_changed":"0","original_id":"0","is_skipped":"0","is_checked":"0","guid":"C02CFA73C3AC467E89DF86F0AE7680A8","previous_guid":"45CF6BB27778473ABFEB580B908C4B45","data":"{\"blocks\":[{\"key\":\"7eir2\",\"text\":\"Validation of predicted TF-TG interactions\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"amk6j\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":0}],\"data\":[]},{\"key\":\"1qki1\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":1}],\"data\":[]}],\"entityMap\":[{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"376\",\"guid\":\"B50C9CB4E0CD4D669A928E5920CA9349\",\"name\":\"inparanoid\",\"version\":\"4.1\",\"developer\":\"\",\"repository\":\"\",\"link\":\"http:\\\/\\\/inparanoid.sbc.su.se\\\/cgi-bin\\\/index.cgi\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"command\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"4470\",\"guid\":\"7F8205F0EAA44873A413BD10DB60D364\",\"name\":\"# run 'perl inparanoid.pl X.fa Y.fa'\",\"description\":\"The script 'inparanoid.pl' in the software 'inparanoid' was used to generate the orthologous groups between two species. We consider a predicted TF-TG interaction as validated if it has orthologous pairs of TF-TG interactions in the mannually collected predicetd relationships of other species.\",\"os_name\":\"Unix - Perl script\",\"os_version\":\"\",\"command\":\"The script 'inparanoid.pl' in the software 'inparanoid' was used to generate the orthologous groups between two species. We consider a predicted TF-TG interaction as validated if it has orthologous pairs of TF-TG interactions in the mannually collected predicetd relationships of other species.\",\"can_edit\":true}}]}","section":"","case_id":"0","section_color":null,"protocol_id":"14391","previous_id":"651624","last_modified":"1534142936"},{"id":"651848","is_changed":"0","original_id":"0","is_skipped":"0","is_checked":"0","guid":"4B69859409774B38B8D34B971CB34E14","previous_guid":"C02CFA73C3AC467E89DF86F0AE7680A8","data":"{\"blocks\":[{\"key\":\"2q70n\",\"text\":\"Dynamic regulatory maps\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"b2171\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":0}],\"data\":[]},{\"key\":\"2p9b4\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":1}],\"data\":[]}],\"entityMap\":[{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"377\",\"guid\":\"5D5F249BE62C439EA23DB0B761D38779\",\"name\":\"DREM\",\"version\":\"2.0.3\",\"developer\":\"\",\"repository\":\"\",\"link\":\"http:\\\/\\\/www.sb.cs.cmu.edu\\\/drem\\\/\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"command\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"4471\",\"guid\":\"B27C50BF3C09456F8578A12C842027D9\",\"name\":\"# run software 'drem.jar' file in the directory of DREM software installation directory.\",\"description\":\"The method of DREM takes as input fold-change (treated relative to untreated) time series data and transcription factor-gene interaction data, and produces as output a dynamic regulatory map.\",\"os_name\":\"Windows - Jave\",\"os_version\":\"\",\"command\":\"The method of DREM takes as input fold-change (treated relative to untreated) time series data and transcription factor-gene interaction data, and produces as output a dynamic regulatory map.\",\"can_edit\":true}}]}","section":"","case_id":"0","section_color":null,"protocol_id":"14391","previous_id":"651847","last_modified":"1533276725"},{"id":"651849","is_changed":"0","original_id":"0","is_skipped":"0","is_checked":"0","guid":"A036E4C69D02425E91DA6A45652FA36F","previous_guid":"4B69859409774B38B8D34B971CB34E14","data":"{\"blocks\":[{\"key\":\"75ecg\",\"text\":\"GO enrichment analysis\",\"type\":\"unstyled\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[],\"data\":[]},{\"key\":\"ajrsu\",\"text\":\" \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":1,\"key\":0}],\"data\":[]},{\"key\":\"5ea0k\",\"text\":\" ### one defined function for GO enrichment analysis. here, \\u2018inter_genes\\u2019 for your interested genes cal_enrichments <- function(GO_path,save_path_,inter_genes,codition){ # note: here, inter_genes and all_used_gene need to have same naming rule. geneID2GO <- readMappings(file = paste(GO_path,\\\"gene2_go\\\",sep=\\\"\\\")) all_used_gene = names(geneID2GO) geneList = factor(as.integer(all_used_gene %in% inter_genes)) names(geneList) = all_used_gene # run test for Biological process GOdata_BP <- new(\\\"topGOdata\\\", ontology = \\\"BP\\\", allGenes = geneList, annot = annFUN.gene2GO, gene2GO = geneID2GO) BP_fisher = runTest(GOdata_BP,algorithm = \\\"classic\\\", statistic = \\\"fisher\\\") allRes_BP <- GenTable(GOdata_BP, classic = BP_fisher, orderBy = \\\"weight\\\", ranksOf = \\\"classic\\\", topNodes = length(which(BP_fisher@score< 0.01))) write.table(allRes_BP,file = paste(save_path_,codition,\\\"_BP.txt\\\",sep=\\\"\\\"),sep=\\\"\\\\t\\\",quote = F,row.names = F ) # run test for Molecular function GOdata_MF <- new(\\\"topGOdata\\\", ontology = \\\"MF\\\", allGenes = geneList, annot = annFUN.gene2GO, gene2GO = geneID2GO) MF_fisher = runTest(GOdata_MF,algorithm = \\\"classic\\\", statistic = \\\"fisher\\\") allRes_MF <- GenTable(GOdata_MF, classic = MF_fisher, orderBy = \\\"weight\\\", ranksOf = \\\"classic\\\", topNodes = length(which(MF_fisher@score< 0.01))) write.table(allRes_MF,file = paste(save_path_,codition,\\\"_MF.txt\\\",sep=\\\"\\\"),sep=\\\"\\\\t\\\",quote = F,row.names = F ) # run test for Cellular component GOdata_CC <- new(\\\"topGOdata\\\", ontology = \\\"CC\\\", allGenes = geneList, annot = annFUN.gene2GO, gene2GO = geneID2GO) CC_fisher = runTest(GOdata_CC,algorithm = \\\"classic\\\", statistic = \\\"fisher\\\") allRes_CC <- GenTable(GOdata_CC, classic = CC_fisher, orderBy = \\\"weight\\\", ranksOf = \\\"classic\\\", topNodes = length(which(CC_fisher@score< 0.01))) write.table(allRes_CC,file = paste(save_path_,codition,\\\"_CC.txt\\\",sep=\\\"\\\"),sep=\\\"\\\\t\\\",quote = F,row.names = F ) } GO term enrichment was conducted over a given gene set using the topGO R package, where all annotated genes in switchgrass was used as the background. A GO function is considered enriched if the p-value < 0.01. Windows - R script \",\"type\":\"atomic\",\"depth\":0,\"inlineStyleRanges\":[],\"entityRanges\":[{\"offset\":0,\"length\":2093,\"key\":1}],\"data\":[]}],\"entityMap\":[{\"type\":\"software\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"378\",\"guid\":\"D2931E7FCDDF46EFB9517F2B61963BA3\",\"name\":\"topGO\",\"version\":\"2.30.1\",\"developer\":\"\",\"repository\":\"\",\"link\":\"http:\\\/\\\/www.bioconductor.org\\\/packages\\\/release\\\/bioc\\\/html\\\/topGO.html\",\"os_name\":\"\",\"os_version\":\"\"}},{\"type\":\"command\",\"mutability\":\"MUTABLE\",\"data\":{\"id\":\"4472\",\"guid\":\"A3116DC2485E48D9A0D9DE859A8BB498\",\"name\":\"### one defined function for GO enrichment analysis. here, \\u2018inter_genes\\u2019 for your interested genes\\n\\ncal_enrichments <- function(GO_path,save_path_,inter_genes,codition){\\n\\n  # note: here, inter_genes and all_used_gene need to have same naming rule.\\n\\n  geneID2GO <- readMappings(file = paste(GO_path,\\\"gene2_go\\\",sep=\\\"\\\"))\\n  all_used_gene = names(geneID2GO)\\n  \\n  geneList = factor(as.integer(all_used_gene %in% inter_genes))\\n  names(geneList) = all_used_gene\\n  \\n  # run test for Biological process\\n\\n  GOdata_BP <- new(\\\"topGOdata\\\", ontology = \\\"BP\\\", allGenes = geneList,\\n                   annot = annFUN.gene2GO, gene2GO = geneID2GO)\\n  BP_fisher = runTest(GOdata_BP,algorithm = \\\"classic\\\", statistic = \\\"fisher\\\")\\n  allRes_BP <- GenTable(GOdata_BP, classic = BP_fisher,\\n                        orderBy = \\\"weight\\\", ranksOf = \\\"classic\\\", topNodes = length(which(BP_fisher@score< 0.01)))\\n  write.table(allRes_BP,file = paste(save_path_,codition,\\\"_BP.txt\\\",sep=\\\"\\\"),sep=\\\"\\\\t\\\",quote = F,row.names = F )\\n  \\n  # run test for Molecular function\\n  \\n  GOdata_MF <- new(\\\"topGOdata\\\", ontology = \\\"MF\\\", allGenes = geneList,\\n                   annot = annFUN.gene2GO, gene2GO = geneID2GO)\\n  MF_fisher = runTest(GOdata_MF,algorithm = \\\"classic\\\", statistic = \\\"fisher\\\")\\n  allRes_MF <- GenTable(GOdata_MF, classic = MF_fisher,\\n                        orderBy = \\\"weight\\\", ranksOf = \\\"classic\\\", topNodes = length(which(MF_fisher@score< 0.01)))\\n  write.table(allRes_MF,file = paste(save_path_,codition,\\\"_MF.txt\\\",sep=\\\"\\\"),sep=\\\"\\\\t\\\",quote = F,row.names = F )\\n   \\n  # run test for Cellular component\\n   \\n  GOdata_CC <- new(\\\"topGOdata\\\", ontology = \\\"CC\\\", allGenes = geneList,\\n                   annot = annFUN.gene2GO, gene2GO = geneID2GO)\\n  CC_fisher = runTest(GOdata_CC,algorithm = \\\"classic\\\", statistic = \\\"fisher\\\")\\n  allRes_CC <- GenTable(GOdata_CC, classic = CC_fisher,\\n                        orderBy = \\\"weight\\\", ranksOf = \\\"classic\\\", topNodes = length(which(CC_fisher@score< 0.01)))\\n  write.table(allRes_CC,file = paste(save_path_,codition,\\\"_CC.txt\\\",sep=\\\"\\\"),sep=\\\"\\\\t\\\",quote = F,row.names = F )\\n   \\n}\\n\",\"description\":\"GO term enrichment was conducted over a given gene set using the topGO R package, where all annotated genes in switchgrass was used as the background. A GO function is considered enriched if the p-value < 0.01.\",\"os_name\":\"Windows - R script\",\"os_version\":\"\",\"command\":\"GO term enrichment was conducted over a given gene set using the topGO R package, where all annotated genes in switchgrass was used as the background. A GO function is considered enriched if the p-value < 0.01.\",\"can_edit\":true}}]}","section":"","case_id":"0","section_color":null,"protocol_id":"14391","previous_id":"651848","last_modified":"1534141600"}]}