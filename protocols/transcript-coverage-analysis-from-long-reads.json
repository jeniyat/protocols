{"uri":"transcript-coverage-analysis-from-long-reads-re2d3ge","version_id":"1","protocol_name":"Transcript Coverage Analysis from Long Reads","protocol_name_html":"Transcript Coverage Analysis from Long Reads","is_prepublished":"0","can_edit":"0","parent_id":"13491","api_version":"1","is_new_mode":"0","last_modified":"1530518937","type_id":"1","link":null,"fork_id":"","public_fork_note":"","number_of_steps":"9","has_versions":"1","first_published_date":"1530518937","publish_date":"2018-07-02 08:08:57","documents":null,"have_protocol_in_step":"0","is_protocol_in_step":"0","vendor_name":"Contributed by users","vendor_link":"https:\/\/www.protocols.io","vendor_logo":"\/img\/vendors\/1.png","mod_mins":"-38","mod_secs":"47","description":"<p>This protocol is for comparing two different samples at the transcript level, using long reads that are mapped to transcripts.<\/p>\n<p>\u00a0<\/p>\n<p><strong>Input(s)<\/strong>: stranded fastq files (see steps 1-8 of <a href=\"https:\/\/dx.doi.org\/10.17504\/protocols.io.n8ddhs6\" target=\"_blank\" rel=\"noopener noreferrer\">Stranded Mapping from Long Reads<\/a>), transcript reference fasta file, annotation file<\/p>\n<p>\u00a0<\/p>\n<p><strong>Output(s):<\/strong> transcript table, sorted by differential coverage, annotated with gene name \/ description \/ location<\/p>","is_bookmarked":"0","can_reassign":"1","before_start":"<p>Obtain a transcript fasta file, and an annotation file. For the mouse genome, I use the following files:<\/p>\n<p>\u00a0<\/p>\n<ol>\n<li>Transcript [CDS] sequences from <a href=\"http:\/\/asia.ensembl.org\/Mus_musculus\/Info\/Index\" target=\"_blank\" rel=\"noopener noreferrer\">Ensembl<\/a>; <a href=\"ftp:\/\/ftp.ensembl.org\/pub\/release-92\/fasta\/mus_musculus\/cds\/Mus_musculus.GRCm38.cds.all.fa.gz\" target=\"_blank\" rel=\"noopener noreferrer\">this file<\/a> is the most current at the time this protocol was created.<\/li>\n<li>Annotation file obtained from <a href=\"http:\/\/asia.ensembl.org\/biomart\/martview\" target=\"_blank\" rel=\"noopener noreferrer\">Ensembl BioMart<\/a> (Ensembl Genes -&gt; Mouse Genes) as a compressed TSV file with the following attribute columns:\n<ul>\n<li>\n<div>Transcript stable ID<\/div>\n<\/li>\n<li>\n<div>Gene description<\/div>\n<\/li>\n<li>\n<div>Gene start (bp)<\/div>\n<\/li>\n<li>\n<div>Gene end (bp)<\/div>\n<\/li>\n<li>\n<div>Strand<\/div>\n<\/li>\n<li>\n<div>Gene name<\/div>\n<\/li>\n<li>\n<div>Chromosome\/scaffold name<\/div>\n<\/li>\n<\/ul>\n<\/li>\n<\/ol>","has_guidelines":"0","materials":[],"warning":null,"version_class":"13491","public":"1","is_owner":"1","is_original_owner":"1","created_on":"1530518754","protocol_affiliation":"Malaghan Institute of Medical Research (NZ)","affiliation":"Malaghan Institute of Medical Research (NZ)","doi":"dx.doi.org\/10.17504\/protocols.io.re2d3ge","doi_status":"2","changed_fork_steps":null,"profile_url":"DavidEccles-y2138443y2","protocol_img":"https:\/\/www.protocols.io\/img\/default_protocol.png","profile_image":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg","full_name":"David Eccles","created_by":"David Eccles","private_link":"016A43AECD3384F34A6B1709910AA19D","original_img":"1","username":"david-eccles","is_retracted":"0","retraction_reason":null,"plos_id":null,"manuscript_citation":null,"journal_name":null,"is_donations_disabled":"0","is_donations_disabled_by_user":"9","item_record_id":327612,"fork_info":[],"compare_forks":[],"protocols":[],"groups":[{"group_id":"269","group_uri":"awesome-DNA-from-all-kingdoms-of-life","group_name":"MinION user group for high molecular weight DNA extraction from all kingdoms","group_logo":"https:\/\/s3.amazonaws.com\/pr-journal\/ftfb5nw.jpg","requested_uid":null,"request_flag":null,"my_request":"0"}],"number_of_shared_runs":[],"ownership_history":[],"keywords":"","transfer_to_user":[],"sub_transfer":false,"is_transfer_pending":false,"number_of_bookmarks":"0","collections":[],"tags":[{"tag_id":"454","tag_name":"bioinformatics"},{"tag_id":"643","tag_name":"long read sequencing"},{"tag_id":"893","tag_name":"cDNA"},{"tag_id":"2065","tag_name":"nanopore"},{"tag_id":"2213","tag_name":"differential expression"}],"archived":0,"sub_authors":[],"sub_protocols_number":0,"can_edit_shared":0,"shared_runs":[],"is_shared_run":0,"is_shared":1,"banner":null,"contact_badges":[{"badge_id":"2","badge_image":"\/img\/badges\/bronze.svg","badge_description":"Author!"},{"badge_id":"6","badge_image":"\/img\/badges\/socialbutterfly.svg","badge_description":"Social butterfly"}],"number_of_comments":0,"is_locked":0,"is_locked_by":false,"authors":"David Eccles","authors_list":[{"name":"David Eccles","affiliation":"Malaghan Institute of Medical Research (NZ)","username":"david-eccles","profile_image":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg"}],"user":{"profile_image":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg","username":"david-eccles","full_name":"David Eccles","created_by":"David Eccles"},"access":{"can_view":"1","can_remove":"0","can_add":"0","can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":"0","can_move":"1","can_transfer":"1","can_download":"1","is_locked":"0"},"is_contact_suspended":0,"guidelines":null,"status_id":"2","is_research":"1","status_info":"We are still developing and optimizing this protocol","steps":[{"id":"641740","is_changed":"0","original_id":"641696","is_skipped":"0","is_checked":"0","guid":"3C224F57EDBD413AAC8361DF8676A8F5","previous_guid":null,"previous_id":null,"last_modified":"1530518754","components":[{"component_id":"1141828","previous_id":0,"original_id":"1141728","guid":"28021ECDBEE34BACA6953C292A095CE7","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Transcriptome Mapping","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Transcriptome Mapping"},"is_project":0},{"component_id":"1141829","previous_id":"1141828","original_id":"1141727","guid":"6B533BCE761540BCAEB521D49B570E04","previous_guid":"28021ECDBEE34BACA6953C292A095CE7","component_type_id":"1","data_id":null,"data":"","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":""},"is_project":0},{"component_id":"1141830","previous_id":"1141829","original_id":"1141729","guid":"981E56F70367436980595A074065B172","previous_guid":"6B533BCE761540BCAEB521D49B570E04","component_type_id":"8","data_id":"326","data":"","order_id":"2","name":"Software package","data_by_id":"1","type_id":"8","source_data":{"id":"326","name":"LAST","developer":"Martin Frith","repository":"http:\/\/last.cbrc.jp\/last\/","link":"http:\/\/last.cbrc.jp\/","os_name":"Debian GNU\/Linux","os_version":"","version":"","can_edit":"1"},"is_project":0},{"component_id":"1141831","previous_id":"1141830","original_id":"1141730","guid":"5BBB13C09674493F9B8F21925D51B426","previous_guid":"981E56F70367436980595A074065B172","component_type_id":"15","data_id":"4237","data":"","order_id":"3","name":"Command","data_by_id":"1","type_id":"15","source_data":{"name":"lastdb Mus_musculus.GRCm38.cds.all.fa <(zcat Mus_musculus.GRCm38.cds.all.fa.gz)","description":"Create the transcriptome index from the transcriptome fasta file using lastdb. An anonymous pipe is used \"<()\" to avoid the need to decompress the file for index generation.","os_name":"","os_version":"","can_edit":"1"},"is_project":0}]},{"id":"641741","is_changed":"0","original_id":"641697","is_skipped":"0","is_checked":"0","guid":"D18CE9FE8D18421592E14562B78B611D","previous_guid":"3C224F57EDBD413AAC8361DF8676A8F5","previous_id":"641740","last_modified":"1530518754","components":[{"component_id":"1141832","previous_id":0,"original_id":"1141732","guid":"3E34EA4758DB431895A86B97D21445C3","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Transcriptome Mapping","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Transcriptome Mapping"},"is_project":0},{"component_id":"1141833","previous_id":"1141832","original_id":"1141731","guid":"D5D8F6F978FB46758DE97CCBC54F9595","previous_guid":"3E34EA4758DB431895A86B97D21445C3","component_type_id":"1","data_id":null,"data":"<p>Map the reads to the Mmus transcripts with LAST.<\/p>\n<p>\u00a0<\/p>\n<p>The results of that mapping can be piped through <em>last-map-probs<\/em> to exclude unlikely hits, then through my <a href=\"https:\/\/gitlab.com\/gringer\/bioinfscripts\/blob\/master\/maf_bcsplit.pl\" target=\"_blank\" rel=\"noopener noreferrer\">maf_bcsplit.pl<\/a> script to convert to a one-line-per-mapping CSV format. This CSV format is further processed to make sure that there is only one mapping per transcript-read pair, and then aggregated to sum up counts per transcript.<\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Map the reads to the Mmus transcripts with LAST.<\/p>\n<p>\u00a0<\/p>\n<p>The results of that mapping can be piped through <em>last-map-probs<\/em> to exclude unlikely hits, then through my <a href=\"https:\/\/gitlab.com\/gringer\/bioinfscripts\/blob\/master\/maf_bcsplit.pl\" target=\"_blank\" rel=\"noopener noreferrer\">maf_bcsplit.pl<\/a> script to convert to a one-line-per-mapping CSV format. This CSV format is further processed to make sure that there is only one mapping per transcript-read pair, and then aggregated to sum up counts per transcript.<\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>"},"is_project":0},{"component_id":"1141834","previous_id":"1141833","original_id":"1141733","guid":"1B6502BF437946C3A38477D61796DC83","previous_guid":"D5D8F6F978FB46758DE97CCBC54F9595","component_type_id":"15","data_id":"4238","data":"","order_id":"2","name":"Command","data_by_id":"1","type_id":"15","source_data":{"name":"for id in \"fwd_4T1_BC06\" \"rev_4T1_BC06\" \"fwd_4T1_BC07\" \"rev_4T1_BC07\"\n  do lastal Mus_musculus.GRCm38.cds.all.fa <(pv ${id}.correctedReads.uniqueOnly.fasta.gz | zcat) | \\\n    last-map-probs | ~\/scripts\/maf_bcsplit.pl | awk -F',' '{print $1,$2,$3}' | sort | \\\n    uniq | awk '{print $2,$3}' | sort | uniq -c > trnCounts_LAST_${id}_vs_Mmus_transcriptome.txt\ndone","description":"LAST mapping; probable hit filtering, read counting, and conversion to count file","os_name":"","os_version":"","can_edit":"1"},"is_project":0}]},{"id":"641742","is_changed":"0","original_id":"641700","is_skipped":"0","is_checked":"0","guid":"7E6192E199904843B7A069AE7ACD244C","previous_guid":"D18CE9FE8D18421592E14562B78B611D","previous_id":"641741","last_modified":"1530518754","components":[{"component_id":"1141835","previous_id":0,"original_id":"1141740","guid":"EB6FAB4F96F84B57A2EC6EB60C23F628","previous_guid":null,"component_type_id":"1","data_id":null,"data":"<p>Transcript counts are converted into a narrow table (one line per transcript\/count\/barcode tuple) that includes strand direction and a barcode tag:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>trnCounts &lt;- lapply(c(\"fwd_4T1_BC06\", \"rev_4T1_BC06\",\n                      \"fwd_4T1_BC07\", \"rev_4T1_BC07\"),\n                    function(x){\n                        res &lt;- read.table(sprintf((\"trnCounts_%s_vs_Mmus_transcriptome.txt\"),\n                                                  x), stringsAsFactors=FALSE,\n                                          col.names=c(\"Count\",\"Transcript\",\n                                                      \"Direction\"));\n                        if(grepl(\"rev\",x)){\n                            res$Direction = c(\"-\" = \"+\", \"+\" = \"-\")[res$Direction];\n                        }\n                        res$DB &lt;- paste0(sub(\"..._4T1_\",\"\",x), res$Direction);\n                        return(res);\n                    });\ntrnCounts &lt;- rbind(trnCounts[[1]],trnCounts[[2]],trnCounts[[3]],trnCounts[[4]]);<\/code><\/pre>","order_id":"0","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Transcript counts are converted into a narrow table (one line per transcript\/count\/barcode tuple) that includes strand direction and a barcode tag:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>trnCounts &lt;- lapply(c(\"fwd_4T1_BC06\", \"rev_4T1_BC06\",\n                      \"fwd_4T1_BC07\", \"rev_4T1_BC07\"),\n                    function(x){\n                        res &lt;- read.table(sprintf((\"trnCounts_%s_vs_Mmus_transcriptome.txt\"),\n                                                  x), stringsAsFactors=FALSE,\n                                          col.names=c(\"Count\",\"Transcript\",\n                                                      \"Direction\"));\n                        if(grepl(\"rev\",x)){\n                            res$Direction = c(\"-\" = \"+\", \"+\" = \"-\")[res$Direction];\n                        }\n                        res$DB &lt;- paste0(sub(\"..._4T1_\",\"\",x), res$Direction);\n                        return(res);\n                    });\ntrnCounts &lt;- rbind(trnCounts[[1]],trnCounts[[2]],trnCounts[[3]],trnCounts[[4]]);<\/code><\/pre>"},"is_project":0},{"component_id":"1141836","previous_id":"1141835","original_id":"1141741","guid":"DAA3D76146B44BA290BF256EE4826928","previous_guid":"EB6FAB4F96F84B57A2EC6EB60C23F628","component_type_id":"6","data_id":null,"data":"Data Cleaning (R script)","order_id":"1","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Data Cleaning (R script)"},"is_project":0}]},{"id":"641743","is_changed":"0","original_id":"641702","is_skipped":"0","is_checked":"0","guid":"398183A33FA24C079802B03E88672520","previous_guid":"7E6192E199904843B7A069AE7ACD244C","previous_id":"641742","last_modified":"1530518754","components":[{"component_id":"1141837","previous_id":0,"original_id":"1141746","guid":"A0E09546650A42419B139A55F94DD5FB","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Data Cleaning (R script)","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Data Cleaning (R script)"},"is_project":0},{"component_id":"1141838","previous_id":"1141837","original_id":"1141745","guid":"5D909311B8E5482CB22F3809BC0B56D4","previous_guid":"A0E09546650A42419B139A55F94DD5FB","component_type_id":"1","data_id":null,"data":"<p>The transcript revision number (if any) is removed from the transcript ID:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code> trnCounts$Transcript &lt;- sub(\"\\\\.[0-9]+$\",\"\",trnCounts$Transcript);<\/code><\/pre>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>The transcript revision number (if any) is removed from the transcript ID:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code> trnCounts$Transcript &lt;- sub(\"\\\\.[0-9]+$\",\"\",trnCounts$Transcript);<\/code><\/pre>"},"is_project":0}]},{"id":"641744","is_changed":"0","original_id":"641703","is_skipped":"0","is_checked":"0","guid":"7350918304E34CE5B2067A4A9AE3DDB6","previous_guid":"398183A33FA24C079802B03E88672520","previous_id":"641743","last_modified":"1530518754","components":[{"component_id":"1141839","previous_id":0,"original_id":"1141749","guid":"6E60E3EF16D2414AB07C0827141A230D","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Data Cleaning (R script)","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Data Cleaning (R script)"},"is_project":0},{"component_id":"1141840","previous_id":"1141839","original_id":"1141748","guid":"9E40B1350FF34275AB9B9BE5F95CC7A5","previous_guid":"6E60E3EF16D2414AB07C0827141A230D","component_type_id":"1","data_id":null,"data":"<p>The annotation file is loaded into memory:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>ensembl.df &lt;- read.delim(\"ensembl_mm10_geneFeatureLocations.txt.gz\",\n                         col.names=c(\"Transcript\",\"Description\",\"Start\",\n                                     \"End\",\"Strand\",\"Gene\",\"Chr\"),\n                         stringsAsFactors=FALSE);<\/code><\/pre>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>The annotation file is loaded into memory:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>ensembl.df &lt;- read.delim(\"ensembl_mm10_geneFeatureLocations.txt.gz\",\n                         col.names=c(\"Transcript\",\"Description\",\"Start\",\n                                     \"End\",\"Strand\",\"Gene\",\"Chr\"),\n                         stringsAsFactors=FALSE);<\/code><\/pre>"},"is_project":0}]},{"id":"641745","is_changed":"0","original_id":"641704","is_skipped":"0","is_checked":"0","guid":"EDEDAB780BDA47CDA177F8A0A072FA64","previous_guid":"7350918304E34CE5B2067A4A9AE3DDB6","previous_id":"641744","last_modified":"1530518754","components":[{"component_id":"1141841","previous_id":0,"original_id":"1141751","guid":"D136A02B6382449ABF8B11A8E299C584","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Data Cleaning (R script)","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Data Cleaning (R script)"},"is_project":0},{"component_id":"1141842","previous_id":"1141841","original_id":"1141750","guid":"20FBE5E0B51D4EC2A307A3433CB592D4","previous_guid":"D136A02B6382449ABF8B11A8E299C584","component_type_id":"1","data_id":null,"data":"<p>The <em>dplyr<\/em> and <em>tidyr<\/em> packages are used to convert to a wide format, and pull the associated annotation from the ensembl annotation file:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>library(dplyr);\nlibrary(tidyr);\n\ntrnCounts.wide &lt;- group_by(trnCounts, DB, Transcript) %&gt;%\n    summarise(Count = sum(Count)) %&gt;% spread(DB, Count) %&gt;% inner_join(ensembl.df, by=\"Transcript\");<\/code><\/pre>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>The <em>dplyr<\/em> and <em>tidyr<\/em> packages are used to convert to a wide format, and pull the associated annotation from the ensembl annotation file:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>library(dplyr);\nlibrary(tidyr);\n\ntrnCounts.wide &lt;- group_by(trnCounts, DB, Transcript) %&gt;%\n    summarise(Count = sum(Count)) %&gt;% spread(DB, Count) %&gt;% inner_join(ensembl.df, by=\"Transcript\");<\/code><\/pre>"},"is_project":0}]},{"id":"641746","is_changed":"0","original_id":"641705","is_skipped":"0","is_checked":"0","guid":"D00315435EFE470B9DC1098A5C9464B5","previous_guid":"EDEDAB780BDA47CDA177F8A0A072FA64","previous_id":"641745","last_modified":"1530518754","components":[{"component_id":"1141843","previous_id":0,"original_id":"1141753","guid":"9F11D2C8AF424D049A1B2C7F22782314","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Data Cleaning (R script)","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Data Cleaning (R script)"},"is_project":0},{"component_id":"1141844","previous_id":"1141843","original_id":"1141752","guid":"BEDCAE0280F646FDAE04F53CBF016ABA","previous_guid":"9F11D2C8AF424D049A1B2C7F22782314","component_type_id":"1","data_id":null,"data":"<p>Missing data is set to a count of zero to simplify subsequent computation:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>trnCounts.wide$WTfwd &lt;- coalesce(trnCounts.wide$`BC06+`,0L);\ntrnCounts.wide$WTrev &lt;- coalesce(trnCounts.wide$`BC06-`,0L);\ntrnCounts.wide$\u03c10fwd &lt;- coalesce(trnCounts.wide$`BC07+`,0L);\ntrnCounts.wide$\u03c10rev &lt;- coalesce(trnCounts.wide$`BC07-`,0L);<\/code><\/pre>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Missing data is set to a count of zero to simplify subsequent computation:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>trnCounts.wide$WTfwd &lt;- coalesce(trnCounts.wide$`BC06+`,0L);\ntrnCounts.wide$WTrev &lt;- coalesce(trnCounts.wide$`BC06-`,0L);\ntrnCounts.wide$\u03c10fwd &lt;- coalesce(trnCounts.wide$`BC07+`,0L);\ntrnCounts.wide$\u03c10rev &lt;- coalesce(trnCounts.wide$`BC07-`,0L);<\/code><\/pre>"},"is_project":0}]},{"id":"641747","is_changed":1,"original_id":"641706","is_skipped":"0","is_checked":"0","guid":"0CFA1CEC7E874D3AA47074CA1863D471","previous_guid":"D00315435EFE470B9DC1098A5C9464B5","previous_id":"641746","last_modified":"1530518877","components":[{"component_id":"1141845","previous_id":0,"original_id":"1141755","guid":"7830E46339924491996691147CB5EFF5","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Differential coverage (R script)","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Differential coverage (R script)"},"is_project":0},{"component_id":"1141846","previous_id":"1141845","original_id":"1141754","guid":"900E467CE60B4C128A2CB9D9CBAF3B33","previous_guid":"7830E46339924491996691147CB5EFF5","component_type_id":"1","data_id":null,"data":"<p>This was a pilot experiment with no replicate data (hence why I refer to this as 'differential coverage', rather than differential expression. I would usually use software with proper statistical modeling (such as <a href=\"https:\/\/bioconductor.org\/packages\/release\/bioc\/html\/DESeq2.html\" target=\"_blank\" rel=\"noopener noreferrer\">DESeq2<\/a>), but in this case I'm generating a quick rough-cut comparison using basic R.<\/p>\n<p>\u00a0<\/p>\n<p>I introduce a fudge factor to account for missing data, and use this factor in the calculation of differential coverage (as log2 fold change). The strand-specificity of the sequencing and transcript annotation allows this differential coverage to be determined for only those reads mapping in the correct direction. Results are rounded to 1 d.p. as an additional warning that these results have a low precision.<\/p>\n<p>\u00a0<\/p>\n<p>As the alignment is to transcripts, the direction of the gene is ignored:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>fcFudge &lt;- 5;\ntrnCounts.wide$DCov &lt;- round(log2(trnCounts.wide$WTfwd+fcFudge)-log2(trnCounts.wide$\u03c10fwd+fcFudge),1);\n<\/code><\/pre>\n<p>\u00a0<\/p>\n<p>However, if aligning to genome sequences, use the following code:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>fcFudge &lt;- 5;\ntrnCounts.wide$DCov &lt;- round(ifelse(trnCounts.wide$Strand == 1,\n                              log2(trnCounts.wide$WTfwd+fcFudge)-log2(trnCounts.wide$\u03c10fwd+fcFudge),\n                              log2(trnCounts.wide$WTrev+fcFudge)-log2(trnCounts.wide$\u03c10rev+fcFudge)),1);\n<\/code><\/pre>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>This was a pilot experiment with no replicate data (hence why I refer to this as 'differential coverage', rather than differential expression. I would usually use software with proper statistical modeling (such as <a href=\"https:\/\/bioconductor.org\/packages\/release\/bioc\/html\/DESeq2.html\" target=\"_blank\" rel=\"noopener noreferrer\">DESeq2<\/a>), but in this case I'm generating a quick rough-cut comparison using basic R.<\/p>\n<p>\u00a0<\/p>\n<p>I introduce a fudge factor to account for missing data, and use this factor in the calculation of differential coverage (as log2 fold change). The strand-specificity of the sequencing and transcript annotation allows this differential coverage to be determined for only those reads mapping in the correct direction. Results are rounded to 1 d.p. as an additional warning that these results have a low precision.<\/p>\n<p>\u00a0<\/p>\n<p>As the alignment is to transcripts, the direction of the gene is ignored:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>fcFudge &lt;- 5;\ntrnCounts.wide$DCov &lt;- round(log2(trnCounts.wide$WTfwd+fcFudge)-log2(trnCounts.wide$\u03c10fwd+fcFudge),1);\n<\/code><\/pre>\n<p>\u00a0<\/p>\n<p>However, if aligning to genome sequences, use the following code:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>fcFudge &lt;- 5;\ntrnCounts.wide$DCov &lt;- round(ifelse(trnCounts.wide$Strand == 1,\n                              log2(trnCounts.wide$WTfwd+fcFudge)-log2(trnCounts.wide$\u03c10fwd+fcFudge),\n                              log2(trnCounts.wide$WTrev+fcFudge)-log2(trnCounts.wide$\u03c10rev+fcFudge)),1);\n<\/code><\/pre>"},"is_project":0}],"available_protocols":["13491"]},{"id":"641748","is_changed":"0","original_id":"641707","is_skipped":"0","is_checked":"0","guid":"305091627EF4421CAFCA7E73AD710D45","previous_guid":"0CFA1CEC7E874D3AA47074CA1863D471","previous_id":"641747","last_modified":"1530518754","components":[{"component_id":"1141847","previous_id":0,"original_id":"1141757","guid":"8FBBEEF6EF3B402D9691BA63F9365311","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Differential coverage (R script)","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Differential coverage (R script)"},"is_project":0},{"component_id":"1141848","previous_id":"1141847","original_id":"1141756","guid":"5A13BC3809AC46FC955842C688980089","previous_guid":"8FBBEEF6EF3B402D9691BA63F9365311","component_type_id":"1","data_id":null,"data":"<p>Finally, the resultant table is writtent out to a CSV file, ordered by the absolute value of the differential coverage statistic:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>trnCounts.wide &lt;- arrange(trnCounts.wide, -abs(DCov));\n\nwrite.csv(trnCounts.wide[,c(\"Transcript\",\"WTfwd\",\"WTrev\",\"\u03c10fwd\",\"\u03c10rev\",\n\"DCov\",\"Gene\",\"Description\",\"Chr\",\"Start\",\"End\")],\nfile=\"wide_transcript_Counts_WTvs\u03c10.csv\", row.names=FALSE);<\/code><\/pre>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Finally, the resultant table is writtent out to a CSV file, ordered by the absolute value of the differential coverage statistic:<\/p>\n<p>\u00a0<\/p>\n<pre class=\"language-java\"><code>trnCounts.wide &lt;- arrange(trnCounts.wide, -abs(DCov));\n\nwrite.csv(trnCounts.wide[,c(\"Transcript\",\"WTfwd\",\"WTrev\",\"\u03c10fwd\",\"\u03c10rev\",\n\"DCov\",\"Gene\",\"Description\",\"Chr\",\"Start\",\"End\")],\nfile=\"wide_transcript_Counts_WTvs\u03c10.csv\", row.names=FALSE);<\/code><\/pre>"},"is_project":0}]}]}