{"id":31099,"title":"Bioflux Analyses: Image Preprocessing","title_html":"<p>Bioflux Analyses: Image Preprocessing<\/p>","image":{"source":"https:\/\/protocols-files.s3.amazonaws.com\/private\/40242a8afacdec91e823540962334878ee79175d9206d3caefbdb35b8cb49603\/bvwwbatvp.png?X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJYFAX46LHRVQMGOA%2F20200128%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20200128T101838Z&X-Amz-SignedHeaders=host&X-Amz-Expires=604800&X-Amz-Signature=d5c7311f77d4e81e8569c5df5f1f219fa6d8ff3641226e39c7b430f637d9fc81","placeholder":"https:\/\/protocols-files.s3.amazonaws.com\/private\/40242a8afacdec91e823540962334878ee79175d9206d3caefbdb35b8cb49603\/bvwwbatvp.png?X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJYFAX46LHRVQMGOA%2F20200128%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20200128T101838Z&X-Amz-SignedHeaders=host&X-Amz-Expires=604800&X-Amz-Signature=d5c7311f77d4e81e8569c5df5f1f219fa6d8ff3641226e39c7b430f637d9fc81"},"doi":"dx.doi.org\/10.17504\/protocols.io.bak3icyn","doi_status":2,"uri":"bioflux-analyses-image-preprocessing-bak3icyn","type_id":1,"published_on":1580737455,"parent_protocols":[],"parent_collections":[],"version_id":0,"created_on":1576583362,"categories":null,"creator":{"name":"Tobias Weise","affiliation":"BioControl Jena GmbH","affiliations":[{"affiliation":"BioControl Jena GmbH","url":"https:\/\/www.biocontrol-jena.com\/","is_default":1}],"username":"tobias-weise","link":null,"image":{"source":"\/img\/avatars\/003.png","placeholder":"\/img\/avatars\/003.png"},"badges":[{"id":2,"image":{"source":"\/img\/badges\/bronze.svg","placeholder":"\/img\/badges\/bronze.svg"},"name":"Author"}],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"journal":null,"journal_name":null,"journal_link":null,"article_citation":null,"public":1,"has_versions":false,"link":null,"total_collections":1,"number_of_steps":20,"authors":[{"name":"Tobias Weise","affiliation":"BioControl Jena GmbH","affiliations":[],"username":"tobias-weise","link":null,"image":{"source":"\/img\/avatars\/003.png","placeholder":"\/img\/avatars\/003.png"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false}],"versions":[],"groups":[],"has_subprotocols":0,"is_subprotocol":0,"is_bookmarked":0,"can_be_copied":1,"can_remove_fork":1,"forks_count":{"private":0,"public":0},"access":{"can_view":1,"can_remove":0,"can_add":0,"can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":1,"can_move":1,"can_move_outside":1,"can_transfer":1,"can_download":1,"is_locked":0},"guid":"08B654E020C311EABB9A6DDB197102FB","state_version_id":2240,"steps":[{"id":862299,"guid":"C3E9FF8020C511EABB9A6DDB197102FB","previous_id":null,"previous_guid":null,"modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"02A9EB9C8F2740CF82B125EE103F8E38","order_id":1,"type_id":6,"title":"Section","source":{"title":"Video File to Frames"}},{"id":1054724,"guid":"4106D31713844709ACBBA357E36FE382","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-weight:bold;\">Convert video file into single images<\/span><\/div><div class = \"text-block\"><span>The source material provided as .AVI file is converted into single .TIFF images using <\/span><span style = \"font-style:italic;\">opencv-python. <\/span><span>Additional, a data frame containing meta data annotations is created.<\/span><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":862300,"guid":"FEE5553020C511EABB9A6DDB197102FB","previous_id":871731,"previous_guid":"7BCFC5103D0B11EA91699399F902DDAE","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"C856CEB6885440C5983DDF2EEEC9CDA7","order_id":1,"type_id":6,"title":"Section","source":{"title":"Image Processing"}},{"id":1054724,"guid":"D254BF107572462A9C0D82491E417A0D","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-weight:bold;\">Chamber Edge Determination<\/span><\/div><div class = \"text-block\">The individual image contains two growth chambers separated by four edge lines (Fig. 2.1-A). Median pixel intensity (in Y-direction) is calculated for each position in X-direction (Fig 2.1-B), and subsequently derived into the absolute difference in median pixel intensity (Fig. 2.1-C). Values greater or equal to the 98 % percentile of the respective data set (peak values) are assigned into four equidistant clusters (Fig. 2.1-D). The maximum peak value of the respective cluster returns the X-position of the respective chamber edge.<\/div><div class = \"text-block\">Visualisation of Chamber Edge Determination.<\/div><div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/protocols-files.s3.amazonaws.com\/private\/40242a8afacdec91e823540962334878ee79175d9206d3caefbdb35b8cb49603\/bwh7batvp.png?X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJYFAX46LHRVQMGOA%2F20200129%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20200129T171719Z&X-Amz-SignedHeaders=host&X-Amz-Expires=604800&X-Amz-Signature=d6f85234b68f7616017160b3c98db9bf10b5856f4e996863cccee860e31176a7\" \/><\/div><\/div>"}},{"id":1054725,"guid":"D60722A6C14B4CBFB821A2DF9AC25D0B","order_id":2,"type_id":1,"title":"description","source":{"description":"<div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/protocols-files.s3.amazonaws.com\/private\/40242a8afacdec91e823540962334878ee79175d9206d3caefbdb35b8cb49603\/bwh7batvp.png?X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJYFAX46LHRVQMGOA%2F20200129%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20200129T171719Z&X-Amz-SignedHeaders=host&X-Amz-Expires=604800&X-Amz-Signature=d6f85234b68f7616017160b3c98db9bf10b5856f4e996863cccee860e31176a7\" \/><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":862320,"guid":"9624A8A020D111EA9479FBE15C588D80","previous_id":862300,"previous_guid":"FEE5553020C511EABB9A6DDB197102FB","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"F53C7D1920B14BE69B8401625556D76F","order_id":1,"type_id":6,"title":"Section","source":{"title":"Image Processing"}},{"id":1054724,"guid":"CA127D99CBC5401CA8FD9CC753C49D47","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Import of the required packages.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">import numpy as np<\/div><div class = \"text-block\">import pandas as pd<\/div><div class = \"text-block\">import skimage<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":862322,"guid":"ABFE39C020D111EA9479FBE15C588D80","previous_id":862320,"previous_guid":"9624A8A020D111EA9479FBE15C588D80","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"0DF146292C9F46A2A24B476230A977F3","order_id":1,"type_id":6,"title":"Section","source":{"title":"Image Processing"}},{"id":1054724,"guid":"95B1BEE898464AF2AA3D670679B1FA06","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Example code of the Chamber Edge Determination definition.<\/div><div class = \"text-block\">Strategy:     <\/div><div class = \"text-block\"><ol style = \"list-style-type: decimal;\"><li style = \"counter-reset:ol0;\">calculate the median pixel intensity along the y-axis of image<\/li><li style = \"counter-reset:ol0;\">create derivative of median values (absolute values) to find the change in median pixel intensity along x-axis of image     <\/li><li style = \"counter-reset:ol0;\">select peak values (representing position of chamber lines)<\/li><li style = \"counter-reset:ol0;\">calculation of 6 positions (left chamber (2 lines), inner space (2 lines), right chamber (2 lines))<\/li><\/ol><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">def find_lines(img):<\/div><div class = \"text-block\">    #invert image<\/div><div class = \"text-block\">    img_bin = 255 - img<\/div><div class = \"text-block\">    # calculate median intensity row-wise<\/div><div class = \"text-block\">    xmedian = np.zeros(len(img_bin))<\/div><div class = \"text-block\">    for i in range(len(img_bin)):<\/div><div class = \"text-block\">        xmedian[i] = np.median(img_bin[i])<\/div><div class = \"text-block\">    # median values to DataFrame<\/div><div class = \"text-block\">    df = pd.DataFrame(data={'xmedian':xmedian})<\/div><div class = \"text-block\">    # calculate absolutes of differences of pixels row-wise<\/div><div class = \"text-block\">    df['xdiff'] = pd.DataFrame.diff(df.xmedian, periods=1, axis=0).abs()<\/div><div class = \"text-block\">    # calculate 98% percentile & pic values above this threshold<\/div><div class = \"text-block\">    qdf = df[df.xdiff >= np.nanpercentile(df.xdiff,98)].copy()<\/div><div class = \"text-block\">    qdf.reset_index(inplace=True)<\/div><div class = \"text-block\">    qdf.rename(columns={'index':'imgdex'},inplace=True)<\/div><div class = \"text-block\">    # assign imgdex to four clusters <\/div><div class = \"text-block\">    qdf['cluster'] = pd.cut(qdf.imgdex,4,right=True,labels=[0,1,2,3])<\/div><div class = \"text-block\">    # assign 6 lines (using 5 pixels safety distance)<\/div><div class = \"text-block\">    imgdex = np.zeros(6)<\/div><div class = \"text-block\">    imgdex[0] = qdf.imgdex[(qdf.cluster == 0) & \\<\/div><div class = \"text-block\">    (qdf.xdiff == qdf.xdiff[(qdf.cluster == 0)].max())].max() + 5<\/div><div class = \"text-block\">    imgdex[1] = qdf.imgdex[(qdf.cluster == 1) & \\<\/div><div class = \"text-block\">    (qdf.xdiff == qdf.xdiff[(qdf.cluster == 1)].max())].min() - 5<\/div><div class = \"text-block\">    imgdex[2] = qdf.imgdex[(qdf.cluster == 1) & \\<\/div><div class = \"text-block\">    (qdf.xdiff == qdf.xdiff[(qdf.cluster == 1)].max())].max() + 5<\/div><div class = \"text-block\">    imgdex[3] = qdf.imgdex[(qdf.cluster == 2) & \\<\/div><div class = \"text-block\">    (qdf.xdiff == qdf.xdiff[(qdf.cluster == 2)].max())].min() - 5<\/div><div class = \"text-block\">    imgdex[4] = qdf.imgdex[(qdf.cluster == 2) & \\<\/div><div class = \"text-block\">    (qdf.xdiff == qdf.xdiff[(qdf.cluster == 2)].max())].max() + 5<\/div><div class = \"text-block\">    imgdex[5] = qdf.imgdex[(qdf.cluster == 3) & \\<\/div><div class = \"text-block\">    (qdf.xdiff == qdf.xdiff[(qdf.cluster == 3)].max())].min() - 5<\/div><div class = \"text-block\">    imgdex = np.array(imgdex, dtype='int')<\/div><div class = \"text-block\">    # return lines as integer array<\/div><div class = \"text-block\">    return imgdex<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":862326,"guid":"C0B7B4E020D111EA9479FBE15C588D80","previous_id":862299,"previous_guid":"C3E9FF8020C511EABB9A6DDB197102FB","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"3AD4CA871E7F40EEA7CD937B31728C78","order_id":1,"type_id":6,"title":"Section","source":{"title":"Video File to Frames"}},{"id":1054724,"guid":"F3A4EBFF9DE242DF9564D7B842EF4B27","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Import of the required packages.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">import numpy as np<\/div><div class = \"text-block\">import pandas as pd<\/div><div class = \"text-block\">import cv2<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":862328,"guid":"C982AEE020D111EA9479FBE15C588D80","previous_id":862326,"previous_guid":"C0B7B4E020D111EA9479FBE15C588D80","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"B7546CC6D20F4FF2AD9C646C8DFD3A93","order_id":1,"type_id":6,"title":"Section","source":{"title":"Video File to Frames"}},{"id":1054724,"guid":"941B54470B0148F9BF90E97908C6870B","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Example code for reading the video file from source path and saving the individual images to target path.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">cap = cv2.VideoCapture(source_path\/video_file.AVI)<\/div><div class = \"text-block\">i = 0<\/div><div class = \"text-block\"># read frames from video file<\/div><div class = \"text-block\">while(cap.isOpened()):<\/div><div class = \"text-block\">    ret,frame = cap.read()<\/div><div class = \"text-block\">    if ret == False:<\/div><div class = \"text-block\">        break<\/div><div class = \"text-block\">    # convert to greyscale image<\/div><div class = \"text-block\">    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<\/div><div class = \"text-block\">    # save to file<\/div><div class = \"text-block\">    cv2.imwrite((target_path + 'frame_%s.TIFF'%i), frame)<\/div><div class = \"text-block\">    i += 1<\/div><div class = \"text-block\">cap.release()<\/div><div class = \"text-block\">cv2.destroyAllWindows()<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":862330,"guid":"2067C33020D711EA92722F2FFC6247C2","previous_id":862328,"previous_guid":"C982AEE020D111EA9479FBE15C588D80","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"3149069224F242AFA618C76704652CFF","order_id":1,"type_id":6,"title":"Section","source":{"title":"Video File to Frames"}},{"id":1054724,"guid":"8764B37BDDD34A229D43863CAE1D5914","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Example output of individual image (2D array) .<\/div><div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/protocols-files.s3.amazonaws.com\/private\/40242a8afacdec91e823540962334878ee79175d9206d3caefbdb35b8cb49603\/bvwybatvp.png?X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJYFAX46LHRVQMGOA%2F20200129%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20200129T171719Z&X-Amz-SignedHeaders=host&X-Amz-Expires=604800&X-Amz-Signature=91512ac74bbc1c820cfd7a55bcb0564a4154760f9cb255da1459c4bf4e07f9da\" \/><\/div><\/div>"}},{"id":1054725,"guid":"31CD4630DA6E4D69947FC321528CD43B","order_id":2,"type_id":1,"title":"description","source":{"description":"<div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/protocols-files.s3.amazonaws.com\/private\/40242a8afacdec91e823540962334878ee79175d9206d3caefbdb35b8cb49603\/bvwybatvp.png?X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJYFAX46LHRVQMGOA%2F20200129%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20200129T171719Z&X-Amz-SignedHeaders=host&X-Amz-Expires=604800&X-Amz-Signature=91512ac74bbc1c820cfd7a55bcb0564a4154760f9cb255da1459c4bf4e07f9da\" \/><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":866346,"guid":"0A32C2902E3311EA9D6F7B995F6D3E27","previous_id":866750,"previous_guid":"0E8D6590306111EA86CEDD1E387C8850","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"B386A0734CA3487DB661A27CAF5C312F","order_id":1,"type_id":6,"title":"Section","source":{"title":"Image Processing"}},{"id":1054724,"guid":"95E430134C174F5F98B7D49DB3AB89BB","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-weight:bold;\">Chamber Selection and Background Removal<\/span><\/div><div class = \"text-block\">Chambers were selected from the respective video frame between the determined chamber edges (according to Fig. 2.1-D). In order to exclude the chamber edge itself, a safety distance of 5 pixels in X-direction is applied. Also, a background removal was performed by subtracting the median intensity of the reference space resolved in Y-direction. Reference was selected as a 100 pixel wide strip next to cluster 1 (Fig. 2.1-D).<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":866750,"guid":"0E8D6590306111EA86CEDD1E387C8850","previous_id":862322,"previous_guid":"ABFE39C020D111EA9479FBE15C588D80","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"8CD8B6B161634A3AB4E5086E6F6E663E","order_id":1,"type_id":6,"title":"Section","source":{"title":"Image Processing"}},{"id":1054724,"guid":"C6D81ABD02FC4207A7C79BC8D34F6B7F","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Example code of the Chamber Edge Determination execution.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"># load meta data frame<\/div><div class = \"text-block\">data = pd.read_pickle((data_path + 'data.pkl'))<\/div><div class = \"text-block\"># loop over all images<\/div><div class = \"text-block\">line1, line2, line3, line4, line5, line6 = [np.zeros(len(data)) for i in range(6)]<\/div><div class = \"text-block\">for i in range(len(data)):<\/div><div class = \"text-block\">    clear_output()<\/div><div class = \"text-block\">    # read respective image<\/div><div class = \"text-block\">    img = skimage.io.imread((source_path + 'frame_%s.TIFF'%i))<\/div><div class = \"text-block\">    # rotate image <\/div><div class = \"text-block\">    img = skimage.transform.rotate(img,data.angle.median(),\\<\/div><div class = \"text-block\">                                   resize=True,mode='constant',cval=1)<\/div><div class = \"text-block\">    # find lines<\/div><div class = \"text-block\">    lines = find_lines(img)<\/div><div class = \"text-block\">    line1[i], line2[i], line3[i], line4[i], line5[i], line6[i] = lines<\/div><div class = \"text-block\"># append positions to meta data frame<\/div><div class = \"text-block\">data['line1'] = line1<\/div><div class = \"text-block\">data['line2'] = line2<\/div><div class = \"text-block\">data['line3'] = line3<\/div><div class = \"text-block\">data['line4'] = line4<\/div><div class = \"text-block\">data['line5'] = line5<\/div><div class = \"text-block\">data['line6'] = line6<\/div><div class = \"text-block\"># convert values into integers<\/div><div class = \"text-block\">data.line1 = pd.to_numeric(data.line1, errors='raise', downcast='integer')<\/div><div class = \"text-block\">data.line2 = pd.to_numeric(data.line2, errors='raise', downcast='integer')<\/div><div class = \"text-block\">data.line3 = pd.to_numeric(data.line3, errors='raise', downcast='integer')<\/div><div class = \"text-block\">data.line4 = pd.to_numeric(data.line4, errors='raise', downcast='integer')<\/div><div class = \"text-block\">data.line5 = pd.to_numeric(data.line5, errors='raise', downcast='integer')<\/div><div class = \"text-block\">data.line6 = pd.to_numeric(data.line6, errors='raise', downcast='integer')<\/div><div class = \"text-block\">save meta data frame to file<\/div><div class = \"text-block\">data.to_pickle((data_path + 'data.pkl'))<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":866752,"guid":"199D02F0306211EA86CEDD1E387C8850","previous_id":866346,"previous_guid":"0A32C2902E3311EA9D6F7B995F6D3E27","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"05FCF2C2F1834D4AA46203F7E897C268","order_id":1,"type_id":6,"title":"Section","source":{"title":"Image Processing"}},{"id":1054724,"guid":"5197055C445644958BCF40A861095957","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Import of the required packages.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">import numpy as np<\/div><div class = \"text-block\">import pandas as pd<\/div><div class = \"text-block\">import skimage<\/div><div class = \"text-block\">from skimage import img_as_uint<\/div><div class = \"text-block\">import cv2<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":866753,"guid":"D0829B10306211EA86CEDD1E387C8850","previous_id":866752,"previous_guid":"199D02F0306211EA86CEDD1E387C8850","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"1580CADBB84442AB95CF44C5F80FADD2","order_id":1,"type_id":6,"title":"Section","source":{"title":"Image Processing"}},{"id":1054724,"guid":"DC8C7A3A89974486907308A81B22B22A","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Example code of image rotation and chamber cutting execution.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"># load meta data frame from file<\/div><div class = \"text-block\">data = pd.read_pickle((data_path + 'data.pkl'))<\/div><div class = \"text-block\"># loop over all images <\/div><div class = \"text-block\">for i in range(len(data)):<\/div><div class = \"text-block\">    clear_output()<\/div><div class = \"text-block\">    print('processing file ',i+1,' of ',len(data))<\/div><div class = \"text-block\">    # read respective image<\/div><div class = \"text-block\">    img = skimage.io.imread((source_path + 'frame_%s.TIFF'%i))<\/div><div class = \"text-block\">    # rotate image<\/div><div class = \"text-block\">    img = skimage.transform.rotate(img,data.angle.median(),resize=False)<\/div><div class = \"text-block\">    # cut image into desired cambers<\/div><div class = \"text-block\">    # applying 10 pixels as safety distance in x-direction<\/div><div class = \"text-block\">    img_cham_A = img[data.line1[i]:data.line2[i], 10:len(img[0])-10]<\/div><div class = \"text-block\">    img_cham_B = img[data.line5[i]:data.line6[i], 10:len(img[0])-10]<\/div><div class = \"text-block\">    # save images to folder<\/div><div class = \"text-block\">    skimage.io.imsave((target_path + '00_WT\/frame_%s_WT.TIFF'%i), \\<\/div><div class = \"text-block\">                       img_as_uint(img_cham_A))<\/div><div class = \"text-block\">    skimage.io.imsave((target_path + '01_MT\/frame_%s_MT.TIFF'%i), \\<\/div><div class = \"text-block\">                       img_as_uint(img_cham_B))<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":866773,"guid":"0FFBC1A0306C11EA86CEDD1E387C8850","previous_id":866753,"previous_guid":"D0829B10306211EA86CEDD1E387C8850","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"F8FA7073159C443394867F39DCA5C83E","order_id":1,"type_id":6,"title":"Section","source":{"title":"Image Processing"}},{"id":1054724,"guid":"77CB5D0919B14D618C350585FB00C85E","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Example code of background removal execution.\n<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"># load meta data frame from file<\/div><div class = \"text-block\">data = pd.read_pickle((data_path + 'data.pkl'))<\/div><div class = \"text-block\"># loop over all images <\/div><div class = \"text-block\">for i in range(len(data)):<\/div><div class = \"text-block\">    clear_output()<\/div><div class = \"text-block\">    print('sample',k+1,'processing file ',i+1,' of ',len(data))<\/div><div class = \"text-block\">    # read respective image<\/div><div class = \"text-block\">    # read + rotate original image<\/div><div class = \"text-block\">    img = cv2.imread((source_path + 'frame_%s.TIFF'%i),0)<\/div><div class = \"text-block\">    img = skimage.transform.rotate(img,data.angle.median(),resize=False)<\/div><div class = \"text-block\">    img = img_as_ubyte(img)<\/div><div class = \"text-block\">    # invert image <\/div><div class = \"text-block\">    img = 255 - img<\/div><div class = \"text-block\">    # read chamber images<\/div><div class = \"text-block\">    img_cham_A = cv2.imread((source_path + '00_WT\/frame_%s_WT.TIFF'%i),0)<\/div><div class = \"text-block\">    img_cham_B = cv2.imread((source_path + '01_MT\/frame_%s_MT.TIFF'%i),0)<\/div><div class = \"text-block\">    # invert chamber images<\/div><div class = \"text-block\">    img_cham_A = 255 - img_cham_A<\/div><div class = \"text-block\">    img_cham_B = 255 - img_cham_B<\/div><div class = \"text-block\">    # rotate chamber images 90\u00b0<\/div><div class = \"text-block\">    img_cham_A = np.array([list(i) for i in zip(*img_cham_A)], dtype=np.int16)<\/div><div class = \"text-block\">    img_cham_B = np.array([list(i) for i in zip(*img_cham_B)], dtype=np.int16)<\/div><div class = \"text-block\">    # cut reference space (+ invert)<\/div><div class = \"text-block\">    refspace = img[data.line3[i]:data.line3[i]+100, 10:len(img[0])-10]<\/div><div class = \"text-block\">    # rotate refspace 90\u00b0<\/div><div class = \"text-block\">    refspace90 = np.array([list(i) for i in zip(*refspace)], dtype=np.int16)<\/div><div class = \"text-block\">    # calculate median intensity of background<\/div><div class = \"text-block\">    background = np.zeros(len(refspace90))<\/div><div class = \"text-block\">    for j in range(len(refspace90)):<\/div><div class = \"text-block\">        background[j] = np.median(refspace90[j])<\/div><div class = \"text-block\">    background = np.array(background,dtype=np.int16)<\/div><div class = \"text-block\">    # create new empty image<\/div><div class = \"text-block\">    cham_A_new = np.zeros(img_cham_A.shape, dtype=np.int16)<\/div><div class = \"text-block\">    cham_B_new = np.zeros(img_cham_B.shape, dtype=np.int16)<\/div><div class = \"text-block\">    # subtract background<\/div><div class = \"text-block\">    for l in range(len(background)):<\/div><div class = \"text-block\">        cham_A_new[l] = img_cham_A[l] - background[l]<\/div><div class = \"text-block\">        cham_B_new[l] = img_cham_B[l] - background[l]<\/div><div class = \"text-block\">    # rotate and invert new images back to 0\u00b0<\/div><div class = \"text-block\">    cham_A_new = 255 - np.array([list(i) for i in zip(*cham_A_new)], \\     <\/div><div class = \"text-block\">                                dtype=np.int16).clip(0, 255)<\/div><div class = \"text-block\">    cham_B_new = 255 - np.array([list(i) for i in zip(*cham_B_new)], \\<\/div><div class = \"text-block\">                                dtype=np.int16).clip(0, 255)<\/div><div class = \"text-block\">    # save images to folder<\/div><div class = \"text-block\">    cv2.imwrite((target_path[k] + '00_WT\/frame_%s_WT.TIFF'%i),cham_A_new)<\/div><div class = \"text-block\">    cv2.imwrite((target_path[k] + '01_MT\/frame_%s_MT.TIFF'%i),cham_B_new)<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":866774,"guid":"352D64B0306C11EA86CEDD1E387C8850","previous_id":866773,"previous_guid":"0FFBC1A0306C11EA86CEDD1E387C8850","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"8661E555B97746F9B3916EC98594BF2F","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calculation of Pixel Intensity"}},{"id":1054724,"guid":"C5DFBF74C06C428A99FA6C74C54C76B5","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>The mean pixel intensity I<\/span><span style = \"vertical-align:sub;\">pix<\/span><span> (i. e. gray scale value; reflecting cell density) for each of the two chambers is calculated. The values are added into the respective data frame. Growth rates \u00b5 are derived from I<\/span><span style = \"vertical-align:sub;\">pix<\/span><span> using the central difference approximation below.<\/span><\/div><div style = \"text-align :; float : ;\"><span style = \"\">\\mu(t_{\\rm i}) = \\frac{I_{\\rm pix}(t_{\\rm i+1}) - I_{\\rm pix}(t_{\\rm i-1})}{\\left(t_{\\rm i+1}-t_{\\rm i-1}\\right)\\cdot I_{\\rm pix}(t_{\\rm i})}<\/span><\/div><div class = \"text-block\"><span>Legend: \u00b5(t<\/span><span style = \"vertical-align:sub;\">i<\/span><span>) - growth rate \u00b5 at time point t<\/span><span style = \"vertical-align:sub;\">i, <\/span><span style = \"vertical-align:sub;vertical-align:sub;\">I<\/span><span style = \"vertical-align:sub;\">pix<\/span><span>(t<\/span><span style = \"vertical-align:sub;\">i<\/span><span>) - mean pixel intensity at time point t<\/span><span style = \"vertical-align:sub;\">i<\/span><span>, i - i<\/span><span style = \"vertical-align:super;\">th<\/span><span> measurement<\/span><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":866782,"guid":"016DEA40307C11EA86CEDD1E387C8850","previous_id":866774,"previous_guid":"352D64B0306C11EA86CEDD1E387C8850","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"2AABE20EF9B34F3BBC8960874E8053BE","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calculation of Pixel Intensity"}},{"id":1054724,"guid":"A6674B6420E945F7AD63ED8578A9E9BC","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Import of the required packages.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">import numpy as np<\/div><div class = \"text-block\">import pandas as pd<\/div><div class = \"text-block\">import skimage<\/div><div class = \"text-block\">from skimage import img_as_float<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":866787,"guid":"7C880B70307C11EA86CEDD1E387C8850","previous_id":866782,"previous_guid":"016DEA40307C11EA86CEDD1E387C8850","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"C1AB14BF790D4698AA712CC16C9ABC96","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calculation of Pixel Intensity"}},{"id":1054724,"guid":"EEFF28FB4C024F43AD41AF57A8EFCA3F","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Example code of Mean Pixel Intensity Calculation.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">data = pd.read_pickle((data_path + 'data.pkl'))<\/div><div class = \"text-block\"># create time column (within this batch: measurements every 20min -> index \/ 3)<\/div><div class = \"text-block\">data['time'] = data.index \/ 3 # [h]<\/div><div class = \"text-block\">meanGrayWT, meanGrayMT, \\<\/div><div class = \"text-block\">varGrayWT, varGrayMT = [np.zeros(len(data)) for i in range(4)]<\/div><div class = \"text-block\">for k in range(len(data)):<\/div><div class = \"text-block\">    imgWT = 1 - img_as_float(skimage.io.imread((source_path + \\<\/div><div class = \"text-block\">                                                '00_WT\/frame_%s_WT.TIF'%k)))<\/div><div class = \"text-block\">    imgMT = 1 - img_as_float(skimage.io.imread((source_path + \\<\/div><div class = \"text-block\">                                                '01_MT\/frame_%s_MT.TIF'%k)))<\/div><div class = \"text-block\">    meanGrayWT[k] = np.mean(imgWT)<\/div><div class = \"text-block\">    meanGrayMT[k] = np.mean(imgMT)<\/div><div class = \"text-block\">data['greyWTint'] = meanGrayWT<\/div><div class = \"text-block\">data['greyMTint'] = meanGrayMT<\/div><div class = \"text-block\">data['greyWTmu'] = np.gradient(data.greyWTint) \/ data.greyWTint * 3<\/div><div class = \"text-block\">data['greyMTmu'] = np.gradient(data.greyMTint) \/ data.greyMTint * 3<\/div><div class = \"text-block\">data.to_pickle((data_path + 'data.pkl'))<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":867079,"guid":"3C0854D0313811EAA151BB7C194AC638","previous_id":866787,"previous_guid":"7C880B70307C11EA86CEDD1E387C8850","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"31137B8DC6C34419948696AABA4342EA","order_id":1,"type_id":6,"title":"Section","source":{"title":"Calculation of Pixel Intensity"}},{"id":1054724,"guid":"C21A275DEF3C4155802B7CF0B14D75C2","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Visualisation of the calculated data.<\/div><div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/protocols-files.s3.amazonaws.com\/private\/40242a8afacdec91e823540962334878ee79175d9206d3caefbdb35b8cb49603\/bwjwbatvp.png?X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJYFAX46LHRVQMGOA%2F20200129%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20200129T171719Z&X-Amz-SignedHeaders=host&X-Amz-Expires=604800&X-Amz-Signature=9e3308a036db8757150dbe35dcf0a04e7d998d4e3d8d69c72e07be23f5555ed2\" \/><\/div><\/div>"}},{"id":1054725,"guid":"A4D9F2986B4C4E1B9470ED965B329F9F","order_id":2,"type_id":1,"title":"description","source":{"description":"<div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/protocols-files.s3.amazonaws.com\/private\/40242a8afacdec91e823540962334878ee79175d9206d3caefbdb35b8cb49603\/bwjwbatvp.png?X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJYFAX46LHRVQMGOA%2F20200129%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20200129T171719Z&X-Amz-SignedHeaders=host&X-Amz-Expires=604800&X-Amz-Signature=9e3308a036db8757150dbe35dcf0a04e7d998d4e3d8d69c72e07be23f5555ed2\" \/><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":871728,"guid":"18721B403D0A11EA91699399F902DDAE","previous_id":862330,"previous_guid":"2067C33020D711EA92722F2FFC6247C2","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"94C7BAF701AA469A8D3D2D8CAA5B4B88","order_id":1,"type_id":6,"title":"Section","source":{"title":"Image Processing"}},{"id":1054724,"guid":"7A18D5DED6D746E6A99FA6833FBC9867","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span style = \"font-weight:bold;\">Automated Image Rotation<\/span><\/div><div class = \"text-block\">Image processing required vertical aligned chamber edges (Fig. 2.1-A). Unaligned video frames would result in peak values scattered in X-direction (conferring to Fig. 2.1-C and D). In order to gain vertical alignment, the rotation angle is estimated by minimising the peak width in X-direction by using a basin-hopping algorithm (scipy.optimize.basinhopping). Standard settings of the package are applied with respect to the convergence criteria. Initial rotation angle is set to 0\u00b0 for all frames.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":871729,"guid":"9EED23903D0A11EA91699399F902DDAE","previous_id":871728,"previous_guid":"18721B403D0A11EA91699399F902DDAE","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"997DB16A3EA54146ABD94863AAEB78B6","order_id":1,"type_id":6,"title":"Section","source":{"title":"Image Processing"}},{"id":1054724,"guid":"F46DB003914B4DB09E43F5BECFC9438F","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Import of the required packages.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">import numpy as np<\/div><div class = \"text-block\">import pandas as pd<\/div><div class = \"text-block\">import cv2<\/div><div class = \"text-block\">import skimage<\/div><div class = \"text-block\">import scipy<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":871730,"guid":"D0F202703D0A11EA91699399F902DDAE","previous_id":871729,"previous_guid":"9EED23903D0A11EA91699399F902DDAE","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"77B42D04676C4C1F99074405C80E71E2","order_id":1,"type_id":6,"title":"Section","source":{"title":"Image Processing"}},{"id":1054724,"guid":"3D07552AE1D54596A6A63DB48698F606","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Example code of the Automated Image Rotation definition.<\/div><div class = \"text-block\">Strategy:<\/div><div class = \"text-block\"><ol style = \"list-style-type: decimal;\"><li style = \"counter-reset:ol0;\">calculate the median pixel intensity along the y-axis of image<\/li><li style = \"counter-reset:ol0;\">create derivative of median values (absolute values) to find the change in median pixel intensity along y-axis of image<\/li><li style = \"counter-reset:ol0;\">select peak values (representing position of chamber lines \/ peak width correlates to slope of chamber line)<\/li><li style = \"counter-reset:ol0;\">rotate image to minimise the peak width<\/li><\/ol><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">def score(a):<\/div><div class = \"text-block\">    # rotate image by given angle 'a'<\/div><div class = \"text-block\">    img_rot = skimage.transform.rotate(img,a,resize=True)<\/div><div class = \"text-block\">    # calculate median of pixel intensity along the y-axis of image<\/div><div class = \"text-block\">    xmedian = np.zeros(len(img_rot))<\/div><div class = \"text-block\">    for i in range(len(img_rot)):<\/div><div class = \"text-block\">        xmedian[i] = np.median(img_rot[i])<\/div><div class = \"text-block\">    # add median values to data frame <\/div><div class = \"text-block\">    df = pd.DataFrame(data={'xmedian':xmedian})<\/div><div class = \"text-block\">    # create derivative along the median values (absolute values)<\/div><div class = \"text-block\">    # 'xdiff' represents change in median pixel intensity along y-axis of image<\/div><div class = \"text-block\">    df['xdiff'] = pd.DataFrame.diff(df.xmedian, periods=1, axis=0).abs()<\/div><div class = \"text-block\">    # select 'xdiff' values >= 98% percentile  to new data frame<\/div><div class = \"text-block\">    qdf = df[df.xdiff >= np.nanpercentile(df.xdiff,98)]<\/div><div class = \"text-block\">    qdf = qdf.reset_index()<\/div><div class = \"text-block\">    qdf.rename(columns={'index':'imgdex'},inplace=True)<\/div><div class = \"text-block\">    # cluster selected xdiff values into 4 clusters <\/div><div class = \"text-block\">    # (representing the position of camber lines in y-direction)<\/div><div class = \"text-block\">    qdf['cluster'] = pd.cut(qdf.imgdex,4,right=True,labels=[0,1,2,3])<\/div><div class = \"text-block\">    # calculating the width of cluster <\/div><div class = \"text-block\">    imgdex = np.zeros(4)<\/div><div class = \"text-block\">    for i in range(4):<\/div><div class = \"text-block\">        imgdex[i] = qdf.imgdex[qdf.cluster == i].max() - \\<\/div><div class = \"text-block\">                    qdf.imgdex[qdf.cluster == i].min()<\/div><div class = \"text-block\">    imgdex = np.array(imgdex, dtype='float')<\/div><div class = \"text-block\">    # returning sum of cluster width    <\/div><div class = \"text-block\">    return imgdex.sum()<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0},{"id":871731,"guid":"7BCFC5103D0B11EA91699399F902DDAE","previous_id":871730,"previous_guid":"D0F202703D0A11EA91699399F902DDAE","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"240661AAC0324E8BA4AC82B8C03B8C71","order_id":1,"type_id":6,"title":"Section","source":{"title":"Image Processing"}},{"id":1054724,"guid":"B5D5C0168AD14703BB8E4E3F46F6E6D7","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Example code of Automated Image Rotation execution.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"># load meta data frame<\/div><div class = \"text-block\">data = pd.read_pickle((data_path + 'data.pkl'))<\/div><div class = \"text-block\"># loop over all images<\/div><div class = \"text-block\">angle = np.zeros(len(data))<\/div><div class = \"text-block\">for i in range(len(data)):<\/div><div class = \"text-block\">    # read respective image and invert<\/div><div class = \"text-block\">    img =  255 - skimage.io.imread((source_path + 'frame_%s.TIF'%i))<\/div><div class = \"text-block\">    # estimate rotation angle using basinhopping initial rotation angle = 0\u00b0<\/div><div class = \"text-block\">    answ = scipy.optimize.basinhopping(score,0,niter=200)<\/div><div class = \"text-block\">    angle[i] = answ.x[0]<\/div><div class = \"text-block\"># append angles to meta data frame + save data frame to file<\/div><div class = \"text-block\">data['angle'] = angle<\/div><div class = \"text-block\">data.to_pickle((data_path + 'data.pkl'))<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","section_duration":0,"critical":null,"critical_id":null,"duration":0}],"document":null,"materials":[],"description":"<div class = \"text-blocks\"><div class = \"text-block\">Biofilm formation under shear flow conditions was monitored using the Bioflux1000 device (Fluxion Biosciences, Inc.). In short, Candida albicans overnight cultures were washed in pre-warmed RPMI medium. Cells were seeded for 2-5 sec from the outlet well into the channels of Bioflux1000 flow chambers, which were primed before with warm medium. The cells were allowed to adhere to the channels for 90 min without any flow, followed by removal of non-adherent cells by flowing fresh, pre-warmed RPMI medium for 5 sec. Shear flow was set for time series experiments over 24 h biofilm formation and images were captured every 20 min. Two channels were investigated in parallel having a 10 \u00d7 magnification to allow a direct comparison between a mutant and a reference (wild-type) strain. Image capturing and stacks to movies was performed using the MetaMorph\u00ae Software (Molecular Devices).<\/div><div class = \"text-block\">Source material provided as AVI files was converted into single TIFF images as well as data frames containing meta data annotations. The individual image contains two growth chambers (wild type and mutant) separated by four edge lines. Images were rotated automatically to vertical alignment in order to carry out an automated chamber detection and analysis. The mean pixel intensity (i. e. grey scale value; reflecting cell density) of the individual chamber was calculated and added into the respective data frame. <\/div><div class = \"text-block\">All computations were performed using the programming language python (version 3.6.9) and the additional packages numpy (version 1.16.2), opencv-python (version 4.1.1.26), pandas (version 0.25.0) and scikit-image (version 0.15.0).<\/div><\/div>","changed_on":1580737455}