{"uri":"introduction-to-blast-and-protein-homology-searche-qfudtnw","version_id":"2","protocol_name":"Introduction to BLAST and protein homology searches","protocol_name_html":"Introduction to BLAST and protein homology searches","is_prepublished":"0","can_edit":"0","parent_id":"11558","api_version":"1","is_new_mode":"0","last_modified":"1527268428","type_id":"1","link":null,"fork_id":"","public_fork_note":"","number_of_steps":"8","has_versions":"1","first_published_date":"1527268428","publish_date":"2018-05-25 17:13:48","documents":null,"have_protocol_in_step":"0","is_protocol_in_step":"0","vendor_name":"Contributed by users","vendor_link":"https:\/\/www.protocols.io","vendor_logo":"\/img\/vendors\/1.png","mod_mins":"-42","mod_secs":"17","description":"<p><strong>This is a short tutorial on the basics of getting started with standalone BLAST+ in the Ubuntu command line.<\/strong><\/p>\n<p>Code is intended for use on an Ubuntu 16.04 LTS OS.<\/p>\n<p>\u00a0<\/p>\n<p>Note that a web server for BLASTP is also available: https:\/\/blast.ncbi.nlm.nih.gov\/Blast.cgi?PROGRAM=blastp&amp;PAGE_TYPE=BlastSearch&amp;LINK_LOC=blasthome<\/p>\n<p>\u00a0<\/p>\n<p>For details on BLAST please see the NCBI webpage and release notes:\u00a0https:\/\/www.ncbi.nlm.nih.gov\/books\/NBK131777\/<\/p>\n<p>And the NCBI paper on BLAST+: https:\/\/www.ncbi.nlm.nih.gov\/pubmed\/20003500?dopt=Citation<\/p>","is_bookmarked":"0","can_reassign":"1","before_start":null,"has_guidelines":"0","materials":[],"warning":null,"version_class":"11558","public":"1","is_owner":"1","is_original_owner":"1","created_on":"1527256497","protocol_affiliation":"Virginia Tech","affiliation":"Virginia Tech","doi":"dx.doi.org\/10.17504\/protocols.io.qfudtnw","doi_status":"2","changed_fork_steps":null,"profile_url":"FrankAylward-y22344v2x2","protocol_img":"https:\/\/www.protocols.io\/img\/default_protocol.png","profile_image":"https:\/\/s3.amazonaws.com\/pr-journal\/v39jtte.png","full_name":"Frank Aylward","created_by":"Frank Aylward","private_link":"283C1C1EDFE0BD668BD268A7E96E8BBE","original_img":"1","username":"frank-aylward","is_retracted":"0","retraction_reason":null,"plos_id":null,"manuscript_citation":null,"journal_name":null,"is_donations_disabled":"0","is_donations_disabled_by_user":"9","item_record_id":317252,"fork_info":[],"compare_forks":[],"protocols":[],"groups":[],"number_of_shared_runs":[],"ownership_history":[],"keywords":"","transfer_to_user":[],"sub_transfer":false,"is_transfer_pending":false,"number_of_bookmarks":"0","collections":[],"tags":[],"archived":0,"sub_authors":[],"sub_protocols_number":0,"can_edit_shared":0,"shared_runs":[],"is_shared_run":0,"is_shared":1,"banner":null,"contact_badges":[{"badge_id":"4","badge_image":"\/img\/badges\/gold.svg","badge_description":"Gold power author!"}],"number_of_comments":0,"is_locked":0,"is_locked_by":false,"authors":"Frank Aylward","authors_list":[{"name":"Frank Aylward","affiliation":"Virginia Tech","username":null,"profile_image":null}],"user":{"profile_image":"https:\/\/s3.amazonaws.com\/pr-journal\/v39jtte.png","username":"frank-aylward","full_name":"Frank Aylward","created_by":"Frank Aylward"},"access":{"can_view":"1","can_remove":"0","can_add":"0","can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":"0","can_move":"1","can_transfer":"1","can_download":"1","is_locked":"0"},"is_contact_suspended":0,"guidelines":null,"status_id":"1","is_research":"0","status_info":"We use this protocol in our group and it is working","steps":[{"id":"631587","is_changed":1,"original_id":"622441","is_skipped":"0","is_checked":"0","guid":"35FE9FB3A4034EAEADF0F4F75DF240EF","previous_guid":"E656E8D1825D40F3B74E696A9D6306AA","previous_id":"631590","last_modified":"1527257580","components":[{"component_id":"1115905","previous_id":0,"original_id":"1092483","guid":"6753546FC7A742B1BD0CB6F8CA18F41A","previous_guid":null,"component_type_id":"6","data_id":null,"data":"","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":""},"is_project":0},{"component_id":"1115906","previous_id":"1115905","original_id":"1092484","guid":"3CC9CFD10FA643A0AB94831667BDFDFC","previous_guid":"6753546FC7A742B1BD0CB6F8CA18F41A","component_type_id":"1","data_id":null,"data":"<p>Now that we have BLAST installed we need to download some data to start analyzing. Here we will use proteins predicted from the genomes of two <em>Prochlorococcus<\/em> bacteriophage genomes. We can use the wget command, which is already available as part of the base Ubuntu command line. Wget allows us to download files from a web server directly into the folder we are working in, and we need to know the URL for the file in order to do this. The National Center for Biotechnology Information (NCBI) has many genomes and genome-related datasets that it posts for researchers to use, and I have gone through and found the appropriate URLs to use here.\u00a0<\/p>\n<p>Here are the commands:<\/p>\n<p>\u00a0<\/p>\n<p><strong>wget -O\u00a0prochlorococcus_phage_PSSM2.faa.gz ftp:\/\/ftp.ncbi.nlm.nih.gov\/geno<\/strong><strong>mes\/all\/GCF\/000\/859\/585\/GCF_000859585.1_ViralProj15135\/GCF_000859585.1_ViralProj15135_protein.faa.gz<\/strong><\/p>\n<p>\u00a0<\/p>\n<p><strong>wget -O prochlorococcus_phage_PSSM3.faa.gz ftp:\/\/ftp.ncbi.nlm.nih.gov\/genomes\/all\/GCF\/000\/907\/775\/GCF_000907775.1_ViralProj209210\/GCF_000907775.1_ViralProj209210_protein.faa.gz<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>The -O flag specifies the file names that we want the downloads to be called. Without this flag wget would give the downloaded file the same names that they are given on the website, and sometimes these names can be quite long.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>The above commands should download one gzip file each (extension .gz). Gzip files are commonly used for compressing data on Linux systems. Before we use them here we\u00a0will have to uncompress them with the gunzip command<\/p>\n<p><strong>gunzip<\/strong> <strong>prochlorococcus_phage_PSSM2.faa.gz<\/strong><\/p>\n<p><strong>gunzip prochlorococcus_phage_PSSM3.faa.gz<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>After this we should have two .faa files. To check this we can use the ls command:<\/p>\n<p><strong>ls\u00a0<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>And we should see something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yd8jtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yd7jtte.png\" data-ofn=\"Screenshot (3).png\" \/><\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Now that we have BLAST installed we need to download some data to start analyzing. Here we will use proteins predicted from the genomes of two <em>Prochlorococcus<\/em> bacteriophage genomes. We can use the wget command, which is already available as part of the base Ubuntu command line. Wget allows us to download files from a web server directly into the folder we are working in, and we need to know the URL for the file in order to do this. The National Center for Biotechnology Information (NCBI) has many genomes and genome-related datasets that it posts for researchers to use, and I have gone through and found the appropriate URLs to use here.\u00a0<\/p>\n<p>Here are the commands:<\/p>\n<p>\u00a0<\/p>\n<p><strong>wget -O\u00a0prochlorococcus_phage_PSSM2.faa.gz ftp:\/\/ftp.ncbi.nlm.nih.gov\/geno<\/strong><strong>mes\/all\/GCF\/000\/859\/585\/GCF_000859585.1_ViralProj15135\/GCF_000859585.1_ViralProj15135_protein.faa.gz<\/strong><\/p>\n<p>\u00a0<\/p>\n<p><strong>wget -O prochlorococcus_phage_PSSM3.faa.gz ftp:\/\/ftp.ncbi.nlm.nih.gov\/genomes\/all\/GCF\/000\/907\/775\/GCF_000907775.1_ViralProj209210\/GCF_000907775.1_ViralProj209210_protein.faa.gz<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>The -O flag specifies the file names that we want the downloads to be called. Without this flag wget would give the downloaded file the same names that they are given on the website, and sometimes these names can be quite long.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>The above commands should download one gzip file each (extension .gz). Gzip files are commonly used for compressing data on Linux systems. Before we use them here we\u00a0will have to uncompress them with the gunzip command<\/p>\n<p><strong>gunzip<\/strong> <strong>prochlorococcus_phage_PSSM2.faa.gz<\/strong><\/p>\n<p><strong>gunzip prochlorococcus_phage_PSSM3.faa.gz<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>After this we should have two .faa files. To check this we can use the ls command:<\/p>\n<p><strong>ls\u00a0<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>And we should see something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yd8jtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yd7jtte.png\" data-ofn=\"Screenshot (3).png\" \/><\/p>"},"is_project":0}],"available_protocols":["11573"]},{"id":"631588","is_changed":1,"original_id":"622442","is_skipped":"0","is_checked":"0","guid":"24D6EF9B083A4DB8A3DF6B85FD38FEE8","previous_guid":"35FE9FB3A4034EAEADF0F4F75DF240EF","previous_id":"631587","last_modified":"1527258104","components":[{"component_id":"1115907","previous_id":0,"original_id":"1092485","guid":"3B8836A606C54788BF8F8168A7851143","previous_guid":null,"component_type_id":"6","data_id":null,"data":"","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":""},"is_project":0},{"component_id":"1115908","previous_id":"1115907","original_id":"1092486","guid":"695F5D06D1514484A32CA6D6BF1AED57","previous_guid":"3B8836A606C54788BF8F8168A7851143","component_type_id":"1","data_id":null,"data":"<p>Now that we have the files downloaded and in the right format, we can get some basic stats about their format and content. FASTA files are formatted such that sequences are always preceded by a \"header\" line that starts with \"&gt;\". This line contains information about the name of the sequence, and possibly other information.\u00a0<\/p>\n<p>Because every sequence starts with a \"&gt;\" character, we can count how many protein sequences are in a file by counting the number of lines that start with \"&gt;\". The Unix command to do this is grep, and the commands look like this:<\/p>\n<p>\u00a0<\/p>\n<p><strong>grep '^&gt;' prochlorococcus_phage_PSSM2.faa | wc<\/strong><\/p>\n<p>or<\/p>\n<p><strong>grep '^&gt;' prochlorococcus_phage_PSSM3.faa | wc<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>The '^' symbol that precedes the \"&gt;\" tells grep that we are only looking for \"&gt;\" symbols at the start of the line. At the end, the \"| wc\" tells the command line to pipe the output of grep to a wc command. You can play around with these commands and remove the pipe at the end- you should find that grep returns each header line that starts wtih \"&gt;\". For purposes here we don't want to see each line individually, we just want to count how many there are. The wc command returns the number of lines, characters, and bytes are in the input, so here this would equal the number of headers in a the FASTA files. The output should look something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yebjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yeajtte.png\" data-ofn=\"Screenshot (4).png\" \/><\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Now that we have the files downloaded and in the right format, we can get some basic stats about their format and content. FASTA files are formatted such that sequences are always preceded by a \"header\" line that starts with \"&gt;\". This line contains information about the name of the sequence, and possibly other information.\u00a0<\/p>\n<p>Because every sequence starts with a \"&gt;\" character, we can count how many protein sequences are in a file by counting the number of lines that start with \"&gt;\". The Unix command to do this is grep, and the commands look like this:<\/p>\n<p>\u00a0<\/p>\n<p><strong>grep '^&gt;' prochlorococcus_phage_PSSM2.faa | wc<\/strong><\/p>\n<p>or<\/p>\n<p><strong>grep '^&gt;' prochlorococcus_phage_PSSM3.faa | wc<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>The '^' symbol that precedes the \"&gt;\" tells grep that we are only looking for \"&gt;\" symbols at the start of the line. At the end, the \"| wc\" tells the command line to pipe the output of grep to a wc command. You can play around with these commands and remove the pipe at the end- you should find that grep returns each header line that starts wtih \"&gt;\". For purposes here we don't want to see each line individually, we just want to count how many there are. The wc command returns the number of lines, characters, and bytes are in the input, so here this would equal the number of headers in a the FASTA files. The output should look something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yebjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yeajtte.png\" data-ofn=\"Screenshot (4).png\" \/><\/p>"},"is_project":0}],"available_protocols":["11573"]},{"id":"631589","is_changed":1,"original_id":"622443","is_skipped":"0","is_checked":"0","guid":"3F9BDDEA86E448AC992341B590B4BB1F","previous_guid":"24D6EF9B083A4DB8A3DF6B85FD38FEE8","previous_id":"631588","last_modified":"1527266158","components":[{"component_id":"1115909","previous_id":0,"original_id":"1092487","guid":"144A02FEE0AE4866B6562DE76608DD92","previous_guid":null,"component_type_id":"1","data_id":null,"data":"<p>Now that we have some basic information about the files we can begin formatting them for BLASTP.<\/p>\n<p>For any search BLAST needs one FASTA file to be specified as the query, and one to be specified as the reference. Before running BLAST the reference needs to be formatted using a command called makeblastdb, which is part of the BLAST package and should have bee installed above. Makeblastdb\u00a0takes a FASTA file as input and produces several files with different extensions that can be used as reference databases.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p><strong>makeblastdb -in prochlorococcus_phage_PSSM2.faa -dbtype prot<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>the -in flag specified the FASTA file to be formatted, and the -dbtype flag specifies the molecule type (prot for protein and nucl for nucleic acid).\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>If we check the folder after running the above command we should see a number of new files with the prefix prochlorococcus_phage_PSSM2.faa and several new suffixes. Something like this:<\/p>\n<p>\u00a0<img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yetjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yesjtte.png\" data-ofn=\"Screenshot (5).png\" \/><\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>","order_id":"0","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Now that we have some basic information about the files we can begin formatting them for BLASTP.<\/p>\n<p>For any search BLAST needs one FASTA file to be specified as the query, and one to be specified as the reference. Before running BLAST the reference needs to be formatted using a command called makeblastdb, which is part of the BLAST package and should have bee installed above. Makeblastdb\u00a0takes a FASTA file as input and produces several files with different extensions that can be used as reference databases.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p><strong>makeblastdb -in prochlorococcus_phage_PSSM2.faa -dbtype prot<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>the -in flag specified the FASTA file to be formatted, and the -dbtype flag specifies the molecule type (prot for protein and nucl for nucleic acid).\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>If we check the folder after running the above command we should see a number of new files with the prefix prochlorococcus_phage_PSSM2.faa and several new suffixes. Something like this:<\/p>\n<p>\u00a0<img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yetjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yesjtte.png\" data-ofn=\"Screenshot (5).png\" \/><\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>"},"is_project":0},{"component_id":"1115910","previous_id":"1115909","original_id":"1092488","guid":"06279CBFE10948CE965D374009B16349","previous_guid":"144A02FEE0AE4866B6562DE76608DD92","component_type_id":"6","data_id":null,"data":"","order_id":"1","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":""},"is_project":0}],"available_protocols":["11573"]},{"id":"631590","is_changed":1,"original_id":"622444","is_skipped":"0","is_checked":"0","guid":"E656E8D1825D40F3B74E696A9D6306AA","previous_guid":null,"previous_id":null,"last_modified":"1527256874","components":[{"component_id":"1115911","previous_id":0,"original_id":"1092489","guid":"8DB379E8F0B64E9A944DDE06573A8BF7","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Make sure the right tools are installed first","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Make sure the right tools are installed first"},"is_project":0},{"component_id":"1115912","previous_id":"1115911","original_id":"1092490","guid":"D5E6F3B08805493296F5734436FCD579","previous_guid":"8DB379E8F0B64E9A944DDE06573A8BF7","component_type_id":"1","data_id":null,"data":"<p><strong>Command to be entered into the command line are in bold<\/strong><\/p>\n<p>Comments are in regular typeface<\/p>\n<p>\u00a0<\/p>\n<p>We'll be using the BLASTP tool in the BLAST+ suite.<\/p>\n<p>On an Ubuntu 16.06 system If you need to install this first, type:<\/p>\n<p><strong>sudo apt install ncbi-blast+<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>You will be asked if you wish to continue after you are told how much space it will take up. To proceed type 'Y'.<\/p>\n<p>It may take a minute or two to finish installing.\u00a0<\/p>\n<p>Then, to view the abbreviated usage and flags, type:<\/p>\n<p><strong>blastp -h<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>And you should see short-form instructions for the general usage and different options, something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yd2jtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/ydzjtte.png\" data-ofn=\"Screenshot (1).png\" \/><\/p>\n<p>\u00a0<\/p>\n<p>For long form instructions you can type the following:<\/p>\n<p><strong>blastp -help<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>And you will see a very long list of all the options and what they mean (this will take up more than one screen full, so you will need to scroll up after the text finishes printing to the screen to see everything).\u00a0<\/p>\n<p>The bottom of this long usage guide should look something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yd4jtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yd3jtte.png\" data-ofn=\"Screenshot (2).png\" \/><\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>We will go over some of the commonly-used commands in this tutorial, but it is always worthwhile to look at all of the available options, play around with different parameters, and see how the results can be changed.\u00a0<\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p><strong>Command to be entered into the command line are in bold<\/strong><\/p>\n<p>Comments are in regular typeface<\/p>\n<p>\u00a0<\/p>\n<p>We'll be using the BLASTP tool in the BLAST+ suite.<\/p>\n<p>On an Ubuntu 16.06 system If you need to install this first, type:<\/p>\n<p><strong>sudo apt install ncbi-blast+<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>You will be asked if you wish to continue after you are told how much space it will take up. To proceed type 'Y'.<\/p>\n<p>It may take a minute or two to finish installing.\u00a0<\/p>\n<p>Then, to view the abbreviated usage and flags, type:<\/p>\n<p><strong>blastp -h<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>And you should see short-form instructions for the general usage and different options, something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yd2jtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/ydzjtte.png\" data-ofn=\"Screenshot (1).png\" \/><\/p>\n<p>\u00a0<\/p>\n<p>For long form instructions you can type the following:<\/p>\n<p><strong>blastp -help<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>And you will see a very long list of all the options and what they mean (this will take up more than one screen full, so you will need to scroll up after the text finishes printing to the screen to see everything).\u00a0<\/p>\n<p>The bottom of this long usage guide should look something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yd4jtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yd3jtte.png\" data-ofn=\"Screenshot (2).png\" \/><\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>We will go over some of the commonly-used commands in this tutorial, but it is always worthwhile to look at all of the available options, play around with different parameters, and see how the results can be changed.\u00a0<\/p>"},"is_project":0}],"available_protocols":["11573"]},{"id":"631591","is_changed":1,"original_id":"622445","is_skipped":"0","is_checked":"0","guid":"5754DA70A1284AB28E4532658065ABA0","previous_guid":"3F9BDDEA86E448AC992341B590B4BB1F","previous_id":"631589","last_modified":"1527266507","components":[{"component_id":"1115913","previous_id":0,"original_id":"1092491","guid":"2C96CA5D3BF84DD99DBEB113742EBD74","previous_guid":null,"component_type_id":"1","data_id":null,"data":"<p>Now that we have one file formatted as a reference database we can run BLASTP, using the other FASTA file as the query.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p><strong>blastp -query prochlorococcus_phage_PSSM3.faa -db prochlorococcus_phage_PSSM2.faa | head -n 100<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>The output here is quite long, so we can pipe the output into a head command so we see only last 100 lines. You should see something like this (note not all 100 lines are shown below).\u00a0<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yevjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yeujtte.png\" data-ofn=\"Screenshot (6).png\" \/><\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Note that there is a lot of information in this output. The program name and information are provided, and there is information on the query and reference databases used. The alignments that were calculated are also provided- you can see the top of one in the image above, and you can scroll to inspect it when you run it yourself. Note that this information is provided for every alignment that could be calculated for each protein in the query file, so if we had put this output into a file it would be quite large.\u00a0<\/p>","order_id":"0","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Now that we have one file formatted as a reference database we can run BLASTP, using the other FASTA file as the query.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p><strong>blastp -query prochlorococcus_phage_PSSM3.faa -db prochlorococcus_phage_PSSM2.faa | head -n 100<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>The output here is quite long, so we can pipe the output into a head command so we see only last 100 lines. You should see something like this (note not all 100 lines are shown below).\u00a0<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yevjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yeujtte.png\" data-ofn=\"Screenshot (6).png\" \/><\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Note that there is a lot of information in this output. The program name and information are provided, and there is information on the query and reference databases used. The alignments that were calculated are also provided- you can see the top of one in the image above, and you can scroll to inspect it when you run it yourself. Note that this information is provided for every alignment that could be calculated for each protein in the query file, so if we had put this output into a file it would be quite large.\u00a0<\/p>"},"is_project":0},{"component_id":"1115914","previous_id":"1115913","original_id":"1092492","guid":"800BB23C7B8346D6933B02B9B2821741","previous_guid":"2C96CA5D3BF84DD99DBEB113742EBD74","component_type_id":"6","data_id":null,"data":"","order_id":"1","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":""},"is_project":0}],"available_protocols":["11573"]},{"id":"631592","is_changed":1,"original_id":"622446","is_skipped":"0","is_checked":"0","guid":"AB16F056B0744847B169110A1B602E59","previous_guid":"5754DA70A1284AB28E4532658065ABA0","previous_id":"631591","last_modified":"1527267224","components":[{"component_id":"1115915","previous_id":0,"original_id":"1092493","guid":"74F67C6A6DE74E438F25E8A1E4C5DBB3","previous_guid":null,"component_type_id":"6","data_id":null,"data":"","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":""},"is_project":0},{"component_id":"1115916","previous_id":"1115915","original_id":"1092494","guid":"DFC6473899494632AAEDEBD3B2ECCD4F","previous_guid":"74F67C6A6DE74E438F25E8A1E4C5DBB3","component_type_id":"1","data_id":null,"data":"<p>Since the output of the last step was quite extensive, we will want to find ways to simplify it.\u00a0<\/p>\n<p>Here is a similar command that will provide tab-delimited output (first 10 hits shown with the head command).\u00a0<\/p>\n<p><br \/><strong>blastp -query prochlorococcus_phage_PSSM3.faa -db prochlorococcus_phage_PSSM2.faa -outfmt 6 | head<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>You should see something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yewjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yewjtte.png\" data-ofn=\"Screenshot (7).png\" \/><\/p>\n<p>\u00a0<\/p>\n<p>A few notes on the output here:<\/p>\n<p>1) The format is tab-delimited, and the columns correspond to different statistics that were calculated for individual alignments. The columns are:\u00a0query protein, reference protein, % identity, alignment length, mismatches, gap opens, query start, query end, reference start, reference end, evalue, bit score<\/p>\n<p>2) Every protein in the query is compared to every protein in the reference, and all alignments are reported. So a protein in the query file could conceivable have alignments to multiple proteins in the reference (indeed, we see this in the image above). Also, multiple alignments that could be found between the same proteins are also shown (for example, if only the beginning and end of the amino acid sequences align, then two distinct alignmens will be provided).\u00a0<\/p>\n<p>3) Just becuase an alignment is reported does not mean it is 'real'. There are cases of 'spurious alignments' that could happend by random chance. We will need to investigate the statistics provided for each alignment to decide whether or not we think it's worth trusting.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Here are some additional parameters that will ensure that very poor alignments are not reported, and that only the best alignment for each query protein are given (for simplicity).\u00a0<br \/><strong>blastp -query prochlorococcus_phage_PSSM3.faa -db prochlorococcus_phage_PSSM2.faa -outfmt 6 -max_target_seqs 1 -evalue 0.00001 -max_hsps 1 -qcov_hsp_perc 50 | head<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>Different users will prefer different e-values and other cutoffs depending on what they are trying to do afterwards, their own comfort level, etc. As a common rule-of-thumb, e-values of 1e-3 and qe-5 are pretty common. For your own analyses you will need to use your own biological insight to decide for yourself what you are willing to trust and whether the results make sense.<\/p>\n<p>\u00a0<\/p>\n<p>Here is a breakdown of the flags used above:<br \/>\u00a0-query: this is the input file, so the file with all of the protein sequences that we want to search<\/p>\n<p><br \/>\u00a0-db: this is the database, so the file we just indexed with the makeblastdb command above. Note that makeblastdb creates multiple reference files and that only the root name needs to be given here (so if the database was called refdb, then refdb would be given here even though the index files are called refdb.pin, refdb.phr, etc.)<\/p>\n<p><br \/>\u00a0-max_target_seqs: This flat specifies that we only want the best hit for each query protein. Otherwise all hits are provided.<\/p>\n<p><br \/>\u00a0-outfmt: This specifies that we want the tab-delimited output format rather than the full alignment output. If you forget what the columns are you can use -outfmt 7.<\/p>\n<p><br \/>\u00a0-evalue: This indicates that we want to exclude all hits with evalues above this threshold. A good value is about 0.00001, or 1e-5.<\/p>\n<p><br \/>\u00a0max_hsps: HSPs are 'high-scoring segment pairs'. A query protein can make several separate alignments to a single reference, so this tells the program we want only the best-scoring alignment.<\/p>\n<p><br \/>\u00a0-qcov_hsp_perc: This is the 'query coverage high-scoring sequence pair percent', or the percent of the query protein that has to form an alignment against the reference to be retained. Higher values prevent spurious alignments of only a short portion of the query to a reference.<\/p>\n<p>\u00a0<\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Since the output of the last step was quite extensive, we will want to find ways to simplify it.\u00a0<\/p>\n<p>Here is a similar command that will provide tab-delimited output (first 10 hits shown with the head command).\u00a0<\/p>\n<p><br \/><strong>blastp -query prochlorococcus_phage_PSSM3.faa -db prochlorococcus_phage_PSSM2.faa -outfmt 6 | head<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>You should see something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yewjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yewjtte.png\" data-ofn=\"Screenshot (7).png\" \/><\/p>\n<p>\u00a0<\/p>\n<p>A few notes on the output here:<\/p>\n<p>1) The format is tab-delimited, and the columns correspond to different statistics that were calculated for individual alignments. The columns are:\u00a0query protein, reference protein, % identity, alignment length, mismatches, gap opens, query start, query end, reference start, reference end, evalue, bit score<\/p>\n<p>2) Every protein in the query is compared to every protein in the reference, and all alignments are reported. So a protein in the query file could conceivable have alignments to multiple proteins in the reference (indeed, we see this in the image above). Also, multiple alignments that could be found between the same proteins are also shown (for example, if only the beginning and end of the amino acid sequences align, then two distinct alignmens will be provided).\u00a0<\/p>\n<p>3) Just becuase an alignment is reported does not mean it is 'real'. There are cases of 'spurious alignments' that could happend by random chance. We will need to investigate the statistics provided for each alignment to decide whether or not we think it's worth trusting.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Here are some additional parameters that will ensure that very poor alignments are not reported, and that only the best alignment for each query protein are given (for simplicity).\u00a0<br \/><strong>blastp -query prochlorococcus_phage_PSSM3.faa -db prochlorococcus_phage_PSSM2.faa -outfmt 6 -max_target_seqs 1 -evalue 0.00001 -max_hsps 1 -qcov_hsp_perc 50 | head<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>Different users will prefer different e-values and other cutoffs depending on what they are trying to do afterwards, their own comfort level, etc. As a common rule-of-thumb, e-values of 1e-3 and qe-5 are pretty common. For your own analyses you will need to use your own biological insight to decide for yourself what you are willing to trust and whether the results make sense.<\/p>\n<p>\u00a0<\/p>\n<p>Here is a breakdown of the flags used above:<br \/>\u00a0-query: this is the input file, so the file with all of the protein sequences that we want to search<\/p>\n<p><br \/>\u00a0-db: this is the database, so the file we just indexed with the makeblastdb command above. Note that makeblastdb creates multiple reference files and that only the root name needs to be given here (so if the database was called refdb, then refdb would be given here even though the index files are called refdb.pin, refdb.phr, etc.)<\/p>\n<p><br \/>\u00a0-max_target_seqs: This flat specifies that we only want the best hit for each query protein. Otherwise all hits are provided.<\/p>\n<p><br \/>\u00a0-outfmt: This specifies that we want the tab-delimited output format rather than the full alignment output. If you forget what the columns are you can use -outfmt 7.<\/p>\n<p><br \/>\u00a0-evalue: This indicates that we want to exclude all hits with evalues above this threshold. A good value is about 0.00001, or 1e-5.<\/p>\n<p><br \/>\u00a0max_hsps: HSPs are 'high-scoring segment pairs'. A query protein can make several separate alignments to a single reference, so this tells the program we want only the best-scoring alignment.<\/p>\n<p><br \/>\u00a0-qcov_hsp_perc: This is the 'query coverage high-scoring sequence pair percent', or the percent of the query protein that has to form an alignment against the reference to be retained. Higher values prevent spurious alignments of only a short portion of the query to a reference.<\/p>\n<p>\u00a0<\/p>"},"is_project":0}],"available_protocols":["11573"]},{"id":"631593","is_changed":1,"original_id":"622447","is_skipped":"0","is_checked":"0","guid":"1A05744C426346CBB148831AA2005227","previous_guid":"687666CC846142D7A74BE20777A4FD20","previous_id":"631664","last_modified":"1527268138","components":[{"component_id":"1115917","previous_id":0,"original_id":"1092495","guid":"C3C60AB8B32A4839A7A6522DF6FDB4DC","previous_guid":null,"component_type_id":"1","data_id":null,"data":"<p>Above I mentioned two questions we would like to answer:<\/p>\n<p>1) How many proteins in genome A are present in genome B and vice versa.<\/p>\n<p>2) Of he proteins that are present in both genomes, how similar are they overall?<\/p>\n<p>\u00a0<\/p>\n<p>We answered the first qeustion above, and for the second we will need to install a package called 'datamash' that can help with simple math in the command line.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p><strong>sudo apt install datamash<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>Datamash will allow for quick calculation of averages straight from the command line. Once this package is installed you can run the following command:<\/p>\n<p><strong>blastp -query prochlorococcus_phage_PSSM3.faa -db prochlorococcus_phage_PSSM2.faa -outfmt 6 -max_target_seqs 1 -evalue 0.00001 -max_hsps 1 -qcov_hsp_perc 50 | datamash mean 3<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>And the output should be a single number, which is the average of all of the % identity scores from the blast output. Since each line was a distinct alignment between one query protein and it's best match in the reference dataset, this gives us a nice idea of how similar the proteins are overall. Here I got 49.98, which is quite low for % amino acid identity. So it seems as though the protein sequences of these genomes are quite dissimilar.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>For closely related genomes many scientists prefer using average nucleic acid identity (ANI) instead, but for distantly-related organisms this metric is less useful. Viruses evolve very quickly, so AAI is more useful here.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Now try doing the reverse and seeing how similar the results are (i.e., using PSSM2 as the query and PSSM3 as the db).<\/p>\n<p>When you vary the e-value what happens to the one-way AAI? Does this make sense?<\/p>\n<p>What about query coverage? How does increasing that change the one-way AAI?<\/p>","order_id":"0","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Above I mentioned two questions we would like to answer:<\/p>\n<p>1) How many proteins in genome A are present in genome B and vice versa.<\/p>\n<p>2) Of he proteins that are present in both genomes, how similar are they overall?<\/p>\n<p>\u00a0<\/p>\n<p>We answered the first qeustion above, and for the second we will need to install a package called 'datamash' that can help with simple math in the command line.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p><strong>sudo apt install datamash<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>Datamash will allow for quick calculation of averages straight from the command line. Once this package is installed you can run the following command:<\/p>\n<p><strong>blastp -query prochlorococcus_phage_PSSM3.faa -db prochlorococcus_phage_PSSM2.faa -outfmt 6 -max_target_seqs 1 -evalue 0.00001 -max_hsps 1 -qcov_hsp_perc 50 | datamash mean 3<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>And the output should be a single number, which is the average of all of the % identity scores from the blast output. Since each line was a distinct alignment between one query protein and it's best match in the reference dataset, this gives us a nice idea of how similar the proteins are overall. Here I got 49.98, which is quite low for % amino acid identity. So it seems as though the protein sequences of these genomes are quite dissimilar.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>For closely related genomes many scientists prefer using average nucleic acid identity (ANI) instead, but for distantly-related organisms this metric is less useful. Viruses evolve very quickly, so AAI is more useful here.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Now try doing the reverse and seeing how similar the results are (i.e., using PSSM2 as the query and PSSM3 as the db).<\/p>\n<p>When you vary the e-value what happens to the one-way AAI? Does this make sense?<\/p>\n<p>What about query coverage? How does increasing that change the one-way AAI?<\/p>"},"is_project":0},{"component_id":"1115918","previous_id":"1115917","original_id":"1092496","guid":"F95435E58D4E4C23B7CCC052907E9DF8","previous_guid":"C3C60AB8B32A4839A7A6522DF6FDB4DC","component_type_id":"6","data_id":null,"data":"","order_id":"1","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":""},"is_project":0}],"available_protocols":["11573"]},{"id":"631664","is_changed":"0","original_id":"0","is_skipped":"0","is_checked":"0","guid":"687666CC846142D7A74BE20777A4FD20","previous_guid":"AB16F056B0744847B169110A1B602E59","previous_id":"631592","last_modified":"1527268171","components":[{"component_id":"1116099","previous_id":0,"original_id":"0","guid":"89DF49226E664BABBBA954D0D0D816BF","previous_guid":null,"component_type_id":"6","data_id":"0","data":"","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":""},"is_project":0},{"component_id":"1116098","previous_id":"1116099","original_id":"0","guid":"5DB2F325455E4E538161ECE368ECC1F3","previous_guid":"89DF49226E664BABBBA954D0D0D816BF","component_type_id":"1","data_id":null,"data":"<p>Since we are comparing all of the proteins encoded in two viral genomes, it would be nice to get two basic statistics:<\/p>\n<p>1) How many proteins in genome A are present in genome B and vice versa.<\/p>\n<p>2) Of he proteins that are present in both genomes, how similar are they overall?<\/p>\n<p>\u00a0<\/p>\n<p>To answer the first question, we can simply use the command in the last step and count how many hits we find overall. Using the commands described in the previous step we need to be careful to make sure we are only counting the best hit for each query protein, and only one alignment per protein pair.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p><strong>blastp -query prochlorococcus_phage_PSSM3.faa -db prochlorococcus_phage_PSSM2.faa -outfmt 6 -max_target_seqs 1 -evalue 0.00001 -max_hsps 1 -qcov_hsp_perc 50 | wc<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>Note that instead of piping the output to the 'head' command, as we did above, now we can pipe it into a 'wc' command to count how many output lines there are. You should see something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yezjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yeyjtte.png\" data-ofn=\"Screenshot (8).png\" \/><\/p>\n<p>\u00a0<\/p>\n<p>So according to this analysis, there are 109 proteins in phage PSSM3 that have hits to phage PSSM2, with the parameters we used. What percent of all proteins in PSSM3 have hits to proteins in PSSM2? And vice versa?<\/p>\n<p>\u00a0<\/p>\n<p>Now as an exercise try changing the parameters a bit and see how they change the output. What do you think lowering the e-value threshold will do? What is the result of changing the query coverage percent?<\/p>\n<p>\u00a0<\/p>\n<p>Importantly, note that the results may change if we switch the query and the reference files (why would this be?), so we will want to do the reciprocal analysis too.\u00a0<\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Since we are comparing all of the proteins encoded in two viral genomes, it would be nice to get two basic statistics:<\/p>\n<p>1) How many proteins in genome A are present in genome B and vice versa.<\/p>\n<p>2) Of he proteins that are present in both genomes, how similar are they overall?<\/p>\n<p>\u00a0<\/p>\n<p>To answer the first question, we can simply use the command in the last step and count how many hits we find overall. Using the commands described in the previous step we need to be careful to make sure we are only counting the best hit for each query protein, and only one alignment per protein pair.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p><strong>blastp -query prochlorococcus_phage_PSSM3.faa -db prochlorococcus_phage_PSSM2.faa -outfmt 6 -max_target_seqs 1 -evalue 0.00001 -max_hsps 1 -qcov_hsp_perc 50 | wc<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>Note that instead of piping the output to the 'head' command, as we did above, now we can pipe it into a 'wc' command to count how many output lines there are. You should see something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yezjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yeyjtte.png\" data-ofn=\"Screenshot (8).png\" \/><\/p>\n<p>\u00a0<\/p>\n<p>So according to this analysis, there are 109 proteins in phage PSSM3 that have hits to phage PSSM2, with the parameters we used. What percent of all proteins in PSSM3 have hits to proteins in PSSM2? And vice versa?<\/p>\n<p>\u00a0<\/p>\n<p>Now as an exercise try changing the parameters a bit and see how they change the output. What do you think lowering the e-value threshold will do? What is the result of changing the query coverage percent?<\/p>\n<p>\u00a0<\/p>\n<p>Importantly, note that the results may change if we switch the query and the reference files (why would this be?), so we will want to do the reciprocal analysis too.\u00a0<\/p>"},"is_project":0}]}]}