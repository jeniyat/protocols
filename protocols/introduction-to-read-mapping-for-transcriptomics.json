{"uri":"introduction-to-read-mapping-for-transcriptomics-qhedt3e","version_id":"2","protocol_name":"Introduction to read mapping for transcriptomics","protocol_name_html":"Introduction to read mapping for transcriptomics","is_prepublished":"0","can_edit":"0","parent_id":"11510","api_version":"1","is_new_mode":"0","last_modified":"1527540116","type_id":"1","link":null,"fork_id":"","public_fork_note":"","number_of_steps":"6","has_versions":"1","first_published_date":"1527540116","publish_date":"2018-05-28 20:41:56","documents":null,"have_protocol_in_step":"0","is_protocol_in_step":"0","vendor_name":"Contributed by users","vendor_link":"https:\/\/www.protocols.io","vendor_logo":"\/img\/vendors\/1.png","mod_mins":"-15","mod_secs":"57","description":"<p>This is an example of a simple short read mapping analysis that could be used as part of a transcriptomics or RNA-seq workflow.\u00a0\u00a0<\/p>\n<p>Code is intended for use on an Ubuntu 16.04 LTS OS, but it may work on other Unix or Unix-like systems.<\/p>\n<p>\u00a0<\/p>\n<p>This tutorial uses data from the following very nice paper from the Hatfull group:<\/p>\n<p>Dedrick, Mavrich, Ng, and Hatfull, Expression and evolutionary patterns of mycobacteriophage D29 and its temperate close relatives. BMC Microbiology, 2017. https:\/\/doi.org\/10.1186\/s12866-017-1131-2<\/p>\n<p>\u00a0<\/p>\n<p>The tools that are used include:<\/p>\n<p><strong>SRA toolkit<\/strong>:\u00a0https:\/\/www.ncbi.nlm.nih.gov\/sra\/docs\/toolkitsoft\/<\/p>\n<p><strong>bowtie2<\/strong>:\u00a0http:\/\/bowtie-bio.sourceforge.net\/bowtie2\/index.shtml<\/p>\n<p><strong>samtools<\/strong>:\u00a0http:\/\/samtools.sourceforge.net\/<\/p>\n<p><strong>BEDOPS<\/strong>:\u00a0https:\/\/bedops.readthedocs.io\/en\/latest\/content\/reference\/file-management\/conversion\/bam2bed.html<\/p>\n<p><strong>BEDtools<\/strong>:\u00a0https:\/\/bedtools.readthedocs.io\/en\/latest\/<\/p>\n<p>\u00a0<\/p>\n<p>Make sure that these tools are installed before starting the tutorial.\u00a0On a Ubuntu OS you should be able to install most with \"sudo apt install\", but you may wish to use a package manager such as Anaconda or Miniconda as well.\u00a0<\/p>\n<p>Throughout the tutorial some notes may be made about particular versions of tools. For example, note that the version of SRA toolkit that is installed with apt install often leads to downstream errors, it may be desirable to install this tool with Miniconda instead.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Miniconda bash installers can be found here:\u00a0https:\/\/conda.io\/miniconda.html<\/p>\n<p>\u00a0<\/p>","is_bookmarked":"0","can_reassign":"1","before_start":null,"has_guidelines":"0","materials":[],"warning":null,"version_class":"11510","public":"1","is_owner":"1","is_original_owner":"1","created_on":"1527474964","protocol_affiliation":"Virginia Tech","affiliation":"Virginia Tech","doi":"dx.doi.org\/10.17504\/protocols.io.qhedt3e","doi_status":"2","changed_fork_steps":null,"profile_url":"FrankAylward-y22344v2x2","protocol_img":"https:\/\/www.protocols.io\/img\/default_protocol.png","profile_image":"https:\/\/s3.amazonaws.com\/pr-journal\/v39jtte.png","full_name":"Frank Aylward","created_by":"Frank Aylward","private_link":"363C6D6FE8FF0367D584DD9A7E4BFD48","original_img":"1","username":"frank-aylward","is_retracted":"0","retraction_reason":null,"plos_id":null,"manuscript_citation":null,"journal_name":null,"is_donations_disabled":"0","is_donations_disabled_by_user":"9","item_record_id":317603,"fork_info":[],"compare_forks":[],"protocols":[],"groups":[],"number_of_shared_runs":[],"ownership_history":[],"keywords":"","transfer_to_user":[],"sub_transfer":false,"is_transfer_pending":false,"number_of_bookmarks":"1","collections":[],"tags":[{"tag_id":"117","tag_name":" bioinformatics"},{"tag_id":"131","tag_name":" metagenomics"},{"tag_id":"510","tag_name":"Genomics"}],"archived":0,"sub_authors":[],"sub_protocols_number":0,"can_edit_shared":0,"shared_runs":[],"is_shared_run":0,"is_shared":1,"banner":null,"contact_badges":[{"badge_id":"4","badge_image":"\/img\/badges\/gold.svg","badge_description":"Gold power author!"}],"number_of_comments":0,"is_locked":0,"is_locked_by":false,"authors":"Frank Aylward","authors_list":[{"name":"Frank Aylward","affiliation":"Virginia Tech","username":null,"profile_image":null}],"user":{"profile_image":"https:\/\/s3.amazonaws.com\/pr-journal\/v39jtte.png","username":"frank-aylward","full_name":"Frank Aylward","created_by":"Frank Aylward"},"access":{"can_view":"1","can_remove":"0","can_add":"0","can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":"0","can_move":"1","can_transfer":"1","can_download":"1","is_locked":"0"},"is_contact_suspended":0,"guidelines":null,"status_id":"1","is_research":"0","status_info":"We use this protocol in our group and it is working","steps":[{"id":"631982","is_changed":1,"original_id":"622338","is_skipped":"0","is_checked":"0","guid":"60FF6601ECEA449AAA7FFBDA1615443B","previous_guid":null,"previous_id":null,"last_modified":"1527479274","components":[{"component_id":"1116892","previous_id":0,"original_id":"1092167","guid":"9A71AD38A595470D8D2F3D89F5F6615B","previous_guid":null,"component_type_id":"1","data_id":null,"data":"<p>The datasets we will be using here are part of the Dedrick et al BMC Microbiology paper mentioned in the description, which describes some very cool transcriptomic experiments of Mycobacterium smegmatis while is infected with various bacteriophage. There are several short-read Illumina transcriptomes that are part of this study, but here will only consider that associated with the accession\u00a0SRR5585000, which corresponds to a transcriptomic study of M. smegmatis during infection with mycobacteriophage D29. The RNA from this accession was extracted 15 minutes after infection, and other timepoints are also available (see all of the datasets on the Gene Expression Omnibus:\u00a0https:\/\/www.ncbi.nlm.nih.gov\/geo\/query\/acc.cgi?acc=GSE99182).\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>First let's create a new folder and navigate into it, just so we can keep all of the subsequent files organized.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p><strong>mkdir transcript_mapping<\/strong><\/p>\n<p><strong>cd transcript mapping<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>and then let's download the raw Illumina reads using the fastq-dump utility in the SRA toolkit:<\/p>\n<p>\u00a0<\/p>\n<p><strong>fastq-dump -X 10000 SRR5585000<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>The -X flag here indicates that instead of downloading the entire dataset, we only wish to download the first 10,000 reads. This is just for simplicity and to keep the datasets small (10,000 may seem large, but its a small number of reads compared to most transcriptome studies).\u00a0<\/p>\n<p>After this we can us the 'ls' command to ensure that the file was downloaded, and then take a quick look inside with the 'head' command to ensure it looks like typical FASTQ format. You should see something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhdjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhcjtte.png\" data-ofn=\"Screenshot (24).png\" \/><\/p>","order_id":"0","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>The datasets we will be using here are part of the Dedrick et al BMC Microbiology paper mentioned in the description, which describes some very cool transcriptomic experiments of Mycobacterium smegmatis while is infected with various bacteriophage. There are several short-read Illumina transcriptomes that are part of this study, but here will only consider that associated with the accession\u00a0SRR5585000, which corresponds to a transcriptomic study of M. smegmatis during infection with mycobacteriophage D29. The RNA from this accession was extracted 15 minutes after infection, and other timepoints are also available (see all of the datasets on the Gene Expression Omnibus:\u00a0https:\/\/www.ncbi.nlm.nih.gov\/geo\/query\/acc.cgi?acc=GSE99182).\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>First let's create a new folder and navigate into it, just so we can keep all of the subsequent files organized.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p><strong>mkdir transcript_mapping<\/strong><\/p>\n<p><strong>cd transcript mapping<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>and then let's download the raw Illumina reads using the fastq-dump utility in the SRA toolkit:<\/p>\n<p>\u00a0<\/p>\n<p><strong>fastq-dump -X 10000 SRR5585000<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>The -X flag here indicates that instead of downloading the entire dataset, we only wish to download the first 10,000 reads. This is just for simplicity and to keep the datasets small (10,000 may seem large, but its a small number of reads compared to most transcriptome studies).\u00a0<\/p>\n<p>After this we can us the 'ls' command to ensure that the file was downloaded, and then take a quick look inside with the 'head' command to ensure it looks like typical FASTQ format. You should see something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhdjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhcjtte.png\" data-ofn=\"Screenshot (24).png\" \/><\/p>"},"is_project":0},{"component_id":"1116893","previous_id":"1116892","original_id":"1092168","guid":"AC105E1EF19F4546ABC0EA8DC0525BDD","previous_guid":"9A71AD38A595470D8D2F3D89F5F6615B","component_type_id":"6","data_id":null,"data":"Download the reference genome and index a database with bowtie2","order_id":"1","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Download the reference genome and index a database with bowtie2"},"is_project":0}],"available_protocols":["11554"]},{"id":"631983","is_changed":1,"original_id":"622339","is_skipped":"0","is_checked":"0","guid":"E8C806644EF04FC18772FEC49006A0CA","previous_guid":"60FF6601ECEA449AAA7FFBDA1615443B","previous_id":"631982","last_modified":"1527478491","components":[{"component_id":"1116894","previous_id":0,"original_id":"1092169","guid":"387B4ED73ED8482DA73D63FA0373548C","previous_guid":null,"component_type_id":"1","data_id":null,"data":"<p>Now we need to get a reference genome to map reads against. The focus of this experiment was mycobacteriophage D29, so let's download the FASTA file of that genome using the Unix wget command:<\/p>\n<p>\u00a0<\/p>\n<p><strong>wget -O D29.fna.gz ftp:\/\/ftp.ncbi.nlm.nih.gov\/genomes\/all\/GCA\/003\/004\/865\/GCA_003004865.1_ASM300486v1\/GCA_003004865.1_ASM300486v1_genomic.fna.gz<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>and, because the file is compressed, let's unpack it:<\/p>\n<p><br \/><strong>gunzip D29.fna.gz<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>We are going to map reads using bowtie2, which requires that the FASTA genome file is indexed first. To do this we can use the bowtie2-build command. First just try typing \"bowtie2-build\" just to get a handle on the general usage and options of this tool. For purposes here we can run the following command:<\/p>\n<p>\u00a0<\/p>\n<p><strong>bowtie2-build D29.fna D29 &gt; bowtie2.log<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>The reason I put a \"&gt; bowtie2.log\" at the end was because this command outputs a large amount of information to the command line, and I wanted to save it in a log file. It's usually not necessary to look at this, but if something weird happens when mapping reads later we can always go back and check to make sure the genome was indexed properly.<\/p>\n<p>The important thing that bowtie2-build does is create a number of bt2 files, which you should be able to see after running the command.\u00a0<\/p>\n<p>Overall this step should look something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhfjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhejtte.png\" data-ofn=\"Screenshot (26).png\" \/>\u00a0<\/p>\n<p>\u00a0<\/p>","order_id":"0","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Now we need to get a reference genome to map reads against. The focus of this experiment was mycobacteriophage D29, so let's download the FASTA file of that genome using the Unix wget command:<\/p>\n<p>\u00a0<\/p>\n<p><strong>wget -O D29.fna.gz ftp:\/\/ftp.ncbi.nlm.nih.gov\/genomes\/all\/GCA\/003\/004\/865\/GCA_003004865.1_ASM300486v1\/GCA_003004865.1_ASM300486v1_genomic.fna.gz<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>and, because the file is compressed, let's unpack it:<\/p>\n<p><br \/><strong>gunzip D29.fna.gz<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>We are going to map reads using bowtie2, which requires that the FASTA genome file is indexed first. To do this we can use the bowtie2-build command. First just try typing \"bowtie2-build\" just to get a handle on the general usage and options of this tool. For purposes here we can run the following command:<\/p>\n<p>\u00a0<\/p>\n<p><strong>bowtie2-build D29.fna D29 &gt; bowtie2.log<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>The reason I put a \"&gt; bowtie2.log\" at the end was because this command outputs a large amount of information to the command line, and I wanted to save it in a log file. It's usually not necessary to look at this, but if something weird happens when mapping reads later we can always go back and check to make sure the genome was indexed properly.<\/p>\n<p>The important thing that bowtie2-build does is create a number of bt2 files, which you should be able to see after running the command.\u00a0<\/p>\n<p>Overall this step should look something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhfjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhejtte.png\" data-ofn=\"Screenshot (26).png\" \/>\u00a0<\/p>\n<p>\u00a0<\/p>"},"is_project":0},{"component_id":"1116895","previous_id":"1116894","original_id":"1092170","guid":"BEFC4A30FD5E43039467C64F79865079","previous_guid":"387B4ED73ED8482DA73D63FA0373548C","component_type_id":"6","data_id":null,"data":"Download a reference genome","order_id":"1","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Download a reference genome"},"is_project":0}],"available_protocols":["11554"]},{"id":"631984","is_changed":1,"original_id":"622340","is_skipped":"0","is_checked":"0","guid":"2219FBAB10EF45538DEE15B145745C1A","previous_guid":"E8C806644EF04FC18772FEC49006A0CA","previous_id":"631983","last_modified":"1527535626","components":[{"component_id":"1116896","previous_id":0,"original_id":"1092171","guid":"C9B16AE686954318A608F37F4EB3AFC1","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Perform the read mapping","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Perform the read mapping"},"is_project":0},{"component_id":"1116897","previous_id":"1116896","original_id":"1092172","guid":"E3EE3FCC54E543B9B36AEB941205DBB2","previous_guid":"C9B16AE686954318A608F37F4EB3AFC1","component_type_id":"1","data_id":null,"data":"<p>Generally speaking one should do a bit of quality-checking on the reads before jumping straight into the mapping step. Also, it is typical to remove adapter sequences and trim off low-quality bases before mapping.<\/p>\n<p>\u00a0<\/p>\n<p>Since this is intended to be a conceptual tutorial, and since it doesn't change the results too much, we will skip these steps here.\u00a0Keep them in mind if you are interested in performing analyses for a formal study, though.\u00a0If you are interested in adapter clipping and quality trimming, I would recommend cutadapt for the former and sickle for the latter (https:\/\/cutadapt.readthedocs.io\/en\/stable\/guide.html\u00a0 \u00a0and\u00a0 \u00a0https:\/\/github.com\/najoshi\/sickle)<\/p>\n<p>\u00a0<\/p>\n<p>Before we get started, just type '<strong>bowtie2<\/strong>' and take a look at the general usage and options for this tool. Note that bowtie2 is a versatile tool that can be used in many ways. We will be using some rather simple and straightforward code here, but there are many possible options you may wish to play around with.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Let's try a simple command:<\/p>\n<p>\u00a0<\/p>\n<p><strong>bowtie2 -U SRR5585000.fastq -x D29 -S mapping_out.sam<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>The -U specifies that we are using unpaired reads. Keep in mind that Illumina reads are often paired, so for other data you may want to use the -1 and -2 flags to specify input data. We specify the database prefix with the -x flag, and the output SAM file with the -S flag. Bowtie2 outputs the data in 'sequence alignment map' format, which is pretty typical. SAM format is rather complex and compact and contains information about which reads map, and to what locations; you can see details here:\u00a0https:\/\/en.wikipedia.org\/wiki\/SAM_(file_format).\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Generally speaking one should do a bit of quality-checking on the reads before jumping straight into the mapping step. Also, it is typical to remove adapter sequences and trim off low-quality bases before mapping.<\/p>\n<p>\u00a0<\/p>\n<p>Since this is intended to be a conceptual tutorial, and since it doesn't change the results too much, we will skip these steps here.\u00a0Keep them in mind if you are interested in performing analyses for a formal study, though.\u00a0If you are interested in adapter clipping and quality trimming, I would recommend cutadapt for the former and sickle for the latter (https:\/\/cutadapt.readthedocs.io\/en\/stable\/guide.html\u00a0 \u00a0and\u00a0 \u00a0https:\/\/github.com\/najoshi\/sickle)<\/p>\n<p>\u00a0<\/p>\n<p>Before we get started, just type '<strong>bowtie2<\/strong>' and take a look at the general usage and options for this tool. Note that bowtie2 is a versatile tool that can be used in many ways. We will be using some rather simple and straightforward code here, but there are many possible options you may wish to play around with.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Let's try a simple command:<\/p>\n<p>\u00a0<\/p>\n<p><strong>bowtie2 -U SRR5585000.fastq -x D29 -S mapping_out.sam<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>The -U specifies that we are using unpaired reads. Keep in mind that Illumina reads are often paired, so for other data you may want to use the -1 and -2 flags to specify input data. We specify the database prefix with the -x flag, and the output SAM file with the -S flag. Bowtie2 outputs the data in 'sequence alignment map' format, which is pretty typical. SAM format is rather complex and compact and contains information about which reads map, and to what locations; you can see details here:\u00a0https:\/\/en.wikipedia.org\/wiki\/SAM_(file_format).\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>\u00a0<\/p>"},"is_project":0}],"available_protocols":["11554"]},{"id":"631985","is_changed":1,"original_id":"622341","is_skipped":"0","is_checked":"0","guid":"F2E52847768448E88DF8EF511B5433B8","previous_guid":"2219FBAB10EF45538DEE15B145745C1A","previous_id":"631984","last_modified":"1527536231","components":[{"component_id":"1116898","previous_id":0,"original_id":"1092173","guid":"2CE74E0FD64A425D9F4C672596CD5A91","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Process the SAM file with samtools","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Process the SAM file with samtools"},"is_project":0},{"component_id":"1116899","previous_id":"1116898","original_id":"1092174","guid":"C51E90FA893F4614A0782EFDD0AF9594","previous_guid":"2CE74E0FD64A425D9F4C672596CD5A91","component_type_id":"1","data_id":null,"data":"<p>Rather than spending too much time looking at the SAM file I usually just start processing it with samtools. Often you will see SAM files converted into BAM files (binary alignment map). BAM files are smaller, since they do not require encoding to make them human-readable, and they can be processed more quickly. Since SAM and BAM files contain the same information, you will often see SAM files deleted and BAM files used for storage.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>The following commands are a bit tedious, but they are all required to convert SAM-&gt;BAM, sort, and index the mapped reads. Before we begin take a quick look at all of the utilities available with samtools by typing \"<strong>samtools<\/strong>\" in your command line.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>First we need to convert SAM-&gt;BAM and remove reads that did not map:<\/p>\n<p><strong>samtools view -bS -F 4 mapping_out.sam &gt; mapping_out.bam<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>Then we need to sort the reads [note: the following command works with samtools v 0.1.19-96b5f2294a, but the syntax is different with different versions. If you get an error message try using the -o flag and specifying mapping_out.sort.bam as the output file]:<br \/><strong>samtools sort mapping_out.bam mapping_out.sort<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>Finally we need to index the sorted read bam file:<br \/><strong>samtools index mapping_out.sort.bam<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>All of this may seem a bit tedious, but at the end we have a nice sorted bam file that we can use for multiple applications downstream. Sorted bam files are also useful for storing\/sharing data, since they are typically smaller than fastq or sam files.\u00a0 \u00a0<\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Rather than spending too much time looking at the SAM file I usually just start processing it with samtools. Often you will see SAM files converted into BAM files (binary alignment map). BAM files are smaller, since they do not require encoding to make them human-readable, and they can be processed more quickly. Since SAM and BAM files contain the same information, you will often see SAM files deleted and BAM files used for storage.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>The following commands are a bit tedious, but they are all required to convert SAM-&gt;BAM, sort, and index the mapped reads. Before we begin take a quick look at all of the utilities available with samtools by typing \"<strong>samtools<\/strong>\" in your command line.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>First we need to convert SAM-&gt;BAM and remove reads that did not map:<\/p>\n<p><strong>samtools view -bS -F 4 mapping_out.sam &gt; mapping_out.bam<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>Then we need to sort the reads [note: the following command works with samtools v 0.1.19-96b5f2294a, but the syntax is different with different versions. If you get an error message try using the -o flag and specifying mapping_out.sort.bam as the output file]:<br \/><strong>samtools sort mapping_out.bam mapping_out.sort<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>Finally we need to index the sorted read bam file:<br \/><strong>samtools index mapping_out.sort.bam<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>All of this may seem a bit tedious, but at the end we have a nice sorted bam file that we can use for multiple applications downstream. Sorted bam files are also useful for storing\/sharing data, since they are typically smaller than fastq or sam files.\u00a0 \u00a0<\/p>"},"is_project":0}],"available_protocols":["11554"]},{"id":"631986","is_changed":1,"original_id":"622342","is_skipped":"0","is_checked":"0","guid":"958548E560D74FA7ACA60FC2CED2CF77","previous_guid":"F2E52847768448E88DF8EF511B5433B8","previous_id":"631985","last_modified":"1527538288","components":[{"component_id":"1116900","previous_id":0,"original_id":"1092175","guid":"E6D9DDCDB8824B429FFF397EBAD47DF9","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Download the GFF file for the genome","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Download the GFF file for the genome"},"is_project":0},{"component_id":"1116901","previous_id":"1116900","original_id":"1092176","guid":"7A8745589C4F4402A92B1E63690440D4","previous_guid":"E6D9DDCDB8824B429FFF397EBAD47DF9","component_type_id":"1","data_id":null,"data":"<p>Now we have the genome file and a sorted bam file with information about where certain transcriptome reads mapped, but we still need information about where genes and other features are encoded in the mycobacteriophage D29 genome. After all, knowing that a large number of reads map between coordinates 10377 and 11421 in the phage genome is not necessarily useful unless we also have information about what genes are encoded in that region.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>To get the genome annotation we will download the Gene Feature Format table (GFF) for the D29 genome. GFF files are typically used for storing genome annotation information, and one such file was already generated for D29 as part of the genome sequencing project for this bacteriophage. We can do this in the same way that we downloaded the genome above:<\/p>\n<p>\u00a0<\/p>\n<p><strong>wget -O D29.gff.gz ftp:\/\/ftp.ncbi.nlm.nih.gov\/genomes\/all\/GCA\/003\/004\/865\/GCA_003004865.1_ASM300486v1\/GCA_003004865.1_ASM300486v1_genomic.gff.gz<\/strong><br \/><strong>gunzip D29.gff.gz<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>As it turns out, there are many different formats that are used to encode genome annotation information. In the next step we will be using a tool called BEDtools which will require a Browser Extensible Data (BED) file. So we need to convert the GFF file to a BED file. For this we will use a utility called gff2bed in the BEDOPS tool:<\/p>\n<p>\u00a0<\/p>\n<p><strong>gff2bed &lt; D29.gff &gt; D29.bed<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>BED files are tab-delimited tables with information about the different features of a genome, their coordinates, which strand they are encoded in, and some annotation information. The tables are a bit large and somewhat unweildy to look at in the command line, but just to get an idea of a format let's look at the first two lines:<\/p>\n<p>\u00a0<\/p>\n<p><strong>head -n 2 D29.bed<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>This should give you the general idea. Note that the 10th column is super long and contains lots of details about the gene name, protein name, etc. For details on BED format see here:\u00a0https:\/\/genome.ucsc.edu\/FAQ\/FAQformat.html#format1<\/p>\n<p>\u00a0<\/p>\n<p>The code from this step should look something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhxjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhwjtte.png\" data-ofn=\"Screenshot (27).png\" \/><\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Now we have the genome file and a sorted bam file with information about where certain transcriptome reads mapped, but we still need information about where genes and other features are encoded in the mycobacteriophage D29 genome. After all, knowing that a large number of reads map between coordinates 10377 and 11421 in the phage genome is not necessarily useful unless we also have information about what genes are encoded in that region.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>To get the genome annotation we will download the Gene Feature Format table (GFF) for the D29 genome. GFF files are typically used for storing genome annotation information, and one such file was already generated for D29 as part of the genome sequencing project for this bacteriophage. We can do this in the same way that we downloaded the genome above:<\/p>\n<p>\u00a0<\/p>\n<p><strong>wget -O D29.gff.gz ftp:\/\/ftp.ncbi.nlm.nih.gov\/genomes\/all\/GCA\/003\/004\/865\/GCA_003004865.1_ASM300486v1\/GCA_003004865.1_ASM300486v1_genomic.gff.gz<\/strong><br \/><strong>gunzip D29.gff.gz<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>As it turns out, there are many different formats that are used to encode genome annotation information. In the next step we will be using a tool called BEDtools which will require a Browser Extensible Data (BED) file. So we need to convert the GFF file to a BED file. For this we will use a utility called gff2bed in the BEDOPS tool:<\/p>\n<p>\u00a0<\/p>\n<p><strong>gff2bed &lt; D29.gff &gt; D29.bed<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>BED files are tab-delimited tables with information about the different features of a genome, their coordinates, which strand they are encoded in, and some annotation information. The tables are a bit large and somewhat unweildy to look at in the command line, but just to get an idea of a format let's look at the first two lines:<\/p>\n<p>\u00a0<\/p>\n<p><strong>head -n 2 D29.bed<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>This should give you the general idea. Note that the 10th column is super long and contains lots of details about the gene name, protein name, etc. For details on BED format see here:\u00a0https:\/\/genome.ucsc.edu\/FAQ\/FAQformat.html#format1<\/p>\n<p>\u00a0<\/p>\n<p>The code from this step should look something like this:<\/p>\n<p><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhxjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhwjtte.png\" data-ofn=\"Screenshot (27).png\" \/><\/p>"},"is_project":0}],"available_protocols":["11554"]},{"id":"631987","is_changed":1,"original_id":"622343","is_skipped":"0","is_checked":"0","guid":"343C841429BD430DBD63996EF0233A60","previous_guid":"958548E560D74FA7ACA60FC2CED2CF77","previous_id":"631986","last_modified":"1527540007","components":[{"component_id":"1116902","previous_id":0,"original_id":"1092177","guid":"6B96460FAD2A42A2AC0944A3259FB5FB","previous_guid":null,"component_type_id":"6","data_id":null,"data":"Identify highly expressed genes with BEDtools","order_id":"0","name":"Section","data_by_id":"0","type_id":"6","source_data":{"section":"Identify highly expressed genes with BEDtools"},"is_project":0},{"component_id":"1116903","previous_id":"1116902","original_id":"1092178","guid":"D5F46EFE5A6C4460AB126ADBA0A359C1","previous_guid":"6B96460FAD2A42A2AC0944A3259FB5FB","component_type_id":"1","data_id":null,"data":"<p>Now we have all of the necessary files to identify which genes were highly expressed in our transcriptome.\u00a0<\/p>\n<p>First let's take a look at the tool BEDtools and what utilities it has by typing 'bedtools'. You will see a large number of options- this is a very comprehensive tool!\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Here we will be using the 'intersect' utility, which will tell us which reads in our sorted bam file intersect with regions in the BED file.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p><strong>bedtools intersect -a D29.bed -c -bed -f 0.2 -b mapping_out.sort.bam &gt; intersect.txt<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>A quick note on the flags used here.<\/p>\n<p>-a and -b denote the BED file and sorted bam file, respectively.\u00a0<\/p>\n<p>-c indicates that we want to count the number of reads that overlap with BED regions. The default output is to provide each read individually with the feature it mapped to.\u00a0<\/p>\n<p>-f 0.2 denotes that the read has to overlap by at least 20% of it's length to be considered mapping to a feature. One can imagine a long polycistronic mRNA with many genes encoded in it; some reads may overlap just slightly with a specific gene. Here we require at least 20% overlap, which will help ensure reads are mapping properly.\u00a0\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>The output will be a BED file, the same as we used for the input, but with an additional column appended to the end. This column will have the number of reads tha map to each feature.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Now a rather basic question that it would be nice to answer is: What are the highest expressed genes in our transcriptome?<\/p>\n<p>To answer this we should be able to sort the intersect file by the last column with the Unix sort command. Sometimes this can be complicated by spaces that are present in the intersect file, so let's do a quick text replacement first:<\/p>\n<p>\u00a0<\/p>\n<p><strong>sed 's\/ \/_\/g' intersect.txt &gt; intersect_sed.txt<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>And then sort by the 11th column, which is where our mapping counts are:<\/p>\n<p>\u00a0<\/p>\n<p><strong>sort -k 11,11 -rn intersect_sed.txt | cut -f 10,11 | head -n 5<\/strong><\/p>\n<p><strong><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhzjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhyjtte.png\" data-ofn=\"Screenshot (28).png\" \/><\/strong><\/p>\n<p>\u00a0<\/p>\n<p>So of the top 5 most highly expressed genes in the mycobacteriophage D29 genome, we have a DNA primase, a helicase, two hypothetical proteins, and one glutaredoxin. The first two are noteworthy since this particular transcriptome sample was taken after only 15 minutes of infection, and at this early stage we would expect to find genes associated with viral DNA replication (\"early genes\"). The hypothetical proteins are also not surprising, since many genes in bacteriophage genomes are uncharacterized and have no known function.\u00a0<\/p>","order_id":"1","name":"Description","data_by_id":"0","type_id":"1","source_data":{"description":"<p>Now we have all of the necessary files to identify which genes were highly expressed in our transcriptome.\u00a0<\/p>\n<p>First let's take a look at the tool BEDtools and what utilities it has by typing 'bedtools'. You will see a large number of options- this is a very comprehensive tool!\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Here we will be using the 'intersect' utility, which will tell us which reads in our sorted bam file intersect with regions in the BED file.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p><strong>bedtools intersect -a D29.bed -c -bed -f 0.2 -b mapping_out.sort.bam &gt; intersect.txt<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>A quick note on the flags used here.<\/p>\n<p>-a and -b denote the BED file and sorted bam file, respectively.\u00a0<\/p>\n<p>-c indicates that we want to count the number of reads that overlap with BED regions. The default output is to provide each read individually with the feature it mapped to.\u00a0<\/p>\n<p>-f 0.2 denotes that the read has to overlap by at least 20% of it's length to be considered mapping to a feature. One can imagine a long polycistronic mRNA with many genes encoded in it; some reads may overlap just slightly with a specific gene. Here we require at least 20% overlap, which will help ensure reads are mapping properly.\u00a0\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>The output will be a BED file, the same as we used for the input, but with an additional column appended to the end. This column will have the number of reads tha map to each feature.\u00a0<\/p>\n<p>\u00a0<\/p>\n<p>Now a rather basic question that it would be nice to answer is: What are the highest expressed genes in our transcriptome?<\/p>\n<p>To answer this we should be able to sort the intersect file by the last column with the Unix sort command. Sometimes this can be complicated by spaces that are present in the intersect file, so let's do a quick text replacement first:<\/p>\n<p>\u00a0<\/p>\n<p><strong>sed 's\/ \/_\/g' intersect.txt &gt; intersect_sed.txt<\/strong><\/p>\n<p>\u00a0<\/p>\n<p>And then sort by the 11th column, which is where our mapping counts are:<\/p>\n<p>\u00a0<\/p>\n<p><strong>sort -k 11,11 -rn intersect_sed.txt | cut -f 10,11 | head -n 5<\/strong><\/p>\n<p><strong><img id=\"s-mce-img\" class=\"s-mce-img\" src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhzjtte.png\" data-src=\"https:\/\/s3.amazonaws.com\/pr-journal\/yhyjtte.png\" data-ofn=\"Screenshot (28).png\" \/><\/strong><\/p>\n<p>\u00a0<\/p>\n<p>So of the top 5 most highly expressed genes in the mycobacteriophage D29 genome, we have a DNA primase, a helicase, two hypothetical proteins, and one glutaredoxin. The first two are noteworthy since this particular transcriptome sample was taken after only 15 minutes of infection, and at this early stage we would expect to find genes associated with viral DNA replication (\"early genes\"). The hypothetical proteins are also not surprising, since many genes in bacteriophage genomes are uncharacterized and have no known function.\u00a0<\/p>"},"is_project":0}],"available_protocols":["11554"]}]}