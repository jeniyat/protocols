{"id":19803,"title":"Demultiplexing Nanopore reads with LAST","title_html":"Demultiplexing Nanopore reads with LAST","image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bcixa.png","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/bcixa.png"},"doi":"dx.doi.org\/10.17504\/protocols.io.xj3fkqn","doi_status":2,"uri":"demultiplexing-nanopore-reads-with-last-xj3fkqn","type_id":1,"published_on":1548806448,"version_id":0,"created_on":1548800343,"categories":null,"creator":{"name":"David Eccles","affiliation":"Malaghan Institute of Medical Research (NZ)","username":"david-eccles","link":"https:\/\/doi.org\/10.5281\/zenodo.2535894","image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg"},"badges":[{"id":3,"image":{"source":"\/img\/badges\/silver.svg","placeholder":"\/img\/badges\/silver.svg"},"name":"Power author!"},{"id":6,"image":{"source":"\/img\/badges\/socialbutterfly.svg","placeholder":"\/img\/badges\/socialbutterfly.svg"},"name":"Social butterfly"}],"research_interests":null},"journal":null,"journal_name":null,"journal_link":null,"public":1,"has_versions":0,"link":"https:\/\/doi.org\/10.5281\/zenodo.2535894","number_of_steps":8,"authors":[{"name":"David Eccles","affiliation":"Malaghan Institute of Medical Research (NZ)","username":"david-eccles","link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg"},"badges":[],"research_interests":null}],"versions":[],"groups":[{"id":269,"uri":"awesome-DNA-from-all-kingdoms-of-life","title":"MinION user group for high molecular weight DNA extraction from all kingdoms","image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/ftfb5nw.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/ftfb5nw.jpg"},"tech_support":{"email":null,"phone":null,"hide_contact":0,"use_email":0},"is_member":1,"request":{"id":269,"uri":"awesome-DNA-from-all-kingdoms-of-life","is_protocol_requested":0,"is_group_requested":0,"is_my":false,"is_request":false,"is_confirmed":1,"is_declined":0,"visible":1,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/ftfb5nw.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/ftfb5nw.jpg"},"is_member":1,"title":"MinION user group for high molecular weight DNA extraction from all kingdoms","requester":{"name":" ","affiliation":null,"affiliation_url":null,"username":null,"link":null},"protocol":{"id":0,"title":"Demultiplexing Nanopore reads with LAST","title_html":"Demultiplexing Nanopore reads with LAST","image":{"source":null,"placeholder":null},"doi":null,"doi_status":0,"uri":"demultiplexing-nanopore-reads-with-last-xj3fkqn","type_id":1,"published_on":null,"stats":{"number_of_views":0,"number_of_steps":0,"number_of_bookmarks":0,"number_of_comments":0}},"created_on":1548806449,"resolve_on":0,"resolved_user":{"name":" ","affiliation":null,"username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null}}}],"has_subprotocols":0,"is_subprotocol":0,"is_bookmarked":0,"forks_count":{"private":0,"public":0},"steps":[{"id":702702,"guid":"D8449570241411E9B5045FC0FC2F250F","previous_id":null,"previous_guid":null,"modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"93F57A8A6D9243C8ACB06B579A95E25A","order_id":1,"type_id":6,"title":"Section","source":{"title":"Generating Barcode Index"}},{"id":1054724,"guid":"5BD1A165C83842D89926275B005862F0","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Prepare a FASTA file containing barcode sequences (see attached FASTA file). To reduce the chance of mismatched adapters, this should <\/span><span style = \"font-style:italic;\">only<\/span><span> contain the barcode sequences. That restriction means this approach will not work for short reads, where the barcode sequences are very likely to occur within sequences.<\/span><\/div><\/div>"}},{"id":1054725,"guid":"6D43E4F0241511E9B5045FC0FC2F250F","order_id":2,"type_id":23,"title":"file","source":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bciwa.fa","placeholder":"\/img\/extensions\/file.png","original_name":"barcode_base.fa"}}],"cases":null,"data":null,"section":null,"section_color":"#A492FF"},{"id":702707,"guid":"732FDAE0241511E9B5045FC0FC2F250F","previous_id":702702,"previous_guid":"D8449570241411E9B5045FC0FC2F250F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"1FD80D86D2D3455E8C049B0C1AF1F5D9","order_id":1,"type_id":6,"title":"Section","source":{"title":"Generating Barcode Index"}},{"id":1054724,"guid":"062824FA96EE41038171EEE52A943F98","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Prepare the LAST index for the barcode file. This will generate seven additional files of the form <index name>.XXX:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">lastdb barcode_base.fa barcode_base.fa<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":"#A492FF"},{"id":702708,"guid":"0CD5F620241611E9B5045FC0FC2F250F","previous_id":702707,"previous_guid":"732FDAE0241511E9B5045FC0FC2F250F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"2E8BEA24F2B64E1792EF4D0FFFA651B3","order_id":1,"type_id":6,"title":"Section","source":{"title":"Mapping Reads to Barcodes"}},{"id":1054724,"guid":"285F23E7499642B4AC1FEF1067267083","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Combine all input reads into a single file<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">pv ..\/called_all\/*.fastq | gzip > reads_all.fastq.gz<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>Note: I'm using the pipe viewer command <\/span><span style = \"font-style:italic;\">pv<\/span><span> to produce a progress indicator while the command is running. If this command is not available, it can be replaced with <\/span><span style = \"font-style:italic;\">cat<\/span><span> with no change in function (apart from not showing progess).<\/span><\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":"#FFED92"},{"id":702709,"guid":"784AF6D0241611E9B5045FC0FC2F250F","previous_id":702708,"previous_guid":"0CD5F620241611E9B5045FC0FC2F250F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"3C213DA5C70F49A88F2511C3AD18C623","order_id":1,"type_id":6,"title":"Section","source":{"title":"Mapping Reads to Barcodes"}},{"id":1054724,"guid":"9B811DBEC0F64F2CB9968A907DC2F082","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Use LAST in FASTQ alignment mode (-Q 1) to map the reads. In this example, it is distributed over 10 processing threads (-P 10). Here <\/span><span style = \"font-style:italic;\">maf-convert<\/span><span> is used to convert to a single line per match, <\/span><span style = \"font-style:italic;\">cut<\/span><span> retains only the barcode and read IDs, and <\/span><span style = \"font-style:italic;\">uniq<\/span><span> is used to make sure that multiple same barcodes per read (e.g. for reverse \/ complement barcodes at each end) will not produce duplicates:<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">lastal -Q 1 -P10 barcode_base.fa <(pv reads_all.fastq.gz) | \\<\/div><div class = \"text-block\">  maf-convert tab | grep -v '^#' | cut -f 2,7 | uniq | \\<\/div><div class = \"text-block\">  gzip > barcode_assignments.txt.gz<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">For a more stringent search, the output of lastal can be piped through last-map-probs, which will reduce the likelihood of a partial barcode match to other DNA sequences. The downside is that this is more likely to drop reads due to slight mismatches in the barcode portion of the read:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"><span>lastal -Q 1 -P10 barcode_base.fa <(pv reads_all.fastq.gz) | <\/span><span style = \"font-weight:bold;\">last-map-probs |<\/span><span> \\\n  maf-convert tab | grep -v '^#' | cut -f 2,7 | uniq | \\\n  gzip > barcode_assignments.txt.gz<\/span><\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">The output of this command will be a gzipped tab-separated 2-column file with barcode names in the first column, and read IDs in the second column.<\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":"#FFED92"},{"id":702726,"guid":"F64D6380241911E9B5045FC0FC2F250F","previous_id":702729,"previous_guid":"3965B130242011E9B5045FC0FC2F250F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"C83D1A96B5E94DD190E0921D839CCE9E","order_id":1,"type_id":6,"title":"Section","source":{"title":"Splitting Read File Per Barcode"}},{"id":1054724,"guid":"F5D2260C97154709877A0C83D76D1D72","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Create a file containing barcode read counts<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">pv barcode_assignments.txt.gz | zcat | awk '{print $1}' | \\<\/div><div class = \"text-block\">  sort | uniq -c > barcode_counts.txt<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":"#94EBFF"},{"id":702727,"guid":"044B6E40241B11E9B5045FC0FC2F250F","previous_id":702726,"previous_guid":"F64D6380241911E9B5045FC0FC2F250F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"B1B264EF89F7497885DBC4BEA21CC7D3","order_id":1,"type_id":6,"title":"Section","source":{"title":"Splitting Read File Per Barcode"}},{"id":1054724,"guid":"39EE763B55554A7FBC2F41504A535188","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">For each discovered barcode, find the corresponding read IDs, then extract those IDs out of the read FASTQ file. This uses one of my own scripts, <\/div><div class = \"text-block\"><a style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">fastx-fetch.pl<\/span><\/a><\/div><div class = \"text-block\">, to do this directly from a FASTQ file:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">for bc in $(awk '{print $2}' barcode_counts.txt);<\/div><div class = \"text-block\">  do echo \"** ${bc} **\";<\/div><div class = \"text-block\">  fastx-fetch.pl -i <(zgrep ${bc} barcode_assignments.txt.gz | awk '{print $2}') \\<\/div><div class = \"text-block\">    <(pv reads_all.fastq.gz) | \\<\/div><div class = \"text-block\">    gzip > reads_${bc}.fastq.gz;<\/div><div class = \"text-block\">done<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Or, if working from the non-chimeric reads:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"><span>for bc in $(awk '{print $2}' barcode_counts.txt);\n  do echo \"** ${bc} **\";\n  fastx-fetch.pl -i <(zgrep ${bc} barcode_assignments.txt.gz | awk '{print $2}') \\\n    <(pv <\/span><span style = \"font-weight:bold;\">reads_noChimeric.fastq.gz<\/span><span>) | \\\n    gzip > reads_${bc}.fastq.gz;\ndone<\/span><\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Note: this step processes through the read file once per barcode, which could take a while depending on how many barcodes are detected.<\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":"#94EBFF"},{"id":702728,"guid":"AB0A3D50241C11E9B5045FC0FC2F250F","previous_id":702709,"previous_guid":"784AF6D0241611E9B5045FC0FC2F250F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"EF5A255700C648408696472F3803099B","order_id":1,"type_id":6,"title":"Section","source":{"title":"Optional [but recommended]: filtering chimeric reads"}},{"id":1054724,"guid":"C1BC405CB11344848D80CB2C93A58C18","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Identify reads with multiple barcodes (i.e. potentially chimeric reads). The <\/span><span style = \"font-style:italic;\">sort<\/span><span> command sorts by the second field (read ID), then <\/span><span style = \"font-style:italic;\">uniq <\/span><span>identifies duplicated lines when ignoring the first field (barcode).<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">pv barcode_assignments.txt.gz | zcat | sort -k 2,2 | \\<\/div><div class = \"text-block\">  uniq -f 1 -D | gzip > duplicate_assignments.txt.gz<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":"#A492FF"},{"id":702729,"guid":"3965B130242011E9B5045FC0FC2F250F","previous_id":702728,"previous_guid":"AB0A3D50241C11E9B5045FC0FC2F250F","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"DAAAF4DF79564657B30DD5EEF25E5871","order_id":1,"type_id":6,"title":"Section","source":{"title":"Optional [but recommended]: filtering chimeric reads"}},{"id":1054724,"guid":"4EC1E15EAC694B0EBA812B6DE156BF40","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Exclude duplicate read IDs from the fastq file. This uses one of my own scripts, <\/div><div class = \"text-block\"><a style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">fastx-fetch.pl<\/span><\/a><\/div><div class = \"text-block\">, to do this directly from a FASTQ file.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">~\/scripts\/fastx-fetch.pl -v -i <(zcat duplicate_assignments.txt.gz | \\<\/div><div class = \"text-block\">    awk '{print $2}') <(pv reads_all.fastq) | gzip > reads_noChimeric.fastq.gz<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":"#A492FF"}],"materials":[],"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>This protocol is for a semi-manual method for read demultiplexing, as used after my presentation <\/span><span style = \"font-style:italic;\">Sequencing DNA with Linux Cores and Nanopores<\/span><span> to work out the number of reads captured by different barcodes.<\/span><\/div><div class = \"text-block\">Input: reads as a FASTQ file, barcode sequences as a FASTA file<\/div><div class = \"text-block\">Output: reads split into single FASTQ files per target [barcode]<\/div><div class = \"text-block\">Note: barcode \/ adapter sequences are not trimmed by this protocol<\/div><\/div>","changed_on":1548806448}