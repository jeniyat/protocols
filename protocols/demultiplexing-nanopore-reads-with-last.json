{"id":25381,"title":"Demultiplexing Nanopore reads with LAST","title_html":"Demultiplexing Nanopore reads with LAST","image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bcixa.png","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/bcixa.png"},"doi":"dx.doi.org\/10.17504\/protocols.io.42dgya6","doi_status":2,"uri":"demultiplexing-nanopore-reads-with-last-42dgya6","type_id":1,"published_on":1562042083,"parent_protocols":[],"parent_collections":[],"version_id":2,"created_on":1562038055,"categories":null,"creator":{"name":"David A. Eccles","affiliation":"Malaghan Institute of Medical Research (NZ)","affiliations":[{"affiliation":"Malaghan Institute of Medical Research (NZ)","url":"http:\/\/www.malaghan.org.nz\/","is_default":1}],"username":"david-eccles","link":"https:\/\/doi.org\/10.5281\/zenodo.2535894","image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg"},"badges":[{"id":3,"image":{"source":"\/img\/badges\/silver.svg","placeholder":"\/img\/badges\/silver.svg"},"name":"Power author!"},{"id":6,"image":{"source":"\/img\/badges\/socialbutterfly.svg","placeholder":"\/img\/badges\/socialbutterfly.svg"},"name":"Social butterfly"}],"research_interests":null,"blocked_by_you":false,"blocked_you":false},"journal":null,"journal_name":null,"journal_link":null,"article_citation":null,"public":1,"has_versions":1,"link":"https:\/\/doi.org\/10.5281\/zenodo.2535894","total_collections":0,"number_of_steps":8,"authors":[{"name":"David Eccles","affiliation":"Malaghan Institute of Medical Research (NZ)","affiliations":[],"username":"david-eccles","link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/vi7jpt6.jpg"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false}],"versions":[],"groups":[],"has_subprotocols":0,"is_subprotocol":0,"is_bookmarked":0,"can_be_copied":1,"can_remove_fork":1,"forks_count":{"private":0,"public":0},"access":{"can_view":1,"can_remove":0,"can_add":0,"can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":1,"can_move":1,"can_move_outside":1,"can_transfer":1,"can_download":1,"is_locked":0},"steps":[{"id":774079,"guid":"E5C70C21B90544EF91779EDAB5C49E20","previous_id":null,"previous_guid":null,"modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"A40234CA91C344A992869F0686CA00D3","order_id":1,"type_id":6,"title":"Section","source":{"title":"Generating Barcode Index"}},{"id":1054724,"guid":"259FA4E1C59E4578B32AC0185256F886","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Prepare a FASTA file containing barcode sequences (see attached FASTA file). To reduce the chance of mismatched adapters, this should <\/span><span style = \"font-style:italic;\">only<\/span><span> contain the barcode sequences. That restriction means this approach will not work for short reads, where the barcode sequences are very likely to occur within sequences.<\/span><\/div><\/div>"}},{"id":1054725,"guid":"6D43E4F0241511E9B5045FC0FC2F250F","order_id":2,"type_id":23,"title":"file","source":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bciwa.fa","placeholder":"\/img\/extensions\/file.png","original_name":"barcode_base.fa"}}],"cases":null,"data":null,"section":null,"section_color":"#A492FF","critical":null,"critical_id":null,"duration":0},{"id":774080,"guid":"21079997FEDE4345AEFA989C7EA3E57E","previous_id":774079,"previous_guid":"E5C70C21B90544EF91779EDAB5C49E20","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"B2AC2F07DB624259B86C79B5D3C949B2","order_id":1,"type_id":6,"title":"Section","source":{"title":"Generating Barcode Index"}},{"id":1054724,"guid":"23A7DD0505384A3C809FD65939055125","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Prepare the LAST index for the barcode file. This will generate seven additional files of the form <index name>.XXX:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">lastdb barcode_base.fa barcode_base.fa<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0},{"id":774081,"guid":"D6589F552DB440CE8B8F4E08CCA46653","previous_id":774080,"previous_guid":"21079997FEDE4345AEFA989C7EA3E57E","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"1DA388280D5F448D927FD333F513B217","order_id":1,"type_id":6,"title":"Section","source":{"title":"Mapping Reads to Barcodes"}},{"id":1054724,"guid":"3C1A77FDD68D499FBD8087B4EADA9BAE","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Combine all input reads into a single file<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">pv ..\/called_all\/*.fastq | gzip > reads_all.fastq.gz<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>Note: I'm using the pipe viewer command <\/span><span style = \"font-style:italic;\">pv<\/span><span> to produce a progress indicator while the command is running. If this command is not available, it can be replaced with <\/span><span style = \"font-style:italic;\">cat<\/span><span> with no change in function (apart from not showing progess).<\/span><\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":"#FFED92","critical":null,"critical_id":null,"duration":0},{"id":774082,"guid":"F7D2CD9C0412414AADD691E10276785D","previous_id":774081,"previous_guid":"D6589F552DB440CE8B8F4E08CCA46653","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"65A28930E39C45EC9322ED0BC988056F","order_id":1,"type_id":6,"title":"Section","source":{"title":"Mapping Reads to Barcodes"}},{"id":1054724,"guid":"D006CFCF8DA04676ACD719334F4DAAFD","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Use LAST in FASTQ alignment mode (-Q 1) to map the reads. In this example, it is distributed over 10 processing threads (-P 10). Here <\/span><span style = \"font-style:italic;\">maf-convert<\/span><span> is used to convert to a single line per match, <\/span><span style = \"font-style:italic;\">cut<\/span><span> retains only the barcode and read IDs, and <\/span><span style = \"font-style:italic;\">uniq<\/span><span> is used to make sure that multiple same barcodes per read (e.g. for reverse \/ complement barcodes at each end) will not produce duplicates:<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">lastal -Q 1 -P10 barcode_base.fa <(pv reads_all.fastq.gz) | \\<\/div><div class = \"text-block\">  maf-convert -n tab | cut -f 2,7 | uniq | \\<\/div><div class = \"text-block\">  gzip > barcode_assignments.txt.gz<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">For an extremely stringent search, the output of lastal can be piped through last-map-probs, which will reduce the likelihood of a partial barcode match to other DNA sequences. The downside is that this is more likely to drop reads due to slight mismatches in the barcode portion of the read:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\"><span>lastal -Q 1 -P10 barcode_base.fa <(pv reads_all.fastq.gz) | <\/span><span style = \"font-weight:bold;\">last-map-probs |<\/span><span> \\\n  maf-convert -n tab | cut -f 2,7 | uniq | \\\n  gzip > barcode_assignments.txt.gz<\/span><\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">The output of this command will be a gzipped tab-separated 2-column file with barcode names in the first column, and read IDs in the second column.<\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0},{"id":774083,"guid":"6233152773F9449AAEA79C0B4628381E","previous_id":774085,"previous_guid":"DBF1105858294EE78572D6384A236493","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"8605AA63EAAE4C869E83B9CB944E6840","order_id":1,"type_id":6,"title":"Section","source":{"title":"Splitting Read File Per Barcode"}},{"id":1054724,"guid":"1BE110FD2812455B82E46CF601CE5578","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Create a file containing barcode read counts for the appropriate read category. For example, for non-chimeric reads:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">pv unique_assignments.txt.gz | zcat | awk '{print $1}' | \\<\/div><div class = \"text-block\">  sort | uniq -c > barcode_counts.txt<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Or for all reads:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">pv barcode_assignments.txt.gz | zcat | awk '{print $1}' | \\<\/div><div class = \"text-block\">  sort | uniq -c > barcode_counts.txt<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":"#94EBFF","critical":null,"critical_id":null,"duration":0},{"id":774084,"guid":"E2D11848249045E19255169D7BF568B6","previous_id":774083,"previous_guid":"6233152773F9449AAEA79C0B4628381E","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"C8469FCD84E64EF09C12DC7AA766933A","order_id":1,"type_id":6,"title":"Section","source":{"title":"Splitting Read File Per Barcode"}},{"id":1054724,"guid":"EDC0A277C2214DAD812A4CE441499F14","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">For each discovered barcode, using the appropriate read category assignment file, find the corresponding read IDs, then extract those IDs out of the read FASTQ file. This uses one of my own scripts, <\/div><div class = \"text-block\"><a style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">fastx-fetch.pl<\/span><\/a><\/div><div class = \"text-block\">, to do this directly from a FASTQ file:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">mkdir -p demultiplexed<\/div><div class = \"text-block\">for bc in $(awk '{print $2}' barcode_counts.txt);<\/div><div class = \"text-block\">  do echo \"** ${bc} **\";<\/div><div class = \"text-block\">  fastx-fetch.pl -i <(zgrep \"^${bc}\" unique_assignments.txt.gz | \\<\/div><div class = \"text-block\">    awk '{print $2}') <(pv reads_all.fastq.gz) | \\<\/div><div class = \"text-block\">    gzip > demultiplexed\/reads_${bc}.fastq.gz;<\/div><div class = \"text-block\">done<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Note: this step processes through the read file once per barcode, which could take a while depending on how many barcodes are detected.<\/div><div class = \"text-block\">Or, alternatively, for all reads:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">mkdir -p demultiplexed<\/div><div class = \"text-block\">for bc in $(awk '{print $2}' barcode_counts.txt);<\/div><div class = \"text-block\">  do echo \"** ${bc} **\";<\/div><div class = \"text-block\">  fastx-fetch.pl -i <(zgrep \"^${bc}\" barcode_assignments.txt.gz | \\<\/div><div class = \"text-block\">    awk '{print $2}') <(pv reads_all.fastq.gz) | \\<\/div><div class = \"text-block\">    gzip > demultiplexed\/reads_${bc}.fastq.gz;<\/div><div class = \"text-block\">done<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0},{"id":774085,"guid":"DBF1105858294EE78572D6384A236493","previous_id":774086,"previous_guid":"58DAD87D2DC74602A051F8B818FF5C02","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"CEA490835413405DB489C4E5B385B5DF","order_id":1,"type_id":6,"title":"Section","source":{"title":"Optional [but recommended]: identifying chimeric reads"}},{"id":1054724,"guid":"04CA6260FE8747D7940BDBBFBCA84028","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Identify reads with multiple barcodes (i.e. potentially chimeric reads). This is identical to the last step, except for using '<\/span><span style = \"font-style:italic;\">uniq -D<\/span><span>' to only print <\/span><span style = \"font-style:italic;\">duplicated<\/span><span> reads. This step is only strictly needed when chimeric reads need to be inspected.<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">pv barcode_assignments.txt.gz | zcat | sort -k 2,2 | uniq | \\<\/div><div class = \"text-block\">  uniq -f 1 -D | gzip > duplicate_assignments.txt.gz<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0},{"id":774086,"guid":"58DAD87D2DC74602A051F8B818FF5C02","previous_id":774082,"previous_guid":"F7D2CD9C0412414AADD691E10276785D","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"02DA57B1794B4170BD4228B2CB6D54D6","order_id":1,"type_id":6,"title":"Section","source":{"title":"Optional [but recommended]: identifying chimeric reads"}},{"id":1054724,"guid":"69C35F1890FF4E31950EC183A190E142","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Identify reads with unique barcode classes attached to each read. The <\/span><span style = \"font-style:italic;\">sort<\/span><span> command sorts by the second field (read ID), then <\/span><span style = \"font-style:italic;\">uniq <\/span><span>identifies duplicated lines when ignoring the first field (barcode). Two <\/span><span style = \"font-style:italic;\">uniq<\/span><span> commands are used to allow for the possibility that a sequence could be tailed by matching barcodes at both ends. The downside of this is that it will also collapse chimeric reads with the <\/span><span style = \"font-style:italic;\">same<\/span><span> barcode. This uses '<\/span><span style = \"font-style:italic;\">uniq -u<\/span><span>' to only print the unique lines.<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">pv barcode_assignments.txt.gz | zcat | sort -k 2,2 | uniq | \\<\/div><div class = \"text-block\">  uniq -f 1 -u | gzip > unique_assignments.txt.gz<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":null,"data":null,"section":null,"section_color":null,"critical":null,"critical_id":null,"duration":0}],"materials":[],"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>This protocol is for a semi-manual method for read demultiplexing, as used after my presentation <\/span><span style = \"font-style:italic;\">Sequencing DNA with Linux Cores and Nanopores<\/span><span> to work out the number of reads captured by different barcodes.<\/span><\/div><div class = \"text-block\">Input: reads as a FASTQ file, barcode sequences as a FASTA file<\/div><div class = \"text-block\">Output: reads split into single FASTQ files per target [barcode]<\/div><div class = \"text-block\">Note: barcode \/ adapter sequences are not trimmed by this protocol<\/div><\/div>","changed_on":1562042083}