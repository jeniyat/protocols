{"id":25033,"title":"Processing Single Cell Calling Card Sequencing Data","title_html":"<p>Processing Single Cell Calling Card Sequencing Data<\/p>","image":{"source":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/bs6s4s6w.png","placeholder":"https:\/\/s3.amazonaws.com\/protocols-files\/public\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/bs6s4s6w.png"},"doi":"dx.doi.org\/10.17504\/protocols.io.4phgvj6","doi_status":2,"uri":"processing-single-cell-calling-card-sequencing-dat-4phgvj6","type_id":1,"published_on":1572021076,"parent_protocols":[],"parent_collections":[],"version_id":0,"created_on":1561406769,"categories":null,"creator":{"name":"Arnav Moudgil","affiliation":"Washington University, Saint Louis","affiliations":[{"affiliation":"Washington University, Saint Louis","url":"http:\/\/genetics.wustl.edu\/rmlab\/","is_default":1}],"username":"arnav-moudgil","link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bcqga.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/bcqga.jpg"},"badges":[{"id":3,"image":{"source":"\/img\/badges\/silver.svg","placeholder":"\/img\/badges\/silver.svg"},"name":"Power author!"}],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"journal":null,"journal_name":null,"journal_link":null,"article_citation":null,"public":1,"has_versions":0,"link":null,"total_collections":0,"number_of_steps":20,"authors":[{"name":"Arnav Moudgil","affiliation":"Washington University, Saint Louis","affiliations":[],"username":"arnav-moudgil","link":null,"image":{"source":"https:\/\/s3.amazonaws.com\/pr-journal\/bcqga.jpg","placeholder":"https:\/\/s3.amazonaws.com\/pr-journal\/bcqga.jpg"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},{"name":"Rob Mitra","affiliation":"Washington University, Saint Louis","affiliations":[],"username":"rob-mitra","link":null,"image":{"source":"\/img\/avatars\/013.png","placeholder":"\/img\/avatars\/013.png"},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false}],"versions":[],"groups":[{"id":1136,"uri":"calling-cards","title":"Transposon Calling Cards","image":{"source":"https:\/\/www.protocols.io\/img\/group_placeholder.png","placeholder":"https:\/\/www.protocols.io\/img\/group_placeholder.png"},"tech_support":{"email":null,"phone":null,"hide_contact":0,"use_email":0},"is_member":1,"request":{"id":1136,"uri":"calling-cards","title":"Transposon Calling Cards","image":{"source":"https:\/\/www.protocols.io\/img\/group_placeholder.png","placeholder":"https:\/\/www.protocols.io\/img\/group_placeholder.png"},"tech_support":{"email":null,"phone":null,"hide_contact":0,"use_email":0},"is_member":1,"description":null,"research_interests":null,"website":null,"location":null,"affiliation":null,"status":{"is_visible":true,"access_level":0},"stats":{"files":[],"total_members":0,"total_followers":0,"total_child_groups":0,"total_parent_groups":0,"has_collaborations":0},"user_status":{"is_member":true,"is_confirmed":true,"is_invited":false,"is_owner":true,"is_admin":false,"is_following":false},"join_link":null,"token":null,"owner":{"name":" ","affiliation":null,"affiliations":[],"username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"is_protocol_requested":0,"is_group_requested":0,"is_my":false,"is_request":false,"is_confirmed":1,"is_declined":0,"requester":{"name":" ","affiliation":null,"affiliation_url":null,"username":null,"link":null},"protocol":{"id":0,"title":"Processing Single Cell Calling Card Sequencing Data","title_html":"Processing Single Cell Calling Card Sequencing Data","image":{"source":null,"placeholder":null},"doi":null,"doi_status":0,"uri":"processing-single-cell-calling-card-sequencing-dat-4phgvj6","type_id":1,"published_on":null,"stats":{"number_of_views":0,"number_of_steps":0,"number_of_bookmarks":0,"number_of_comments":0,"number_of_exports":0,"number_of_runs":0,"number_of_votes":0,"is_voted":0},"parent_protocols":[],"parent_collections":[]},"created_on":1572021075,"resolve_on":0,"resolved_user":{"name":" ","affiliation":null,"affiliations":[],"username":null,"link":null,"image":{"source":null,"placeholder":null},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"shared":false}}],"has_subprotocols":0,"is_subprotocol":0,"is_bookmarked":0,"can_be_copied":1,"can_remove_fork":1,"forks_count":{"private":0,"public":0},"access":{"can_view":1,"can_remove":0,"can_add":0,"can_edit":0,"can_publish":0,"can_get_doi":0,"can_share":1,"can_move":1,"can_move_outside":1,"can_transfer":1,"can_download":1,"is_locked":0},"guid":"8AE8B5D1B9DA11E99CA40242AC110005","steps":[{"id":768680,"guid":"818923D096BB11E99CFBC96AD75A56C9","previous_id":null,"previous_guid":null,"modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"40ECD13C0D474B0CB91CD0634AA3E685","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preamble"}},{"id":1054724,"guid":"CDFE13AED2A943FC8080C774E269E8CB","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">The objective of this protocol is to take sequencing reads from single cell calling cards (scCC) library and process them into a CCF (calling card format; .ccf) file. A CCF file is a modified BED file (BED3+3) that concisely enumerates every transposition event in the sequenced library.<\/div><div class = \"text-block\">CCF files typically have six columns:<\/div><div class = \"text-block\"><ol style = \"list-style-type: decimal;\"><li style = \"counter-reset:ol0;\">chrom: chromosome<\/li><li style = \"counter-reset:ol0;\">start: beginning coordinate of the insertion site<\/li><li style = \"counter-reset:ol0;\"><span>end: ending coordinate of the insertion site; since <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> inserts into TTAA's, this typically spans the motif itself.<\/span><\/li><li style = \"counter-reset:ol0;\">count: the number of reads supporting this insertion<\/li><li style = \"counter-reset:ol0;\">strand: + or -, indicating which strand was targetted (optional but highly recommended)<\/li><li style = \"counter-reset:ol0;\">barcode: a string identifying the library or cell from which this insertion originated. For scCC, this is the sequence of the cell barcode.<\/li><\/ol><\/div><div class = \"text-block\">Each line of the final .ccf file represents an independent calling card insertion, and the value in the cell barcode column specifies in which cell this insertion was observed. If your sample is heterogeneous, you may find that your cells can be grouped into biologically meaningful clusters (e.g. different cell types) based on their scRNA-seq expression profiles. In this case, you will have assigned cell barcodes to each cluster, and can use this information to split the .ccf file to generate insertion profiles for each cluster (see Step 19). These split .ccf files can then be used to identify differentially bound loci, or for visualization of TF binding in different clusters.<\/div><div class = \"text-block\">This workflow walks through how to perform quality control, alignment, filtering, and processing of single cell calling card sequencing libraries to generate a .ccf file. This file can then be used in downstream applications, such as visualization on the (legacy) <\/div><div class = \"text-block\"><a href=\"http:\/\/epigenomegateway.wustl.edu\/legacy\/\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">WashU Epigenome Browser<\/span><\/a><\/div><div class = \"text-block\"> (instructions <\/div><div class = \"text-block\"><a href=\"http:\/\/wiki.wubrowse.org\/Calling_card\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">here<\/span><\/a><\/div><div class = \"text-block\">), and as input for peak calling.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","critical":null,"critical_id":null,"duration":0},{"id":785038,"guid":"A1A32800ACA011E998CFE3FD4084EA8D","previous_id":768680,"previous_guid":"818923D096BB11E99CFBC96AD75A56C9","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"F5A90BD85BDF40DC9EE06A8A958C884D","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preamble"}},{"id":1054724,"guid":"0A37C36CD81D4DA299DEEC793B6DFB8C","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>To illustrate the workflow, let's say that we have performed scCC on our favorite transcription factor (YFTF) in a human cell line. We have prepared scRNA-seq and scCC libraries from 10,000 cells transfected with wild-type <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> transposase and 10,000 cells transfected with YFTF-<\/span><span style = \"font-style:italic;\">piggyBac.<\/span><span> Both the wild-type and YFTF transfectants were loaded across two wells each of a Chromium chip.<\/span><\/div><div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/protocols-files.s3.amazonaws.com\/private\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/brp94s6w.png?X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJYFAX46LHRVQMGOA%2F20191025%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20191025T162715Z&X-Amz-SignedHeaders=host&X-Amz-Expires=604800&X-Amz-Signature=a58eebcf7bb3b0e68a692377e3e35db3f372a3ef85f59bec318113f998953695\" \/><\/div><div class = \"text-block\"><span>This image illustrates our example experiment. Two wells have been loaded with <\/span><span style = \"font-style:italic;\">piggyBac-<\/span><span>transfected cells in Row 1 (blue) and two wells with YFTF-<\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> transfectants (pink). The remaining wells, in grey, were empty (loaded with 50% glycerol). After emulsion generation, the resulting libraries\u2013in the row marked by the triangle\u2013were kept separate and processed according to the <\/span><\/div><div class = \"text-block\"><a href=\"https:\/\/protocols.io\/view\/single-cell-calling-cards-library-preparation-xwifpce\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">scCC molecular protocol<\/span><\/a><\/div><div class = \"text-block\">.<\/div><\/div>"}},{"id":1054725,"guid":"0E6CD2F128F0445385F80895042B5811","order_id":2,"type_id":1,"title":"description","source":{"description":"<div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/protocols-files.s3.amazonaws.com\/private\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/brp94s6w.png?X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJYFAX46LHRVQMGOA%2F20191025%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20191025T162715Z&X-Amz-SignedHeaders=host&X-Amz-Expires=604800&X-Amz-Signature=a58eebcf7bb3b0e68a692377e3e35db3f372a3ef85f59bec318113f998953695\" \/><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","critical":null,"critical_id":null,"duration":0},{"id":785043,"guid":"8C83AC30ACAD11E998CFE3FD4084EA8D","previous_id":785038,"previous_guid":"A1A32800ACA011E998CFE3FD4084EA8D","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"AD99A8D0815843C9AD5C26800BB80432","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preamble"}},{"id":1054724,"guid":"E638753A102E4D4C80EBA601AD47E286","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>scCC analysis requires two separate sequencing runs: one for the scRNA-seq library (which will be used for dimensionality reduction and cell type identification) and one for the scCC library (to assign insertions to specific cells). The scRNA-seq library can be sequenced using 10x's standard recommendations and processed using cellranger. <\/span><span style = \"font-weight:bold;\">We will assume this step has already been completed. <\/span><span>This step establishes a set of high-quality cell barcodes from each library; we will cross-reference these with the scCC library to assign insertions to specific cells.<\/span><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","critical":null,"critical_id":null,"duration":0},{"id":785044,"guid":"AB2BA7D0ACAF11E998CFE3FD4084EA8D","previous_id":818803,"previous_guid":"1E7D9C50E0E211E98B8F9D0B138D3EE0","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"3B7A2419C8634481A93AF22074B5CE6A","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preamble"}},{"id":1054724,"guid":"0F5BAA638BF3420183619334022EC4C0","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">In this example, we will be analyzing scCC sequencing run demultiplexed using index 2 only. The read 1 file will contain the cell barcode and UMI, while read 2 will contain the junction between the transposon and the genome. The read 1 and read 2 files are, respectively:<\/div><div class = \"text-block\"><ul style = \"list-style-type:disc;\"><li style = \"counter-reset:ol0;list-style-type:disc;\">PB_YFTF-PB_combined_R1_001.fastq.gz<\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">PB_YFTF-PB_combined_R2_001.fastq.gz<\/li><\/ul><\/div><div class = \"text-block\">Read 1 is 26 bases long: the first 16 bases comprise the cell barcode, while the final 10 bases are the UMI.<\/div><div class = \"text-block\">Read 2 is 50 bases long: the first 2 bp will contain transposon sequence (GG) followed by the 4bp TTAA insertion site; the rest of the read is genomic sequence (and maybe some P7 adapter).<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","critical":null,"critical_id":null,"duration":0},{"id":785046,"guid":"49346470ACB111E998CFE3FD4084EA8D","previous_id":785044,"previous_guid":"AB2BA7D0ACAF11E998CFE3FD4084EA8D","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"3DE53EE2B5C44FDAA5A762C2F5116618","order_id":1,"type_id":6,"title":"Section","source":{"title":"Adapter Trimming"}},{"id":1054724,"guid":"4C9838C79FE846D7817BD558A46AAF34","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">We first ensure that read 2 begins with GGTTAA. If it does, those bases are trimmed (hard clipped) to facilitate genomic alignment. Only reads with perfect matches are carried forward.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">cutadapt \\<\/div><div class = \"text-block\">    -g ^GGTTAA \\<\/div><div class = \"text-block\">    -o PB_YFTF-PB_combined-trim1_R2_001.fastq.gz \\<\/div><div class = \"text-block\">    -p PB_YFTF-PB_combined-trim1_R1_001.fastq.gz \\<\/div><div class = \"text-block\">    --minimum-length 1 \\<\/div><div class = \"text-block\">    --discard-untrimmed \\<\/div><div class = \"text-block\">    -e 0 \\<\/div><div class = \"text-block\">    --no-indels \\<\/div><div class = \"text-block\">    PB_YFTF-PB_combined_R2_001.fastq.gz \\<\/div><div class = \"text-block\">    PB_YFTF-PB_combined_R1_001.fastq.gz<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Typically 70-90% of reads will pass this filter, although there may be sample-dependent variation.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","critical":null,"critical_id":null,"duration":0},{"id":785047,"guid":"513BA3D0ACB211E998CFE3FD4084EA8D","previous_id":785046,"previous_guid":"49346470ACB111E998CFE3FD4084EA8D","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"F585883E9F934675AABFD88D47683BCE","order_id":1,"type_id":6,"title":"Section","source":{"title":"Adapter Trimming"}},{"id":1054724,"guid":"AEFDC574C9FF4E1B9BE96A3864FF1527","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Next, we re-examine the passing reads and trim any reads that end in the P7 adapter that was added during scCC library preparation. This step reduces the amount of non-genomic bases, which should accelerate alignment. Only a small fraction (5-10%) typically have any adapter sequence at all, so the majority of reads pass this filter.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">cutadapt \\<\/div><div class = \"text-block\">    -a AGAGACTGGCAAGTACACGTCGCACTCACCATGANNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG \\<\/div><div class = \"text-block\">    -o PB_YFTF-PB_S1_L001_R2_001.fastq.gz \\<\/div><div class = \"text-block\">    -p PB_YFTF-PB_S1_L001_R1_001.fastq.gz \\<\/div><div class = \"text-block\">    --minimum-length 1 \\<\/div><div class = \"text-block\">    PB_YFTF-PB_combined-trim1_R2_001.fastq.gz \\<\/div><div class = \"text-block\">    PB_YFTF-PB_combined-trim1_R1_001.fastq.gz<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Here, NNNNNNNNN indicates where the index 1 sequence would be. The N's do not have to be replaced as cutadapt can tolerate ambiguous bases.<\/div><\/div>"}},{"id":1054725,"guid":"16DB591BCA804EC19A249DF4FAC9E000","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\">For running cellranger in next step, the input FASTQ filenames MUST conform to the following pattern:<\/div><div class = \"text-block\">[Sample Name]_S1_L00[Lane Number]_[Read Type]_001.fastq.gz<\/div><div class = \"text-block\">[Read Type] is R1 or R2. [Lane Number] can be varied; for simplicity, we use L001 here.<\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#94EBFF","critical":null,"critical_id":null,"duration":0},{"id":785050,"guid":"A70DE560ACB311E998CFE3FD4084EA8D","previous_id":785047,"previous_guid":"513BA3D0ACB211E998CFE3FD4084EA8D","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"80FBA07C265E4C4D9D8A18962CABB695","order_id":1,"type_id":6,"title":"Section","source":{"title":"Alignment"}},{"id":1054724,"guid":"64E1C06AB8C945F4847E010A674C9066","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Now that our reads are trimmed, we are ready to align them to the genome. At the same time, we need to perform error-correction on our cell barcode and UMI sequences. We will use cellranger, as it can perform both whole-genome alignment and barcode curation at once. We need to specify the directory where the trimmed FASTQ files can be found. Note that this directory should be \"flat\", i.e have no subdirectories.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">cellranger count \\<\/div><div class = \"text-block\">    --id=PB_YFTF-PB_map_scCC \\<\/div><div class = \"text-block\">    --fastqs=fastq_dir\/ \\<\/div><div class = \"text-block\">    --transcriptome=\/opt\/refdata-cellranger-GRCh38-3.0.0 \\<\/div><div class = \"text-block\">    --sample=PB_YFTF-PB \\<\/div><div class = \"text-block\">    --expect-cells=5000 \\<\/div><div class = \"text-block\">    --nosecondary \\<\/div><div class = \"text-block\">    --chemistry=SC3Pv2 \\<\/div><div class = \"text-block\">    --localcores=16 \\<\/div><div class = \"text-block\">    --localmem=30<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">A few notes on this command:<\/div><div class = \"text-block\"><ul style = \"list-style-type:disc;\"><li style = \"counter-reset:ol0;list-style-type:disc;\">--id= will specify the output directory that will be created. This will be familiar to anyone who was worked with cellranger before.<\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">--expect-cells= is an estimate for how many cells are present in the libray. This is much more important for scRNA-seq libraries than scCC libraries, and so can probably be safely excluded.<\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">--nosecondary skips the dimensionality reduction step of the cellranger pipeline. We are only concerned with mapping insertions to the genome.<\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">--chemistry= specifies the chemistry of the 10x kit. We prefer to explicitly specify this. Here, we used version 2 of the single cell 3' kit. The scCC workflow should also be immediately compatible with v3 chemistry.<\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">--localcores= and --localmem=30 specify machine settings. Here, we used 16 cores and 30 GB of memory. These can be adjusted to fit your setup.<\/li><\/ul><\/div><\/div>"}},{"id":1054725,"guid":"22C231C0F5EF46A0B469126C2430646E","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\"><span>cellranger automatically performs barcode whitelisting and error-correction of UMIs, which are encoded in the program's output .bam file. The <\/span><span style = \"font-weight:bold;\">CB<\/span><span> tag contains the read's verified cell barcode, and the<\/span><span style = \"font-weight:bold;\"> UB<\/span><span> tag denotes the corrected UMI. A full description of cellranger BAM tags can be found <\/span><a href=\"https:\/\/support.10xgenomics.com\/single-cell-gene-expression\/software\/pipelines\/latest\/output\/bam\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">here<\/span><\/a><span style = \":;\">.<\/span><\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","critical":null,"critical_id":null,"duration":0},{"id":785052,"guid":"95E6D870ACB611E998CFE3FD4084EA8D","previous_id":785050,"previous_guid":"A70DE560ACB311E998CFE3FD4084EA8D","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"4928C4816D95444CBBACE2D0E39638E2","order_id":1,"type_id":6,"title":"Section","source":{"title":"Alignment"}},{"id":1054724,"guid":"0D621C50D5EB4704A631DCEF6B211BA7","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">We then filter mapped reads for primary alignments, to eliminate multi-mapped reads:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">samtools view \\<\/div><div class = \"text-block\">    -b -h -F 260 \\<\/div><div class = \"text-block\">    -o PB_YFTF-PB_map_scCC_uniq.bam \\<\/div><div class = \"text-block\">    PB_YFTF-PB_map_scCC\/outs\/possorted_genome_bam.bam<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#84CE84","critical":null,"critical_id":null,"duration":0},{"id":785053,"guid":"9BE9BC50ACB711E99D97F1C3C8AA4F58","previous_id":785052,"previous_guid":"95E6D870ACB611E998CFE3FD4084EA8D","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"D01BCD6647BE44A1B7BB4E2283886A96","order_id":1,"type_id":6,"title":"Section","source":{"title":"Annotation"}},{"id":1054724,"guid":"78AF35E546294EA4931CD35C09837BE6","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">As when <\/div><div class = \"text-block\"><a href=\"https:\/\/www.protocols.io\/view\/processing-bulk-calling-card-sequencing-data-xwjfpcn\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">processing bulk RNA calling card data<\/span><\/a><\/div><div class = \"text-block\">, we annotate the filtered BAM file with various tags to connect reads to insertion sites. A usefule side effect of this is that the tagged BAM serves as an archive of a scCC experiment. We use the following custom tags for scCC libraries:<\/div><div class = \"text-block\"><ul style = \"list-style-type:disc;\"><li style = \"counter-reset:ol0;list-style-type:disc;\">XI: insertion site annotation<\/li><li style = \"counter-reset:ol0;list-style-type:disc;\">XZ: adjacent sequence (to verify transposase motif)<\/li><\/ul><\/div><div class = \"text-block\">(The XP, XJ, and XK tags are only used in bulk RNA calling cards.)<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","critical":null,"critical_id":null,"duration":0},{"id":785054,"guid":"113B9C30ACB811E99D97F1C3C8AA4F58","previous_id":785053,"previous_guid":"9BE9BC50ACB711E99D97F1C3C8AA4F58","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"6AB52DAF8B0040B9BE88C60936C6FB95","order_id":1,"type_id":6,"title":"Section","source":{"title":"Annotation"}},{"id":1054724,"guid":"F7F5999E630049F1A55DE9D432DDA111","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Now we will annotate reads with respect to the insertion site. This script checks each read to make sure that it maps next to the <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> insertion site motif TTAA. Remember, this part of read 1 was trimmed in step 5. By double checking that the read maps next to a genomic TTAA, we add an extra layer of specificity to the alignment. The sequence of the adjacent bases will also be annotated with the XZ tag. Reads that pass will be annotated with the insertion site coordinates in the XI tag and written to the output file.<\/span><\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python AnnotateInsertionSites.py \\<\/div><div class = \"text-block\">    --transposase PB \\<\/div><div class = \"text-block\">    -f \\<\/div><div class = \"text-block\">    PB_YFTF-PB_map_scCC_uniq.bam \\<\/div><div class = \"text-block\">    hg38.2bit \\<\/div><div class = \"text-block\">    PB_YFTF-PB_map_scCC_tagged.bam<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">You can provide a path to the .2bit file if your genome references are in another directory.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","critical":null,"critical_id":null,"duration":0},{"id":785058,"guid":"4DAF6110ACB811E99D97F1C3C8AA4F58","previous_id":785054,"previous_guid":"113B9C30ACB811E99D97F1C3C8AA4F58","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"93D91B4EF4F846058A3D090AA0FA14DD","order_id":1,"type_id":6,"title":"Section","source":{"title":"Annotation"}},{"id":1054724,"guid":"96E523FB3B584D7C8E0D94D4F3190A49","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">We perform one last quality control check on the processed scCC reads. Since scCC libraries involve intramolecular circularization, there is a small chance that concatamerization can occur. These would appear as singleton events where a cell barcode and UMI are linked to an insertion in a different cell. To guard against this, we require all insertions in a given cell (i.e. sharing the same cell barcode) to have at least two different UMIs each. This yields libraries with excellent specificity (see e.g. Figure 3B in our <\/div><div class = \"text-block\"><a href=\"https:\/\/www.biorxiv.org\/content\/10.1101\/538553v2\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">preprint<\/span><\/a><\/div><div class = \"text-block\">)<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python UMIFilter.py \\<\/div><div class = \"text-block\">    -p 10x \\<\/div><div class = \"text-block\">    -i PB_YFTF-PB_map_scCC_tagged.bam \\<\/div><div class = \"text-block\">    --verbose \\<\/div><div class = \"text-block\">    -o PB_YFTF-PB_map_scCC_final.bam<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","critical":null,"critical_id":null,"duration":0},{"id":787235,"guid":"A2C76740AF1211E9A47B8D915F52C5E7","previous_id":785058,"previous_guid":"4DAF6110ACB811E99D97F1C3C8AA4F58","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"E4C82F8F5D514C0C874C76CBFC820067","order_id":1,"type_id":6,"title":"Section","source":{"title":"Annotation"}},{"id":1054724,"guid":"A13F4EF3DE3C4C80A38FE795726857BC","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Finally, we convert this BAM file to a (sorted) CCF file. The sorting step relies on bedops; see <\/div><div class = \"text-block\"><a href=\"https:\/\/www.protocols.io\/view\/processing-bulk-calling-card-sequencing-data-xwjfpcn?step=15\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">here<\/span><\/a><\/div><div class = \"text-block\"> for alternatives.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python BamToCallingCard.py \\<\/div><div class = \"text-block\">    -b CB \\<\/div><div class = \"text-block\">    -i PB_YFTF-PB_map_scCC_final.bam \\<\/div><div class = \"text-block\">    -o PB_YFTF-PB_map_scCC_unsorted.ccf<\/div><div class = \"text-block\">sort-bed PB_YFTF-PB_map_scCC_unsorted.ccf > PB_YFTF-PB_map_scCC_final.ccf<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#FFED92","critical":null,"critical_id":null,"duration":0},{"id":787236,"guid":"EC5200A0AF1211E9A47B8D915F52C5E7","previous_id":787235,"previous_guid":"A2C76740AF1211E9A47B8D915F52C5E7","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"8888717CB9614C16931A435D7E3F0A30","order_id":1,"type_id":6,"title":"Section","source":{"title":"Demultiplexing"}},{"id":1054724,"guid":"D8AB867E375E4922A24526431F6FF721","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>At this point, PB_YFTF-PB_map_scCC_final.bam contains all insertions from all cells in our single cell library, both from the wild-type <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> transfectants and the YFTF-<\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> transfectants. How can we determine which insertions came from which library? We will use the cell barcodes to further demultiplex the CCF file.<\/span><\/div><div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/protocols-files.s3.amazonaws.com\/private\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/brqd4s6w.png?X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJYFAX46LHRVQMGOA%2F20191025%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20191025T162715Z&X-Amz-SignedHeaders=host&X-Amz-Expires=604800&X-Amz-Signature=053caaf47698ee6f20a403e46c1b586e497fa0b093400ca32ba15c5669a9abf8\" \/><\/div><div class = \"text-block\"><span>This figure summarizes Steps 15-18, wherein we use the cell barcodes (obtained from the respective scRNA-seq libraries) to demultiplex the combined scCC .bam file, generate .ccf files from each library, and finally create master .ccf files for each condition (i.e. <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> and YFTF-<\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> treatments).<\/span><\/div><\/div>"}},{"id":1054725,"guid":"1ED2C486D34141939EBE7546D9C46317","order_id":2,"type_id":1,"title":"description","source":{"description":"<div style = \"text-align :; float : ;\"><img style = \"\" src = \"https:\/\/protocols-files.s3.amazonaws.com\/private\/c0fce444e2276efcc5c6b74fda092b0910da446fb1cb11be6b22e2950eeceed4\/brqd4s6w.png?X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAJYFAX46LHRVQMGOA%2F20191025%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20191025T162715Z&X-Amz-SignedHeaders=host&X-Amz-Expires=604800&X-Amz-Signature=053caaf47698ee6f20a403e46c1b586e497fa0b093400ca32ba15c5669a9abf8\" \/><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#EA9F6C","critical":null,"critical_id":null,"duration":0},{"id":787237,"guid":"E20B5BC0AF1511E9A47B8D915F52C5E7","previous_id":818804,"previous_guid":"2E089DC0E0E511E98B8F9D0B138D3EE0","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"0C432C5AFF9E4BA78BFEC47D1C670DF7","order_id":1,"type_id":6,"title":"Section","source":{"title":"Demultiplexing"}},{"id":1054724,"guid":"A580074C8AF449B0A6758F9981A1B058","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Since GEM generation was performed independently for each sample, there is a small chance (see note below) that the same cell barcode was captured more than once across libraries. This could, in theory, confound interpretation of TF binding, as a shared cell barcode may belong to cells of different types or states. While the effect of these is likely small, we recommend discarding shared barcodes between libraries. The following command takes in a set of barcode files; for each, an output file is created containing the subset of unique barcodes found only in the respective input file.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python UMIFilter.py \\<\/div><div class = \"text-block\">    -i PB-1\/outs\/filtered_gene_bc_matrices\/hg38\/barcodes.tsv \\<\/div><div class = \"text-block\">       PB-2\/outs\/filtered_gene_bc_matrices\/hg38\/barcodes.tsv \\<\/div><div class = \"text-block\">       YFTF-1\/outs\/filtered_gene_bc_matrices\/hg38\/barcodes.tsv \\<\/div><div class = \"text-block\">       YFTF-2\/outs\/filtered_gene_bc_matrices\/hg38\/barcodes.tsv \\<\/div><div class = \"text-block\">    -o PB-1_unique_barcodes.txt \\<\/div><div class = \"text-block\">       PB-2_unique_barcodes.txt \\<\/div><div class = \"text-block\">       YFTF-1_unique_barcodes.txt \\<\/div><div class = \"text-block\">       YFTF-2_unique_barcodes.txt<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">Note that this can command can take in any number of input files (2, 3, 4, 5, etc.). The only requirements are: (1) a matched list of output files is provided; and (2) the input barcode files contain one barcode per line.<\/div><\/div>"}},{"id":1054725,"guid":"10931500E0B542C7B3E149E629E5BD2F","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\">For the curious: the probability of a shared barcode (i.e. barcode collision) between two 10x scRNA-seq libraries is quite small, but is dependent on library size. For two libraries of 5,000 cells each, the probability is < 1%. As the number of libraries increases, the probability of collision increases approximately. We have filtered unique cell barcodes across as many as six libraries and have discarded no more than 5% of total cell barcodes.<\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#EA9F6C","critical":null,"critical_id":null,"duration":0},{"id":787299,"guid":"5455F240AF1A11E9A47B8D915F52C5E7","previous_id":787237,"previous_guid":"E20B5BC0AF1511E9A47B8D915F52C5E7","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"1317EE19B7E8451189AC0D4EFF7FEF27","order_id":1,"type_id":6,"title":"Section","source":{"title":"Demultiplexing"}},{"id":1054724,"guid":"366FE56A07A9437D9EF35F6BBE1E5AE9","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">Now that we have a list of cell barcodes unique to each library, we can demultiplex our calling card BAM file. The example show is for PB_1 but can be generalized to all samples.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python FilterBAMByBarcodes.py \\<\/div><div class = \"text-block\">    -i PB_YFTF-PB_map_scCC_final.bam<\/div><div class = \"text-block\">    -b PB-1_unique_barcodes.txt \\<\/div><div class = \"text-block\">    -o PB-1_scCC_final.bam<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\">We can now convert this BAM file to CCF output.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python BamToCallingCard.py \\<\/div><div class = \"text-block\">    -b CB \\<\/div><div class = \"text-block\">    -i PB-1_scCC_final.bam \\<\/div><div class = \"text-block\">    -o PB-1_scCC_unsorted.ccf<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"><span>We can also combine the two wild-type <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> libraries into a single, sorted CCF file. (The second step requires bedops; see <\/span><\/div><div class = \"text-block\"><a href=\"https:\/\/www.protocols.io\/view\/processing-bulk-calling-card-sequencing-data-xwjfpcn?step=15\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">here<\/span><\/a><\/div><div class = \"text-block\"> for alternative sorting commands).<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">cat PB-1_scCC_unsorted.ccf PB-2_scCC_unsorted.ccf | sort-bed - > PB_scCC_final.ccf<\/div><div class = \"text-block\">cat YFTF-PB-1_scCC_unsorted.ccf YFTF-PB-2_scCC_unsorted.ccf | sort-bed > YFTF-PB_scCC_final.ccf<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#EA9F6C","critical":null,"critical_id":null,"duration":0},{"id":787303,"guid":"630BBED0AF1C11E9A47B8D915F52C5E7","previous_id":787299,"previous_guid":"5455F240AF1A11E9A47B8D915F52C5E7","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"588BB75BEB2243EAB3AC20F1B58FC651","order_id":1,"type_id":6,"title":"Section","source":{"title":"Demultiplexing"}},{"id":1054724,"guid":"BF8BF1CAB49148878EE67081DCE78D6A","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">At last, we have a CCF file containing all insertions across all (unique) cells in a scCC experiment. This file can be further visualized on the WashU Epigenome Browser and used as input for peak calling. Here is an example of scCC CCF output.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">chr1\t29884\t29888\t3\t+\tGCATGATCAGACGTAG-1<\/div><div class = \"text-block\">chr1\t30355\t30359\t4\t-\tCAGCTGGTCGCAAACT-1<\/div><div class = \"text-block\">chr1\t32116\t32120\t11\t-\tGTGTGCGAGCTTCGCG-1<\/div><div class = \"text-block\">chr1\t32303\t32307\t674\t+\tGTCGTAAAGGTAGCTG-1<\/div><div class = \"text-block\">chr1\t33031\t33035\t2\t-\tTTAGTTCTCAACACTG-1<\/div><div class = \"text-block\">chr1\t33031\t33035\t21\t+\tGCAATCAGTGGTTTCA-1<\/div><div class = \"text-block\">chr1\t33031\t33035\t25\t+\tGCACTCTAGTAGCCGA-1<\/div><div class = \"text-block\">chr1\t33031\t33035\t98\t+\tGTTTCTACAGACGCAA-1<\/div><div class = \"text-block\">chr1\t33169\t33173\t26\t-\tCAAGAAAGTACAGCAG-1<\/div><div class = \"text-block\">chr1\t34572\t34576\t4\t-\tCGTTCTGCAAATTGCC-1<\/div><\/div><\/code><\/pre><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#EA9F6C","critical":null,"critical_id":null,"duration":0},{"id":787304,"guid":"BFFE2600AF1C11E9A47B8D915F52C5E7","previous_id":787303,"previous_guid":"630BBED0AF1C11E9A47B8D915F52C5E7","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"F072C0F4BC88483EAC75CE985F504696","order_id":1,"type_id":6,"title":"Section","source":{"title":"Notes"}},{"id":1054724,"guid":"0C8467F5C1E549EE895BA4FB22BED55E","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">In the course of analzying your scRNA-seq data, you may find biologically meaningful clusters and may wish to identify differentially bound loci. Let us suppose that in the your analysis of the YFTF-PB transfectants, you find two clusters of cells (Alfa and Bravo) and wish to stratify insertions specific to each cluster. If the cell barcodes in each cluster are in Barcodes_Alfa.txt and Barcodes_Bravo.txt, we can directly filter insertions from the YFTF-PB CCF file, instead of going back to the BAM file.<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">python FilterCCFByBarcodes.py \\<\/div><div class = \"text-block\">    -i YFTF-PB_scCC_final.ccf \\<\/div><div class = \"text-block\">    -b Barcode_Alfa.txt \\<\/div><div class = \"text-block\">    -o YFTF-PB_scCC_Alfa.ccf<\/div><div class = \"text-block\">python FilterCCFByBarcodes.py \\<\/div><div class = \"text-block\">    -i YFTF-PB_scCC_final.ccf \\<\/div><div class = \"text-block\">    -b Barcode_Bravo.txt \\<\/div><div class = \"text-block\">    -o YFTF-PB_scCC_Bravo.ccf<\/div><\/div><\/code><\/pre><\/div><div class = \"text-block\"> Note that if the input CCF file is sorted, the output file should automatically be sorted as well.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#E57785","critical":null,"critical_id":null,"duration":0},{"id":787305,"guid":"B9116C70AF1D11E9A47B8D915F52C5E7","previous_id":787304,"previous_guid":"BFFE2600AF1C11E9A47B8D915F52C5E7","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"66B6FF821E4C4B769981AE3839ED9914","order_id":1,"type_id":6,"title":"Section","source":{"title":"Notes"}},{"id":1054724,"guid":"2FEE295C3E684BE6A5DAC5F52E0A24D9","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Currently, the scCC pipeline <\/span><span style = \"font-weight:bold;\">does not <\/span><span>support 10x scRNA-seq libraries merged using <\/span><span style = \"font-style:italic;\">cellranger aggr<\/span><span>. Guidance on this will be provided in the future.<\/span><\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#E57785","critical":null,"critical_id":null,"duration":0},{"id":818803,"guid":"1E7D9C50E0E211E98B8F9D0B138D3EE0","previous_id":785043,"previous_guid":"8C83AC30ACAD11E998CFE3FD4084EA8D","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"DC70E6B6ED39400CAF835CDF091C24D8","order_id":1,"type_id":6,"title":"Section","source":{"title":"Preamble"}},{"id":1054724,"guid":"BBC02676132D471DA3D2D12AF174A185","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">The scCC library should have been sequenced as recommended in our <\/div><div class = \"text-block\"><a href=\"https:\/\/protocols.io\/view\/single-cell-calling-cards-library-preparation-xwifpce\" style = \"text-decoration:underline;color:blue;cursor:pointer;\"><span style = \":;\">scCC molecular workflow<\/span><\/a><\/div><div class = \"text-block\">. Specifically, on a dual indexed-compatible Illumina sequencer; we prefer to sequence these libraries on an Illumina NextSeq 500 with 50% phiX, allocating 26 bases to read 1, 50 bases to read 2, and 8 bases each to index 1 and index 2. Although scCC libraries should be demultiplexable with unique index sequences, this does not always work and the index 1 read can fail, reporting all N's. If this happens, reads from all libraries will be mixed together. We can identify scCC reads from phiX and other artifacts by demultiplexing with the index 2 read (should be GCGTCAAT). To further identify reads from the constituent libraries, we will demultiplex using the cell barcode.<\/div><\/div>"}}],"cases":[],"data":null,"section":null,"section_color":"#A492FF","critical":null,"critical_id":null,"duration":0},{"id":818804,"guid":"2E089DC0E0E511E98B8F9D0B138D3EE0","previous_id":787236,"previous_guid":"EC5200A0AF1211E9A47B8D915F52C5E7","modified_on":0,"protocol_id":0,"components":[{"id":1054723,"guid":"CAD38B2F7D474F5B8F774AFC333C6F09","order_id":1,"type_id":6,"title":"Section","source":{"title":"Demultiplexing"}},{"id":1054724,"guid":"B94CC70BB2EE4D37AE7EDF62006D9A32","order_id":1,"type_id":1,"title":"description","source":{"description":"<div class = \"text-blocks\"><div class = \"text-block\">In step 2, we prepared our 10x libraries by loading four wells of the Chromium chip: two for wild-type PB, and two for YFTF-PB. Let us call these libraries PB-1, PB-2, YFTF-1, and YFTF-2; further, assume that we have completed the scRNA-seq portions of the scCC workflow, including analysis with cellranger. For each of these four libraries, we can get a list of high-quality barcodes.<\/div><div class = \"text-block\">After cellranger has finished, each library's cell barcodes can be found in the following locations, respectively:<\/div><div class = \"text-block\"><pre><code><div class = \"text-blocks\"><div class = \"text-block\">PB-1\/outs\/filtered_gene_bc_matrices\/hg38\/barcodes.tsv<\/div><div class = \"text-block\">PB-2\/outs\/filtered_gene_bc_matrices\/hg38\/barcodes.tsv<\/div><div class = \"text-block\">YFTF-1\/outs\/filtered_gene_bc_matrices\/hg38\/barcodes.tsv<\/div><div class = \"text-block\">YFTF-2\/outs\/filtered_gene_bc_matrices\/hg38\/barcodes.tsv<\/div><\/div><\/code><\/pre><\/div><\/div>"}},{"id":1054725,"guid":"AAC6C414D4934454B5A05767A1D12B0A","order_id":2,"type_id":26,"title":"notes","source":{"id":0,"parent_id":0,"uri":"","title":"","body":"<div class = \"text-blocks\"><div class = \"text-block\">Starting with cellranger v3, the barcodes.tsv file may be gzipped (barcodes.tsv.gz). If that is the case, you will need to unzip before proceeding (gunzip barcodes.tsv.gz)<\/div><\/div>","created_on":0,"changed_on":0,"creator":{"name":" ","affiliation":"","affiliations":[],"username":"","link":null,"image":{"source":"","placeholder":""},"badges":[],"research_interests":null,"blocked_by_you":false,"blocked_you":false,"hide_following":false},"comments":[]}}],"cases":[],"data":null,"section":null,"section_color":"#EA9F6C","critical":null,"critical_id":null,"duration":0}],"document":null,"materials":[],"description":"<div class = \"text-blocks\"><div class = \"text-block\"><span>Here we present a computational pipeline for processing single cell calling card (scCC) data. These data will have been generated from single cell RNA-seq libraries following transfection\/-duction of either undirected <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span> transposase or your favorite transcription factor (YFTF) fused to <\/span><span style = \"font-style:italic;\">piggyBac<\/span><span>. This workflow demonstrates how to process scCC sequencing data derived from a 10x Chromium-based scCC library; the workflow can be parallelized on distributed computing architectures (e.g. slurm).<\/span><\/div><\/div>","changed_on":1572021076}